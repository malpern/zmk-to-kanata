# ZMK to Kanata Converter: Development Plan and Status

## 1. Overview and Goals

The ZMK to Kanata Converter is a tool designed to convert ZMK keymap files (using DTS - Device Tree Source) into the Kanata configuration format.

**Key Goals:**
- Provide robust parsing of ZMK keymap files, including complex DTS structures.
- Support a comprehensive set of ZMK features:
    - Basic keymap structures and layers.
    - Advanced behaviors: Hold-tap (with configurable timing and flavors), layer switching (momentary, toggle, to-layer), sticky keys, macros.
    - Transparent keys.
- Handle matrix layouts, including automatic size detection where possible.
- Minimize external dependencies (e.g., by bundling ZMK header files).
- Produce clean, readable Kanata output.
- Offer both a command-line interface (CLI) and a Python API.

## 2. Architecture

The conversion process follows a DTS-based pipeline:

```
Input ZMK File (.zmk/.dts)
     |
     V
DTS Preprocessor (cpp)
     |
     V
DTS Parser (generates AST)
     |
     V
Keymap Extractor (extracts structured data from AST)
     |
     V
Behavior Transformers (convert ZMK behaviors to Kanata equivalents)
     |
     V
Kanata Output Generation (.kbd)
```

**Key Components:**

1.  **DTS Preprocessor (`converter/dts/preprocessor.py`):**
    *   Integrates with a C preprocessor (`cpp`).
    *   Manages include paths and bundled ZMK header files.
    *   Aims to preserve necessary DTS directives.
    *   Handles matrix size detection.
    *   Platform-specific command execution.

2.  **AST Implementation (`converter/dts/ast.py`):**
    *   Defines classes for the Abstract Syntax Tree: `DtsNode`, `DtsProperty`.
    *   `DtsRoot`: Represents the root of the AST, manages the overall tree, and handles label mapping for reference resolution.

3.  **DTS Parser (`converter/dts/parser.py`):**
    *   Tokenizes the preprocessed DTS content.
    *   Parses tokens into an AST according to DTS syntax rules.
    *   Handles property values, node structures, labels, and references.
    *   Includes error reporting for syntax issues.

4.  **Keymap Extractor (`converter/dts/extractor.py`):**
    *   Traverses the AST generated by the `DtsParser`.
    *   Extracts keymap information: layers, behaviors, bindings.
    *   Resolves references and parameters.

5.  **Behavior Transformers (various files in `converter/transformer/` and `converter/behaviors/`):**
    *   Dedicated modules for specific ZMK behaviors:
        *   Hold-tap (`holdtap_transformer.py`): Handles flavors, timing, quick-tap.
        *   Layer (`layer_transformer.py`): Manages layer switching.
        *   Macros (`macro_transformer.py`, `key_sequence.py`): Parses key sequences and timings.
        *   Sticky Keys (`sticky_key_transformer.py`): Handles sticky key behavior.
    *   Translate ZMK behavior models into Kanata-compatible definitions.

6.  **Kanata Output Generator (`converter/transformer/kanata_transformer.py`):**
    *   Takes the extracted and transformed keymap data.
    *   Generates the final Kanata configuration file content.

## 3. Current Development Status (Post-Initial DtsRoot/AST Fixes)

The project has undergone a significant refactor to a DTS-based parsing system. Initial efforts focused on fixing fundamental issues with `DtsRoot` instantiation and AST API usage across the parser, extractor, and test suites. Many structural `TypeError` and `AttributeError` issues related to `DtsRoot` have been resolved.

**Component Status (Updated View):**

*   **Models (`converter/models.py`):** Believed to be largely stable.
*   **DTS Parser (`converter/dts/parser.py`):**
    *   The primary focus of ongoing debugging.
    *   Correctly instantiates `DtsRoot` by first building a `DtsNode` tree.
    *   **Known Issue:** The logic within `_parse_node_body` for handling child node definitions (both direct and labeled) and property parsing appears to have several remaining bugs. This leads to `TypeError: DtsNode.__init__() missing 1 required positional argument: 'name'` when child nodes are created, and various `DtsParseError`s (e.g., "Expected '{' after node...") indicating the parser is losing its place or misinterpreting tokens.
*   **AST Definition (`converter/dts/ast.py`):**
    *   `DtsNode`, `DtsProperty`, and `DtsRoot` definitions are largely stable. `DtsRoot` now correctly initializes `label_to_node`.
*   **AST Extractor (`converter/dts/extractor.py`):**
    *   Updated to use the correct AST API (e.g., `ast.children` instead of `ast.root.children`). Its correctness heavily depends on a well-formed AST from the parser.
*   **DTS Preprocessor (`converter/dts/preprocessor.py`):**
    *   Integrates with `cpp`.
    *   **Known Issues (Carryover):**
        *   Incorrect default include path initialization.
        *   Potential mis-handling of non-standard C preprocessor directives.
        *   Error handling for `cpp` failures.
*   **Behavior Transformers & Kanata Transformer:** Functionality depends on a correct AST from the parser and extractor.
*   **Main & CLI Scripts:** Stability depends on the underlying library components.
*   **Test Suite:** Many tests updated to reflect `DtsRoot` API changes. Remaining failures are now more indicative of parser logic errors.

## 4. Known Issues and Current Test Failures (Post-Initial DtsRoot/AST Fixes)

The test suite (`pytest`) currently shows **38 failed tests and 34 passed tests**. (Previously 49 failed, 23 passed before `DtsRoot` and AST access fixes).

*   **Dominant Parser Logic Errors:**
    *   `TypeError: DtsNode.__init__() missing 1 required positional argument: 'name'`: This error occurs in multiple tests and points to `DtsParser._parse_node_body` failing to correctly extract or pass the `name` when attempting to instantiate a child `DtsNode`.
    *   `converter.dts.error_handler.DtsParseError: Expected '{ ' after node ... Found ... instead.`: Various instances of this error (e.g., `Expected '{ ' after node 'default_layer'. Found 'bindings' instead.`) indicate the parser is not correctly identifying the start of a child node's body, likely due to issues in token consumption or state management within `_parse_node_body` when processing node labels, names, or properties.
*   **Preprocessor Errors (Carryover):**
    *   `PreprocessorError: ... invalid preprocessing directive ...`
    *   `AssertionError: assert ['/Volumes/Fl.../dts/include'] == []` in `test_preprocessor_initialization`.
    *   `FileNotFoundError` when `PreprocessorError` is expected in `test_preprocessor_error_handling_invalid_cpp_command`.
*   **Main Script Failures (Carryover, likely symptoms of parser errors):** Some `tests/test_main.py` failures persist.
*   **Assertion Errors in specific tests (e.g., `tests/dts/test_parser.py`):** Some assertion values in tests might still be based on previous incorrect parsing behavior and may need adjustment once the parser is more stable. For example, `assert default_layer.properties["bindings"].value == ['&kp A', '&kp B', '&kp C']` might be failing if the parser isn't extracting bindings correctly.

## 5. Immediate Next Steps (Action Plan Refined)

The primary goal is to stabilize the `DtsParser._parse_node_body` method.

1.  **Deep Dive into `DtsParser._parse_node_body`:**
    *   **Focus on `TypeError: DtsNode.__init__() missing 'name'`:**
        *   Trace execution for a failing test case (e.g., one that triggers this TypeError).
        *   Examine how `actual_node_name` is derived before `child = DtsNode(name=actual_node_name)` is called.
        *   Verify token consumption leading up to child node instantiation.
    *   **Focus on `DtsParseError: Expected '{ ' after node ...`:**
        *   Trace execution for a test case triggering this.
        *   Examine the conditions under which the parser expects a `{` and what token it's actually encountering.
        *   Pay close attention to the logic handling properties vs. child nodes, and how labels are processed before expecting a node name and then `{`.
2.  **Incremental Test-Driven Refinement:**
    *   For each specific parsing bug identified, create the smallest possible DTS snippet that reproduces it in a new, focused unit test if one doesn't already exist.
    *   Fix the parser logic to make that specific test pass, ensuring no regressions in already passing tests.
3.  **Address Assertion Discrepancies in `tests/dts/test_parser.py`:**
    *   Once the parser is more reliably constructing the AST, re-evaluate the assertions in `tests/dts/test_parser.py` (and other test files if necessary) that compare parsed values. Some expected values might need updating to reflect the *correct* parsing behavior.
4.  **Re-run Full Test Suite and Assess:** After addressing the core parser logic, run all tests to identify the next layer of issues (likely preprocessor errors or more subtle extractor/transformer bugs).
5.  **Address Preprocessor Issues (Carryover):**
    *   Fix `DtsPreprocessor` initialization for `include_paths`.
    *   Investigate and improve handling of non-standard C directives and `cpp` errors.

### 5.1. Detailed Steps for Stabilizing `DtsParser._parse_node_body`

This approach focuses on isolating issues, meticulous debugging, and incremental fixes:

1.  **Isolate Failing Test Cases Systematically:**
    *   **Target `TypeError: DtsNode.__init__() missing 'name'`:**
        *   Run `pytest -k "test_name_that_fails_with_TypeError_DtsNode_name"` (replace with an actual failing test name, e.g., from `tests/dts/test_parser.py` or `tests/test_dts_parser.py`).
        *   If the existing test is complex, simplify its DTS input or create a new, minimal test case in `tests/dts/test_parser.py` that reproduces *only* this error with the simplest possible DTS structure (e.g., a root with one child node that triggers the error).
    *   **Target `DtsParseError: Expected '{' after node ...`:**
        *   Similarly, identify and isolate a simple test case that triggers this specific `DtsParseError`.
        *   Create a minimal reproduction if necessary.
    *   Prioritize the simplest failing test cases first.

2.  **Focused Debugging Workflow (Iterate per Isolated Test Case):**
    *   **Understand Expected vs. Actual Token Sequence:** For the failing minimal DTS input, manually list the expected sequence of tokens and compare it with `self.tokens` generated by `_tokenize`.
    *   **Trace `self.pos` meticulously:** Before `_parse_node_body` is called for the problematic segment, and at each step within it, log or inspect `self.pos` and `self.tokens[self.pos]`.
        *   Verify `self.pos` advances exactly as expected after consuming each part of the syntax (labels, node names, property names, `=`, values, `;`, `{`, `}`).
    *   **Verify Variable States at Critical Points:**
        *   When `potential_node_name_or_label` is assigned.
        *   When `actual_node_name` is determined (check logic for handling `label: node_name` vs. `node_name`).
        *   Immediately before `child = DtsNode(name=actual_node_name)`, confirm `actual_node_name` holds the correct string.
        *   When an error like "Expected '{'" occurs, what is `self.tokens[self.pos]` *actually* pointing to?
    *   **Use Print Debugging Liberally (if not using a step-debugger):** Add temporary print statements to show the current token, `self.pos`, and key variable values at different stages of `_parse_node_body`.

3.  **Implement and Test Fixes Incrementally:**
    *   Make the smallest possible change to address the identified discrepancy in token handling or state logic.
    *   After the change, run *only the specific isolated test case* to see if it passes.
    *   If it passes, run `black .` and `ruff check . --fix`.
    *   Then, run the full `pytest` suite to check for regressions or newly unmasked errors. If new errors appear, decide if they are related or a separate issue to be tackled next.

4.  **Refine Parser Error Context (If Needed):**
    *   If, during debugging, you find that a `DtsParseError` could be more specific or provide better context for that particular failure mode, consider improving its message or `help_text` once the underlying bug is fixed.

5.  **Iterate and Document:**
    *   Repeat this process for each distinct type of error originating from `_parse_node_body`.
    *   Briefly note in `CONSOLIDATED_PLAN.md` (perhaps as sub-bullets under the fixed error type) the nature of the fix if it clarifies a pattern.

## 6. Broader Remaining Tasks and Future Improvements

(This section synthesizes tasks from previous planning documents, adjusted for current understanding. Items previously marked "[x]" are retained if still relevant or if their "completion" is now questionable.)

### 6.1. Testing Enhancements
*   [ ] Resolve all current test failures.
*   [ ] Add tests for complex binding formats.
*   [ ] Add tests for error recovery scenarios in the parser and preprocessor.
*   [ ] Add tests for state transition edge cases (if applicable to any state machines).
*   [ ] Document test scenarios and coverage.
*   [ ] Add tests for macro timing configurations.
*   [ ] Add property-based tests for transformers and error handling.
*   [ ] Expand integration test suite with more diverse ZMK files.
*   [ ] Add stress tests for large configurations.
*   [ ] Add performance benchmarks and tests.
*   [ ] Add advanced error handling test cases:
    *   Complex syntax errors.
    *   Nested validation issues.
    *   Cross-reference problems.

### 6.2. Feature Development
*   **Macro Support:**
    *   [x] Design `MacroParser` class (existence assumed, but functionality needs verification).
    *   [x] Implement basic macro parsing.
    *   [x] Add macro validation.
    *   [x] Add tests for macro parsing.
    *   [x] Add support for parameterized macros.
    *   [ ] Implement/Verify macro timing configurations (wait times, tap times).
    *   [ ] Add support for complex macro sequences.
    *   [ ] Add validation for macro timing values.
*   **Other Features:**
    *   [ ] Support for more ZMK behaviors (e.g., combos, RGB/LED if desired).
    *   [ ] Custom behavior definitions.
    *   [ ] Config validation tools.
    *   [ ] Migration utilities for users from older versions or formats.

### 6.3. Documentation
*   [ ] Thoroughly update all documentation (README, etc.) to reflect the current DTS-based architecture and its actual state post-fixes.
*   [ ] Document state machine behavior (if any significant state machines exist beyond parsing stages).
*   [ ] Add a comprehensive binding format guide for ZMK-to-Kanata.
*   [ ] Create/Update a troubleshooting guide based on common errors (including new ones found).
*   [ ] Update/Create architecture diagrams.
*   [ ] Document macro configuration options in detail.
*   [ ] Document error handling features, error types, and common fixes.
*   [ ] Add more examples for various ZMK features and their Kanata equivalents.
*   [ ] API reference documentation.

### 6.4. Error Handling and User Experience
*   [ ] Ensure detailed and contextual error messages for all components.
*   [ ] Implement graceful fallbacks for edge cases where possible.
*   [ ] Improve error reporting format (consistent, clear).
*   [ ] Provide helpful suggestions for fixing errors where feasible.
*   [ ] Interactive error fixing (ambitious, future goal).
*   [ ] Error pattern detection and automated fix suggestions (ambitious, future goal).

### 6.5. Performance Optimization
*   [ ] Profile large file processing.
*   [ ] Identify and address bottlenecks in parsing, extraction, or transformation.
*   [ ] Consider caching for repeated operations if beneficial.
*   [ ] Optimize memory usage.

## 7. Development Guidelines

1.  **Code Changes:**
    *   Make small, focused changes.
    *   Add tests for all new features and bug fixes.
    *   Ensure existing functionality (once restored) remains working.
2.  **Error Handling:**
    *   Include context (line numbers, file names, relevant snippets).
    *   Maintain a consistent error format.
    *   Suggest fixes or point to documentation where possible.
3.  **Testing:**
    *   Test both success and failure cases.
    *   Include edge cases and boundary conditions.
    *   Document the purpose of each test.
    *   Aim for high test coverage.

## 8. Code Quality Practices

*   **Linting and Formatting:**
    *   Use Black for code formatting.
    *   Use Ruff for linting.
    *   Enforce these in CI if possible.
*   **Type Hints:** Use type hints throughout the codebase.
*   **Docstrings:** Write comprehensive docstrings for modules, classes, and functions.
*   **Code Reviews:** Conduct code reviews for all significant changes.

This consolidated document should serve as the primary reference for planning and tracking progress. 