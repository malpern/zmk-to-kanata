# ZMK to Kanata Converter: Development Plan and Status

## 1. Overview and Goals

The ZMK to Kanata Converter is a tool designed to convert ZMK keymap files (using DTS - Device Tree Source) into the Kanata configuration format.

**Key Goals:**
- Provide robust parsing of ZMK keymap files, including complex DTS structures.
- Support a comprehensive set of ZMK features:
    - Basic keymap structures and layers.
    - Advanced behaviors: Hold-tap (with configurable timing and flavors), layer switching (momentary, toggle, to-layer), sticky keys, macros.
    - Transparent keys.
- Handle matrix layouts, including automatic size detection where possible.
- Minimize external dependencies (e.g., by bundling ZMK header files).
- Produce clean, readable Kanata output.
- Offer both a command-line interface (CLI) and a Python API.

## 2. Architecture

The conversion process follows a DTS-based pipeline:

```
Input ZMK File (.zmk/.dts)
     |
     V
DTS Preprocessor (cpp)
     |
     V
DTS Parser (generates AST)
     |
     V
Keymap Extractor (extracts structured data from AST)
     |
     V
Behavior Transformers (convert ZMK behaviors to Kanata equivalents)
     |
     V
Kanata Output Generation (.kbd)
```

**Key Components:**

1.  **DTS Preprocessor (`converter/dts/preprocessor.py`):**
    *   Integrates with a C preprocessor (`cpp`).
    *   Manages include paths and bundled ZMK header files.
    *   Aims to preserve necessary DTS directives.
    *   Handles matrix size detection.
    *   Platform-specific command execution.

2.  **AST Implementation (`converter/dts/ast.py`):**
    *   Defines classes for the Abstract Syntax Tree: `DtsNode`, `DtsProperty`.
    *   `DtsRoot`: Represents the root of the AST, manages the overall tree, and handles label mapping for reference resolution.

3.  **DTS Parser (`converter/dts/parser.py`):**
    *   Tokenizes the preprocessed DTS content.
    *   Parses tokens into an AST according to DTS syntax rules.
    *   Handles property values, node structures, labels, and references.
    *   Includes error reporting for syntax issues.

4.  **Keymap Extractor (`converter/dts/extractor.py`):**
    *   Traverses the AST generated by the `DtsParser`.
    *   Extracts keymap information: layers, behaviors, bindings.
    *   Resolves references and parameters.

5.  **Behavior Transformers (various files in `converter/transformer/` and `converter/behaviors/`):**
    *   Dedicated modules for specific ZMK behaviors:
        *   Hold-tap (`holdtap_transformer.py`): Handles flavors, timing, quick-tap.
        *   Layer (`layer_transformer.py`): Manages layer switching.
        *   Macros (`macro_transformer.py`, `key_sequence.py`): Parses key sequences and timings.
        *   Sticky Keys (`sticky_key_transformer.py`): Handles sticky key behavior.
    *   Translate ZMK behavior models into Kanata-compatible definitions.

6.  **Kanata Output Generator (`converter/transformer/kanata_transformer.py`):**
    *   Takes the extracted and transformed keymap data.
    *   Generates the final Kanata configuration file content.

## 3. Current Development Status (as of commit `45a3499`)

The project has undergone a significant refactor to a DTS-based parsing system. While documentation (`RefactorDTS.md`, `IMPLEMENTATION.md`) from that period indicated many components as "complete" and tests as "passing," the current test suite at commit `45a3499` reveals significant issues, primarily related to the initialization of `DtsRoot` and preprocessor behavior.

**Component Status (Reconciled View):**

*   **Models (`converter/models.py`):** Believed to be largely stable as per `RefactorDTS.md`.
*   **DTS Parser (`converter/dts/parser.py`):**
    *   Structure implemented for node/property parsing.
    *   **Known Issue:** Likely instantiates `DtsRoot` incorrectly, causing widespread test failures.
*   **AST Definition (`converter/dts/ast.py`):**
    *   `DtsNode`, `DtsProperty` defined.
    *   `DtsRoot` defined but its `__init__` signature (requiring a `root: DtsNode` argument) is not correctly used by the parser or tests.
*   **AST Extractor (`converter/dts/extractor.py`):** Functionality is likely impacted by parser/AST issues.
*   **DTS Preprocessor (`converter/dts/preprocessor.py`):**
    *   Integrates with `cpp`.
    *   **Known Issues:**
        *   Incorrect default include path initialization.
        *   Potential mis-handling of non-standard C preprocessor directives found in ZMK files.
        *   Error handling for `cpp` failures needs review (e.g., `FileNotFoundError` vs. `PreprocessorError`).
*   **Behavior Transformers:** Functionality is likely impacted by upstream parser/extractor issues.
*   **Kanata Transformer:** Functionality is likely impacted by upstream issues.
*   **Main & CLI Scripts:** Likely impacted by underlying library errors.

## 4. Known Issues and Current Test Failures (at commit `45a3499`)

The test suite (`pytest`) currently shows **49 failed tests and 23 passed tests**.

*   **Critical:** `TypeError: DtsRoot.__init__() missing 1 required positional argument: 'root'`: This is the most widespread error, affecting most parsing and integration tests. It indicates that `DtsRoot` is being instantiated without the required `DtsNode` argument, likely in `DtsParser.py` and numerous test files.
*   **Preprocessor Errors:**
    *   `PreprocessorError: ... invalid preprocessing directive ...`: Suggests issues with how the C preprocessor is invoked or how it handles certain ZMK syntax.
    *   `AssertionError: assert ['/Volumes/Fl.../dts/include'] == []` in `test_preprocessor_initialization`: `DtsPreprocessor` has an unexpected default include path.
    *   `FileNotFoundError: [Errno 2] No such file or directory: 'invalid_cpp'` when `PreprocessorError` is expected: Incorrect error wrapping in `DtsPreprocessor`.
    *   Test `test_preprocessor_error_handling` fails to raise an expected `PreprocessorError`.
*   **AST Issues:**
    *   `AttributeError: 'DtsRoot' object has no attribute 'label_to_node'` (`tests/dts/test_ast.py`): Potentially a side effect of incorrect `DtsRoot` initialization or a separate API mismatch in tests.
*   **Main Script Failures:** Numerous `tests/test_main.py` failures (return code 1 instead of 0, incorrect stderr) are likely symptoms of the `DtsRoot` initialization error.

## 5. Immediate Next Steps (Action Plan)

1.  **Verify and Fix `DtsParser` Instantiation of `DtsRoot`:**
    *   Read `converter/dts/parser.py` (at commit `45a3499`).
    *   Confirm how `DtsRoot` is instantiated in `DtsParser.parse`.
    *   If incorrect (e.g., `DtsRoot()`), modify the parser:
        1.  Create a base `DtsNode` (e.g., `root_node = DtsNode(name="/")`).
        2.  Parse the DTS body content into this `root_node` (filling its children, properties).
        3.  Then, create the `DtsRoot` instance using this populated node: `ast_root = DtsRoot(root=root_node)`.
2.  **Update Test Suite for `DtsRoot` Instantiation:**
    *   After fixing the parser (if necessary), systematically review and fix test failures related to `DtsRoot.__init__()`.
    *   Update test setups to correctly instantiate `DtsRoot`, either by passing a mock/simple `DtsNode` or by using the (fixed) `DtsParser`.
3.  **Re-run Tests and Assess:** Identify remaining failures to guide subsequent steps.
4.  **Address Preprocessor Issues:**
    *   Fix the `DtsPreprocessor` initialization bug related to `include_paths`.
    *   Investigate and improve handling of non-standard C directives and `cpp` errors.
5.  **Address `label_to_node` AttributeError:** If still present after `DtsRoot` fixes, investigate the specific test usages.

## 6. Broader Remaining Tasks and Future Improvements

(This section synthesizes tasks from previous planning documents, adjusted for current understanding. Items previously marked "[x]" are retained if still relevant or if their "completion" is now questionable.)

### 6.1. Testing Enhancements
*   [ ] Resolve all current test failures.
*   [ ] Add tests for complex binding formats.
*   [ ] Add tests for error recovery scenarios in the parser and preprocessor.
*   [ ] Add tests for state transition edge cases (if applicable to any state machines).
*   [ ] Document test scenarios and coverage.
*   [ ] Add tests for macro timing configurations.
*   [ ] Add property-based tests for transformers and error handling.
*   [ ] Expand integration test suite with more diverse ZMK files.
*   [ ] Add stress tests for large configurations.
*   [ ] Add performance benchmarks and tests.
*   [ ] Add advanced error handling test cases:
    *   Complex syntax errors.
    *   Nested validation issues.
    *   Cross-reference problems.

### 6.2. Feature Development
*   **Macro Support:**
    *   [x] Design `MacroParser` class (existence assumed, but functionality needs verification).
    *   [x] Implement basic macro parsing.
    *   [x] Add macro validation.
    *   [x] Add tests for macro parsing.
    *   [x] Add support for parameterized macros.
    *   [ ] Implement/Verify macro timing configurations (wait times, tap times).
    *   [ ] Add support for complex macro sequences.
    *   [ ] Add validation for macro timing values.
*   **Other Features:**
    *   [ ] Support for more ZMK behaviors (e.g., combos, RGB/LED if desired).
    *   [ ] Custom behavior definitions.
    *   [ ] Config validation tools.
    *   [ ] Migration utilities for users from older versions or formats.

### 6.3. Documentation
*   [ ] Thoroughly update all documentation (README, etc.) to reflect the current DTS-based architecture and its actual state post-fixes.
*   [ ] Document state machine behavior (if any significant state machines exist beyond parsing stages).
*   [ ] Add a comprehensive binding format guide for ZMK-to-Kanata.
*   [ ] Create/Update a troubleshooting guide based on common errors (including new ones found).
*   [ ] Update/Create architecture diagrams.
*   [ ] Document macro configuration options in detail.
*   [ ] Document error handling features, error types, and common fixes.
*   [ ] Add more examples for various ZMK features and their Kanata equivalents.
*   [ ] API reference documentation.

### 6.4. Error Handling and User Experience
*   [ ] Ensure detailed and contextual error messages for all components.
*   [ ] Implement graceful fallbacks for edge cases where possible.
*   [ ] Improve error reporting format (consistent, clear).
*   [ ] Provide helpful suggestions for fixing errors where feasible.
*   [ ] Interactive error fixing (ambitious, future goal).
*   [ ] Error pattern detection and automated fix suggestions (ambitious, future goal).

### 6.5. Performance Optimization
*   [ ] Profile large file processing.
*   [ ] Identify and address bottlenecks in parsing, extraction, or transformation.
*   [ ] Consider caching for repeated operations if beneficial.
*   [ ] Optimize memory usage.

## 7. Development Guidelines

1.  **Code Changes:**
    *   Make small, focused changes.
    *   Add tests for all new features and bug fixes.
    *   Ensure existing functionality (once restored) remains working.
2.  **Error Handling:**
    *   Include context (line numbers, file names, relevant snippets).
    *   Maintain a consistent error format.
    *   Suggest fixes or point to documentation where possible.
3.  **Testing:**
    *   Test both success and failure cases.
    *   Include edge cases and boundary conditions.
    *   Document the purpose of each test.
    *   Aim for high test coverage.

## 8. Code Quality Practices

*   **Linting and Formatting:**
    *   Use Black for code formatting.
    *   Use Ruff for linting.
    *   Enforce these in CI if possible.
*   **Type Hints:** Use type hints throughout the codebase.
*   **Docstrings:** Write comprehensive docstrings for modules, classes, and functions.
*   **Code Reviews:** Conduct code reviews for all significant changes.

This consolidated document should serve as the primary reference for planning and tracking progress. 