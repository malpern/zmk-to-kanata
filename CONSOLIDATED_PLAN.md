# ZMK to Kanata Converter: Development Plan and Status

## 1. Overview and Goals

The ZMK to Kanata Converter is a tool designed to convert ZMK keymap files (using DTS - Device Tree Source) into the Kanata configuration format.

**Key Goals:**
- Provide robust parsing of ZMK keymap files, including complex DTS structures.
- Support a comprehensive set of ZMK features:
    - Basic keymap structures and layers.
    - Advanced behaviors: Hold-tap (with configurable timing and flavors), layer switching (momentary, toggle, to-layer), sticky keys, macros.
    - Transparent keys.
- Handle matrix layouts, including automatic size detection where possible.
- Minimize external dependencies (e.g., by bundling ZMK header files).
- Produce clean, readable Kanata output.
- Offer both a command-line interface (CLI) and a Python API.

## 2. Architecture

The conversion process follows a DTS-based pipeline:

```
Input ZMK File (.zmk/.dts)
     |
     V
DTS Preprocessor (cpp)
     |
     V
DTS Parser (generates AST)
     |
     V
Keymap Extractor (extracts structured data from AST)
     |
     V
Behavior Transformers (convert ZMK behaviors to Kanata equivalents)
     |
     V
Kanata Output Generation (.kbd)
```

**Key Components:**

1.  **DTS Preprocessor (`converter/dts/preprocessor.py`):**
    *   Integrates with a C preprocessor (`cpp`).
    *   Manages include paths and bundled ZMK header files.
    *   Preserves DTS directives during preprocessing.
    *   Handles matrix size detection.
    *   Platform-specific command execution.
    *   Current Issues:
        - Path Handling and cpp Command Issues
        - Test Failures
        - Error Handling

2.  **AST Implementation (`converter/dts/ast.py`):**
    *   Defines classes for the Abstract Syntax Tree: `DtsNode`, `DtsProperty`.
    *   `DtsRoot`: Represents the root of the AST, manages the overall tree.

3.  **DTS Parser (`converter/dts/parser.py`):**
    *   Tokenizes the preprocessed DTS content.
    *   Parses tokens into an AST according to DTS syntax rules.
    *   Handles property values, node structures, labels, and references.

4.  **Keymap Extractor (`converter/dts/extractor.py`):**
    *   Traverses the AST generated by the `DtsParser`.
    *   Extracts keymap information: layers, behaviors, bindings.
    *   Resolves references and parameters.

5.  **Behavior Transformers:**
    *   Dedicated modules for specific ZMK behaviors:
        *   Hold-tap: Handles flavors, timing, quick-tap.
        *   Layer: Manages layer switching.
        *   Macros: Parses key sequences and timings.
        *   Sticky Keys: Handles sticky key behavior.
    *   Translate ZMK behavior models into Kanata-compatible definitions.

6.  **Kanata Output Generator:**
    *   Takes the extracted and transformed keymap data.
    *   Generates the final Kanata configuration file content.

## 3. Current Development Status

The project is currently focused on stabilizing the preprocessor component and its test suite. Key areas being addressed:

### Preprocessor Implementation Progress:
1. **Core Functionality:**
   - Basic DTS preprocessing with cpp integration implemented
   - Matrix size detection from both matrix_transform and RC_MATRIX patterns
   - Temporary file handling with proper cleanup
   - Error handling with detailed context and help text
   - Include path validation and management

2. **Current Issues:**
   - Path handling with spaces needs improvement
   - cpp command construction on different platforms
   - Matrix size detection edge cases
   - Temporary file management in error cases
   - Platform-specific cpp path handling

3. **Test Coverage:**
   - Basic preprocessing tests implemented
   - Matrix size detection tests
   - Error handling tests
   - Include path validation tests
   - Need more edge case and platform-specific tests

### Immediate Action Items:
1. **Path Handling Improvements:**
   - Add proper path escaping for spaces in filenames
   - Implement consistent Path vs string handling
   - Add platform-specific path normalization
   - Improve temporary file path handling

2. **cpp Command Enhancements:**
   - Add platform detection for cpp path defaults
   - Implement proper command argument escaping
   - Add cpp version detection and compatibility checks
   - Improve error reporting for cpp command failures

3. **Matrix Size Detection:**
   - Add support for more matrix definition patterns
   - Improve pattern matching robustness
   - Add validation for matrix dimensions
   - Handle multi-matrix configurations

4. **Error Handling:**
   - Enhance error context information
   - Add more specific error types
   - Improve error recovery options
   - Add detailed troubleshooting guides

## 4. Next Steps

1. **Preprocessor Enhancements:**
   - Implement platform-specific cpp path detection
   - Add cpp version compatibility checks
   - Improve matrix size detection robustness
   - Add support for custom preprocessor definitions

2. **Path Handling:**
   - Implement cross-platform path normalization
   - Add proper path escaping for special characters
   - Improve temporary file management
   - Add path validation utilities

3. **Testing Infrastructure:**
   - Add platform-specific test suites
   - Implement matrix size detection tests
   - Add error recovery tests
   - Create preprocessor benchmark tests

4. **Documentation:**
   - Document preprocessor configuration options
   - Add platform-specific setup guides
   - Create troubleshooting documentation
   - Document matrix size detection patterns

## 5. Development Guidelines

1. **Code Changes:**
   - Make small, focused changes
   - Add tests for new features and bug fixes
   - Ensure existing functionality remains working

2. **Error Handling:**
   - Include context (line numbers, file names, relevant snippets)
   - Maintain consistent error format
   - Suggest fixes or point to documentation

3. **Testing:**
   - Test both success and failure cases
   - Include edge cases and boundary conditions
   - Document test purposes
   - Aim for high test coverage

## 6. Code Quality Practices

- **Linting and Formatting:**
  - Use Black for code formatting
  - Use Ruff for linting
  - Keep lines under 79 characters
  - Follow Python type hinting best practices

- **Documentation:**
  - Write comprehensive docstrings
  - Keep README and other docs up to date
  - Document error conditions and solutions

- **Testing:**
  - Write unit tests for new features
  - Add integration tests for complete workflows
  - Test error conditions and edge cases

## 7. Broader Remaining Tasks and Future Improvements

### 7.1. Testing Enhancements
*   [ ] Complete platform-specific preprocessor tests
*   [ ] Add comprehensive matrix size detection tests
*   [ ] Add error recovery and cleanup verification tests
*   [ ] Implement preprocessor performance benchmarks
*   [ ] Add property-based tests for path handling and error cases
*   [ ] Create integration tests with real-world ZMK configs
*   [ ] Add stress tests for large configurations
*   [ ] Implement cross-platform compatibility tests
*   [ ] Add test coverage for all error conditions:
    *   Path handling edge cases
    *   cpp command failures
    *   Matrix detection failures
    *   Include path resolution issues

### 7.2. Feature Development
*   **Preprocessor Enhancements:**
    *   [x] Basic cpp integration
    *   [x] Matrix size detection
    *   [x] Include path handling
    *   [ ] Platform-specific cpp detection
    *   [ ] Custom preprocessor definitions
    *   [ ] Multi-matrix support
    *   [ ] Advanced error recovery
*   **Path Handling:**
    *   [x] Basic Path object support
    *   [ ] Cross-platform path normalization
    *   [ ] Special character handling
    *   [ ] Temporary file management improvements
*   **Error Handling:**
    *   [x] Basic error context
    *   [x] Help text support
    *   [ ] Advanced error recovery
    *   [ ] Interactive error resolution
    *   [ ] Error pattern detection

### 7.3. Documentation
*   [ ] Complete preprocessor configuration guide
*   [ ] Platform-specific setup instructions
*   [ ] Matrix size detection patterns guide
*   [ ] Error handling and troubleshooting guide
*   [ ] Path handling best practices
*   [ ] Performance optimization guide
*   [ ] Test writing guide
*   [ ] API reference documentation

### 7.4. Error Handling and User Experience
*   [x] Basic error context and messages
*   [x] Help text for common errors
*   [ ] Interactive error resolution
*   [ ] Error pattern detection
*   [ ] Automated fix suggestions
*   [ ] Recovery strategies for common failures
*   [ ] User-friendly error reporting format

### 7.5. Performance Optimization
*   [ ] Profile preprocessor operations
*   [ ] Optimize temporary file handling
*   [ ] Improve matrix size detection performance
*   [ ] Enhance include path resolution
*   [ ] Implement caching where beneficial
*   [ ] Optimize memory usage for large files

## 8. Development Guidelines

1.  **Code Changes:**
    *   Make small, focused changes.
    *   Add tests for all new features and bug fixes.
    *   Ensure existing functionality (once restored) remains working.
2.  **Error Handling:**
    *   Include context (line numbers, file names, relevant snippets).
    *   Maintain a consistent error format.
    *   Suggest fixes or point to documentation where possible.
3.  **Testing:**
    *   Test both success and failure cases.
    *   Include edge cases and boundary conditions.
    *   Document the purpose of each test.
    *   Aim for high test coverage.

## 9. Code Quality Practices

*   **Linting and Formatting:**
    *   Use Black for code formatting.
    *   Use Ruff for linting.
    *   Enforce these in CI if possible.
*   **Type Hints:** Use type hints throughout the codebase.
*   **Docstrings:** Write comprehensive docstrings for modules, classes, and functions.
*   **Code Reviews:** Conduct code reviews for all significant changes.

This consolidated document should serve as the primary reference for planning and tracking progress. 