from typing import Dict, List
from converter.transformer.keycode_map import zmk_to_kanata


class KanataConverter:
    """A class to convert parsed DTS data to Kanata configuration."""

    def __init__(self):
        """Initialize the Kanata converter."""
        # Basic key mapping from ZMK to Kanata
        self._key_mapping = {
            "&kp": {
                "A": "a",
                "B": "b",
                "C": "c",
                "D": "d",
                "E": "e",
                "F": "f",
                "G": "g",
                "H": "h",
                "I": "i",
                "J": "j",
                "K": "k",
                "L": "l",
                "M": "m",
                "N": "n",
                "O": "o",
                "P": "p",
                "Q": "q",
                "R": "r",
                "S": "s",
                "T": "t",
                "U": "u",
                "V": "v",
                "W": "w",
                "X": "x",
                "Y": "y",
                "Z": "z",
                "SPACE": "space",
                "ENTER": "enter",
                "ESC": "esc",
                "TAB": "tab",
                "BACKSPACE": "backspace",
                "DELETE": "delete",
                "INSERT": "insert",
                "HOME": "home",
                "END": "end",
                "PAGE_UP": "pageup",
                "PAGE_DOWN": "pagedown",
                "UP": "up",
                "DOWN": "down",
                "LEFT": "left",
                "RIGHT": "right",
            }
        }

    def _convert_key_code(self, key_code: str) -> str:
        """Convert a ZMK key code to a Kanata key code using the central mapping utility."""
        parts = key_code.split()
        if len(parts) == 2:
            key_type, key_value = parts
            if key_type != "&kp":
                raise ValueError(f"Unsupported key type: {key_type}")
            mapped = zmk_to_kanata(key_value)
            if mapped is None:
                raise ValueError(f"Unsupported key value: {key_value}")
            return mapped
        elif len(parts) == 1:
            mapped = zmk_to_kanata(parts[0])
            if mapped is None:
                raise ValueError(f"Unsupported key value: {parts[0]}")
            return mapped
        else:
            raise ValueError(f"Invalid key code format: {key_code}")

    def _generate_layer(self, layer_name: str, keymap: List[List[str]]) -> str:
        """Generate a Kanata layer configuration.

        Args:
            layer_name: The name of the layer
            keymap: The keymap matrix for this layer

        Returns:
            The Kanata layer configuration as a string
        """
        lines = [f"# Layer: {layer_name}"]

        for row_idx, row in enumerate(keymap):
            # Convert each key in the row
            converted_keys = [self._convert_key_code(key) for key in row]
            # Join the keys with spaces
            line = " ".join(converted_keys)
            lines.append(line)

        return "\n".join(lines)

    def convert(self, dts_data: Dict) -> str:
        """Convert parsed DTS data to Kanata configuration.

        Args:
            dts_data: The parsed DTS data containing:
                - matrix_size: Tuple of (rows, columns)
                - matrix_map: List of lists containing RC macro calls
                - keymap: Dictionary mapping layer names to their key bindings

        Returns:
            The Kanata configuration as a string

        Raises:
            ValueError: If the conversion fails
        """
        try:
            # Start with the header
            lines = [
                "# Generated by ZMK to Kanata converter",
                "# Matrix size: {}x{}".format(*dts_data["matrix_size"]),
                "",
            ]

            # Add each layer
            for layer_name, keymap in dts_data["keymap"].items():
                lines.append(self._generate_layer(layer_name, keymap))
                lines.append("")  # Add a blank line between layers

            return "\n".join(lines)

        except Exception as e:
            raise ValueError(f"Failed to convert to Kanata: {str(e)}")

    def _parse_kanata_layer(
        self, layer_name: str, layer_content: str
    ) -> List[List[str]]:
        """Parse a Kanata layer definition into a matrix format.

        Args:
            layer_name: Name of the layer
            layer_content: Content of the layer definition

        Returns:
            List[List[str]]: Matrix representation of the layer
        """
        # Split into lines and remove empty lines
        lines = [line.strip() for line in layer_content.split("\n") if line.strip()]

        # Remove the layer definition line
        if lines and lines[0].startswith("(deflayer"):
            lines = lines[1:]

        # Remove the closing parenthesis if present
        if lines and lines[-1].strip() == ")":
            lines = lines[:-1]

        # Parse each line into a row
        matrix = []
        for line in lines:
            # Split on whitespace and filter out empty strings
            row = [key.strip() for key in line.split() if key.strip()]
            if row:  # Only add non-empty rows
                matrix.append(row)

        return matrix
