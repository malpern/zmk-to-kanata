============================= test session starts ==============================
platform darwin -- Python 3.10.16, pytest-8.3.4, pluggy-1.5.0 -- /Users/malpern/.pyenv/versions/3.10.16/bin/python3.10
cachedir: .pytest_cache
rootdir: /Volumes/FlashGordon/Dropbox/code/nicktokatana
configfile: pyproject.toml
testpaths: tests
plugins: anyio-4.7.0
collecting ... collected 72 items / 57 deselected / 15 selected

tests/dts/test_performance.py::test_preprocessor_performance FAILED      [  6%]
tests/dts/test_preprocessor.py::test_preprocessor_initialization FAILED  [ 13%]
tests/dts/test_preprocessor.py::test_preprocess_simple_file FAILED       [ 20%]
tests/dts/test_preprocessor.py::test_preprocess_with_matrix PASSED       [ 26%]
tests/dts/test_preprocessor.py::test_preprocess_with_includes FAILED     [ 33%]
tests/dts/test_preprocessor.py::test_preprocess_invalid_file FAILED      [ 40%]
tests/dts/test_preprocessor.py::test_preprocess_invalid_cpp_command FAILED [ 46%]
tests/dts/test_preprocessor.py::test_matrix_size_extraction PASSED       [ 53%]
tests/dts/test_preprocessor.py::test_preprocess_simple_keymap FAILED     [ 60%]
tests/dts/test_preprocessor.py::test_preprocess_with_include_paths PASSED [ 66%]
tests/dts/test_preprocessor.py::test_matrix_size_detection PASSED        [ 73%]
tests/dts/test_preprocessor.py::test_matrix_size_detection_no_matrix PASSED [ 80%]
tests/test_dts_preprocessor.py::test_preprocessor FAILED                 [ 86%]
tests/test_dts_preprocessor.py::test_preprocessor_large_matrix FAILED    [ 93%]
tests/test_dts_preprocessor.py::test_preprocessor_error_handling FAILED  [100%]

=================================== FAILURES ===================================
________________________ test_preprocessor_performance _________________________

self = <converter.dts.preprocessor.DtsPreprocessor object at 0x105902fb0>
input_path = PosixPath('/Volumes/FlashGordon/Dropbox/code/nicktokatana/tests/fixtures/dts/complex_keymap.zmk')
matrix_size = None

    def preprocess(
        self,
        input_path: str,
        matrix_size: Optional[Tuple[int, int]] = None,
    ) -> str:
        """Preprocess a DTS file.
    
        Args:
            input_path: Path to the input file
            matrix_size: Optional tuple of (rows, cols) for matrix transform
    
        Returns:
            The preprocessed content as a string
    
        Raises:
            PreprocessorError: If preprocessing fails
        """
        input_path = Path(input_path)
        if not input_path.exists():
            raise PreprocessorError(
                f"Input file does not exist: {input_path}",
                help_text=(
                    "Ensure the input file exists and has proper " "read permissions"
                ),
            )
    
        try:
            with open(input_path, "r") as f:
                content_for_cpp = f.read()
        except Exception as e:
            raise PreprocessorError(
                f"Failed to read input file: {str(e)}",
                file=str(input_path),
                help_text=("Ensure the file exists and has proper " "read permissions"),
            )
    
        # Create a temporary file for the preprocessor input
        tmp_input = tempfile.NamedTemporaryFile(
            mode="w",
            delete=False,
            suffix=".dts",
            dir=None,  # Use system default temp dir (usually /tmp)
        )
        tmp_input.write(content_for_cpp)
        tmp_input.close()
        tmp_input_file = Path(tmp_input.name)
    
        # Debug: print environment and temp file contents
        print("[DtsPreprocessor] ENVIRONMENT:")
        for k, v in os.environ.items():
            if len(v) > 40:
                print(f"  {k}={v[:20]}...{v[-20:]}")
            else:
                print(f"  {k}={v}")
        if len(str(tmp_input_file)) > 70:
            print(f"[DtsPreprocessor] Temp file: " f"{str(tmp_input_file)[:70]}...")
        else:
            print(f"[DtsPreprocessor] Temp file: {tmp_input_file}")
        with open(tmp_input_file, "r") as f:
            print("[DtsPreprocessor] Temp file contents:")
            print(f.read())
    
        try:
            # Build cpp command as a list for shell=False
            cpp_cmd = [
                str(self.cpp_path),
                "-E",
            ]
            for path in self.include_paths:
                cpp_cmd.extend(["-I", str(path)])
            cpp_cmd.append(str(tmp_input_file))
    
            # Debug: print the constructed command list
            print("[DtsPreprocessor] cpp command:", cpp_cmd)
    
            # Run preprocessor with shell=False
            try:
>               result = subprocess.run(
                    cpp_cmd,
                    capture_output=True,
                    text=True,
                    check=True,
                    shell=False,
                )

converter/dts/preprocessor.py:202: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = None, capture_output = True, timeout = None, check = True
popenargs = (['/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/cpp', '-E', '/var/folders/0s/42v7yl697hn0l1cdnx0vrvyr0000gn/T/tmpa32wmidc.dts'],)
kwargs = {'shell': False, 'stderr': -1, 'stdout': -1, 'text': True}
process = <Popen: returncode: 1 args: ['/Applications/Xcode.app/Contents/Developer/Too...>
stdout = '# 1 "/var/folders/0s/42v7yl697hn0l1cdnx0vrvyr0000gn/T/tmpa32wmidc.dts"\n# 1 "<built-in>" 1\n# 1 "<built-in>" 3\n# 423...       \n        tri_layer {\n            if-layers = <1 2>;\n            then-layer = <3>;\n        };\n    };\n}; \n'
stderr = "/var/folders/0s/42v7yl697hn0l1cdnx0vrvyr0000gn/T/tmpa32wmidc.dts:1:10: fatal error: 'dt-bindings/zmk/matrix_transform...lude <dt-bindings/zmk/matrix_transform.h>\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n1 error generated.\n"
retcode = 1

    def run(*popenargs,
            input=None, capture_output=False, timeout=None, check=False, **kwargs):
        """Run command with arguments and return a CompletedProcess instance.
    
        The returned instance will have attributes args, returncode, stdout and
        stderr. By default, stdout and stderr are not captured, and those attributes
        will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them,
        or pass capture_output=True to capture both.
    
        If check is True and the exit code was non-zero, it raises a
        CalledProcessError. The CalledProcessError object will have the return code
        in the returncode attribute, and output & stderr attributes if those streams
        were captured.
    
        If timeout is given, and the process takes too long, a TimeoutExpired
        exception will be raised.
    
        There is an optional argument "input", allowing you to
        pass bytes or a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it will be used internally.
    
        By default, all communication is in bytes, and therefore any "input" should
        be bytes, and the stdout and stderr will be bytes. If in text mode, any
        "input" should be a string, and stdout and stderr will be strings decoded
        according to locale encoding, or by "encoding" if set. Text mode is
        triggered by setting any of text, encoding, errors or universal_newlines.
    
        The other arguments are the same as for the Popen constructor.
        """
        if input is not None:
            if kwargs.get('stdin') is not None:
                raise ValueError('stdin and input arguments may not both be used.')
            kwargs['stdin'] = PIPE
    
        if capture_output:
            if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:
                raise ValueError('stdout and stderr arguments may not be used '
                                 'with capture_output.')
            kwargs['stdout'] = PIPE
            kwargs['stderr'] = PIPE
    
        with Popen(*popenargs, **kwargs) as process:
            try:
                stdout, stderr = process.communicate(input, timeout=timeout)
            except TimeoutExpired as exc:
                process.kill()
                if _mswindows:
                    # Windows accumulates the output in a single blocking
                    # read() call run on child threads, with the timeout
                    # being done in a join() on those threads.  communicate()
                    # _after_ kill() is required to collect that and add it
                    # to the exception.
                    exc.stdout, exc.stderr = process.communicate()
                else:
                    # POSIX _communicate already populated the output so
                    # far into the TimeoutExpired exception.
                    process.wait()
                raise
            except:  # Including KeyboardInterrupt, communicate handled that.
                process.kill()
                # We don't call process.wait() as .__exit__ does that for us.
                raise
            retcode = process.poll()
            if check and retcode:
>               raise CalledProcessError(retcode, process.args,
                                         output=stdout, stderr=stderr)
E               subprocess.CalledProcessError: Command '['/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/cpp', '-E', '/var/folders/0s/42v7yl697hn0l1cdnx0vrvyr0000gn/T/tmpa32wmidc.dts']' returned non-zero exit status 1.

/Users/malpern/.pyenv/versions/3.10.16/lib/python3.10/subprocess.py:526: CalledProcessError

During handling of the above exception, another exception occurred:

sample_keymap_path = '/Volumes/FlashGordon/Dropbox/code/nicktokatana/tests/fixtures/dts/complex_keymap.zmk'

    def test_preprocessor_performance(sample_keymap_path):
        """Test the performance of the preprocessor."""
        preprocessor = DtsPreprocessor()
    
        # Run multiple times to get stable measurements
        times = []
        for _ in range(10):
>           _, duration = measure_time(preprocessor.preprocess, sample_keymap_path)

tests/dts/test_performance.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/dts/test_performance.py:16: in measure_time
    result = func(*args, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <converter.dts.preprocessor.DtsPreprocessor object at 0x105902fb0>
input_path = PosixPath('/Volumes/FlashGordon/Dropbox/code/nicktokatana/tests/fixtures/dts/complex_keymap.zmk')
matrix_size = None

    def preprocess(
        self,
        input_path: str,
        matrix_size: Optional[Tuple[int, int]] = None,
    ) -> str:
        """Preprocess a DTS file.
    
        Args:
            input_path: Path to the input file
            matrix_size: Optional tuple of (rows, cols) for matrix transform
    
        Returns:
            The preprocessed content as a string
    
        Raises:
            PreprocessorError: If preprocessing fails
        """
        input_path = Path(input_path)
        if not input_path.exists():
            raise PreprocessorError(
                f"Input file does not exist: {input_path}",
                help_text=(
                    "Ensure the input file exists and has proper " "read permissions"
                ),
            )
    
        try:
            with open(input_path, "r") as f:
                content_for_cpp = f.read()
        except Exception as e:
            raise PreprocessorError(
                f"Failed to read input file: {str(e)}",
                file=str(input_path),
                help_text=("Ensure the file exists and has proper " "read permissions"),
            )
    
        # Create a temporary file for the preprocessor input
        tmp_input = tempfile.NamedTemporaryFile(
            mode="w",
            delete=False,
            suffix=".dts",
            dir=None,  # Use system default temp dir (usually /tmp)
        )
        tmp_input.write(content_for_cpp)
        tmp_input.close()
        tmp_input_file = Path(tmp_input.name)
    
        # Debug: print environment and temp file contents
        print("[DtsPreprocessor] ENVIRONMENT:")
        for k, v in os.environ.items():
            if len(v) > 40:
                print(f"  {k}={v[:20]}...{v[-20:]}")
            else:
                print(f"  {k}={v}")
        if len(str(tmp_input_file)) > 70:
            print(f"[DtsPreprocessor] Temp file: " f"{str(tmp_input_file)[:70]}...")
        else:
            print(f"[DtsPreprocessor] Temp file: {tmp_input_file}")
        with open(tmp_input_file, "r") as f:
            print("[DtsPreprocessor] Temp file contents:")
            print(f.read())
    
        try:
            # Build cpp command as a list for shell=False
            cpp_cmd = [
                str(self.cpp_path),
                "-E",
            ]
            for path in self.include_paths:
                cpp_cmd.extend(["-I", str(path)])
            cpp_cmd.append(str(tmp_input_file))
    
            # Debug: print the constructed command list
            print("[DtsPreprocessor] cpp command:", cpp_cmd)
    
            # Run preprocessor with shell=False
            try:
                result = subprocess.run(
                    cpp_cmd,
                    capture_output=True,
                    text=True,
                    check=True,
                    shell=False,
                )
            except subprocess.CalledProcessError as e:
>               raise PreprocessorError(
                    "Failed to process DTS directives",
                    file=str(input_path),
                    context=str(e),
                    help_text=("Check for malformed DTS directives in " "input file"),
                )
E               converter.dts.preprocessor.PreprocessorError: Failed to process DTS directives

converter/dts/preprocessor.py:210: PreprocessorError
----------------------------- Captured stdout call -----------------------------
[DtsPreprocessor] ENVIRONMENT:
  MallocNanoZone=0
  USER=malpern
  SECURITYSESSIONID=186a3
  COMMAND_MODE=unix2003
  __CFBundleIdentifier=com.todesktop.230313mzl4w4u92
  PATH=/Users/malpern/.curs....cache/lm-studio/bin
  LOGNAME=malpern
  SSH_AUTH_SOCK=/private/tmp/com.app...x1qskoux7b/Listeners
  HOME=/Users/malpern
  SHELL=/bin/zsh
  TMPDIR=/var/folders/0s/42v7...1cdnx0vrvyr0000gn/T/
  LaunchInstanceID=BFD4BF06-15BD-4F76-8D8A-1AEC50E6795A
  __CF_USER_TEXT_ENCODING=0x1F5:0x0:0x0
  XPC_SERVICE_NAME=0
  XPC_FLAGS=0x0
  ORIGINAL_XDG_CURRENT_DESKTOP=undefined
  CURSOR_TRACE_ID=f5e099fd466543c5a0d391e03a641e89
  SHLVL=1
  PWD=/Volumes/FlashGordon...ox/code/nicktokatana
  OLDPWD=/Volumes/FlashGordon...ox/code/nicktokatana
  HOMEBREW_PREFIX=/opt/homebrew
  HOMEBREW_CELLAR=/opt/homebrew/Cellar
  HOMEBREW_REPOSITORY=/opt/homebrew
  INFOPATH=/opt/homebrew/share/...homebrew/share/info:
  YOUR_CONSUMER_KEY=ah6HAffNJRCv4xNrV4OZcVIrQ
  YOUR_CONSUMER_SECRET=EXM9IzH9IEdE2yJf0t5F...DPuFXLk55DwB8pLRswR5
  YOUR_ACCESS_TOKEN=1483-5UbadNrxZUkJpAp...JSXPVSxtsPwJyrUrZvcO
  YOUR_ACCESS_TOKEN_SECRET=jeyyEWPHAgoS0ebKus4t...0jH2T3gRCIz3dsYXQwqS
  YOUR_BEARER_TOKEN=AAAAAAAAAAAAAAAAAAAA...8YVAWCOQu6Pyu4yhuY0a
  OPENAI_API_KEY=sk-qVQDNdwpfPhrAvFr9...ob362AQbhWVa3p95yD28
  ANTHROPIC_API_KEY=sk-ant-api03-Tq7nYRm...SCuUoAfwIQg-NWFWuAAA
  TAVILY_API_KEY=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
  BING_SUBSCRIPTION_KEY=bec8ded0f34a421ba60cc3bd4626825e
  EDITOR=vi
  ZSH=/Users/malpern/.oh-my-zsh
  PAGER=head -n 10000 | cat
  LESS=-R
  LSCOLORS=Gxfxcxdxbxegedabagacad
  LS_COLORS=di=1;36:ln=35:so=32:...46:tw=30;42:ow=30;43
  PYENV_ROOT=/Users/malpern/.pyenv
  PYENV_SHELL=zsh
  DISABLE_AUTO_UPDATE=true
  TERM_PROGRAM=vscode
  TERM_PROGRAM_VERSION=0.50.1
  LANG=en_US.UTF-8
  COLORTERM=truecolor
  GIT_ASKPASS=/Applications/Cursor.../git/dist/askpass.sh
  VSCODE_GIT_ASKPASS_NODE=/Applications/Cursor...rsor Helper (Plugin)
  VSCODE_GIT_ASKPASS_EXTRA_ARGS=
  VSCODE_GIT_ASKPASS_MAIN=/Applications/Cursor...dist/askpass-main.js
  VSCODE_GIT_IPC_HANDLE=/var/folders/0s/42v7...-git-14a5ce3e7f.sock
  PYENV_VERSION=3.10.16
  PYENV_DIR=/
  VIRTUAL_ENV=/Volumes/Flash Gordo...e/nicktokatana/.venv
  PYENV_HOOK_PATH=/Users/malpern/.pyen.../usr/lib/pyenv/hooks
  VIRTUAL_ENV_PROMPT=.venv
  VSCODE_INJECTION=1
  ZDOTDIR=/Users/malpern
  USER_ZDOTDIR=/Users/malpern
  TERM=xterm-256color
  PS1=.venv%(?:%{[01;32m%...} $(git_prompt_info)
  PYTHONPATH=.
  _=/Users/malpern/.pyen...s/3.10.16/bin/pytest
  PYTEST_VERSION=8.3.4
  PYTEST_CURRENT_TEST=tests/dts/test_perfo...r_performance (call)
[DtsPreprocessor] Temp file: /var/folders/0s/42v7yl697hn0l1cdnx0vrvyr0000gn/T/tmpa32wmidc.dts
[DtsPreprocessor] Temp file contents:
#include <dt-bindings/zmk/matrix_transform.h>

/ {
    chosen {
        zmk,matrix_transform = &default_transform;
    };

    default_transform: matrix_transform {
        compatible = "zmk,matrix-transform";
        rows = <4>;
        columns = <12>;
        map = <
            RC(0,0)  RC(0,1)  RC(0,2)  RC(0,3)  RC(0,4)  RC(0,5)  RC(0,6)  RC(0,7)  RC(0,8)  RC(0,9)  RC(0,10) RC(0,11)
            RC(1,0)  RC(1,1)  RC(1,2)  RC(1,3)  RC(1,4)  RC(1,5)  RC(1,6)  RC(1,7)  RC(1,8)  RC(1,9)  RC(1,10) RC(1,11)
            RC(2,0)  RC(2,1)  RC(2,2)  RC(2,3)  RC(2,4)  RC(2,5)  RC(2,6)  RC(2,7)  RC(2,8)  RC(2,9)  RC(2,10) RC(2,11)
            RC(3,0)  RC(3,1)  RC(3,2)  RC(3,3)  RC(3,4)  RC(3,5)  RC(3,6)  RC(3,7)  RC(3,8)  RC(3,9)  RC(3,10) RC(3,11)
        >;
    };

    behaviors {
        mt: mod_tap {
            compatible = "zmk,behavior-hold-tap";
            tapping-term-ms = <200>;
            #binding-cells = <2>;
        };
        
        lt: layer_tap {
            compatible = "zmk,behavior-hold-tap";
            tapping-term-ms = <200>;
            #binding-cells = <2>;
        };
        
        macro_a: macro_a {
            compatible = "zmk,behavior-macro";
            #binding-cells = <0>;
            bindings = <&kp A &kp B>;
        };
        
        macro_b: macro_b {
            compatible = "zmk,behavior-macro";
            #binding-cells = <0>;
            bindings = <&kp C &kp D>;
        };
        
        unicode: unicode {
            compatible = "zmk,behavior-unicode";
            #binding-cells = <1>;
        };
        
        uc_string: unicode_string {
            compatible = "zmk,behavior-unicode-string";
            #binding-cells = <1>;
            strings = <
                "smile" "😊"
                "heart" "❤️"
            >;
        };
    };

    keymap {
        compatible = "zmk,keymap";
        
        default_layer {
            bindings = <
                &mt LSHIFT A  &kp B        &macro_a     &kp D         &lt 1 E      &kp F
                &kp G         &kp H        &kp I        &kp J         &kp K        &kp L
                &kp M         &kp N        &kp O        &kp P         &kp Q        &kp R
                &kp S         &kp T        &kp U        &kp V         &kp W        &kp X
            >;
        };
        
        lower_layer {
            bindings = <
                &kp N1        &kp N2       &kp N3       &kp N4        &kp N5       &kp N6
                &kp N7        &kp N8       &kp N9       &kp N0        &kp MINUS    &kp EQUAL
                &kp F1        &kp F2       &kp F3       &kp F4        &kp F5       &kp F6
                &kp F7        &kp F8       &kp F9       &kp F10       &kp F11      &kp F12
            >;
        };
        
        raise_layer {
            bindings = <
                &kp EXCLAMATION &kp AT     &kp HASH     &kp DOLLAR    &kp PERCENT  &kp CARET
                &kp AMPERSAND   &kp STAR   &kp LPAR     &kp RPAR      &kp UNDER    &kp PLUS
                &kp F1          &kp F2     &kp F3       &kp F4        &kp F5       &kp F6
                &kp F7          &kp F8     &kp F9       &kp F10       &kp F11      &kp F12
            >;
        };
        
        adjust_layer {
            bindings = <
                &kp RESET      &kp BOOTLOADER &kp NONE  &kp NONE      &kp NONE     &kp NONE
                &kp NONE       &kp NONE       &kp NONE  &kp NONE      &kp NONE     &kp NONE
                &kp NONE       &kp NONE       &kp NONE  &kp NONE      &kp NONE     &kp NONE
                &kp NONE       &kp NONE       &kp NONE  &kp NONE      &kp NONE     &kp NONE
            >;
        };
    };

    combos {
        compatible = "zmk,combos";
        
        combo_esc {
            timeout-ms = <50>;
            key-positions = <0 1>;
            bindings = <&kp ESC>;
        };
        
        combo_tab {
            timeout-ms = <50>;
            key-positions = <1 2>;
            bindings = <&kp TAB>;
        };
        
        combo_enter {
            timeout-ms = <50>;
            key-positions = <2 3>;
            bindings = <&kp ENTER>;
        };
    };

    conditional_layers {
        compatible = "zmk,conditional-layers";
        
        tri_layer {
            if-layers = <1 2>;
            then-layer = <3>;
        };
    };
}; 
[DtsPreprocessor] cpp command: ['/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/cpp', '-E', '/var/folders/0s/42v7yl697hn0l1cdnx0vrvyr0000gn/T/tmpa32wmidc.dts']
_______________________ test_preprocessor_initialization _______________________

    def test_preprocessor_initialization():
        """Test preprocessor initialization with different options."""
        # Test default initialization
        preprocessor = DtsPreprocessor()
>       assert preprocessor.cpp_path.endswith("cpp") or preprocessor.cpp_path.endswith(
            "clang"
        )
E       AttributeError: 'PosixPath' object has no attribute 'endswith'

tests/dts/test_preprocessor.py:92: AttributeError
_________________________ test_preprocess_simple_file __________________________

self = <converter.dts.preprocessor.DtsPreprocessor object at 0x105abfb20>
input_path = PosixPath('/var/folders/0s/42v7yl697hn0l1cdnx0vrvyr0000gn/T/tmpjl4smb_l/test.dts')
matrix_size = None

    def preprocess(
        self,
        input_path: str,
        matrix_size: Optional[Tuple[int, int]] = None,
    ) -> str:
        """Preprocess a DTS file.
    
        Args:
            input_path: Path to the input file
            matrix_size: Optional tuple of (rows, cols) for matrix transform
    
        Returns:
            The preprocessed content as a string
    
        Raises:
            PreprocessorError: If preprocessing fails
        """
        input_path = Path(input_path)
        if not input_path.exists():
            raise PreprocessorError(
                f"Input file does not exist: {input_path}",
                help_text=(
                    "Ensure the input file exists and has proper " "read permissions"
                ),
            )
    
        try:
            with open(input_path, "r") as f:
                content_for_cpp = f.read()
        except Exception as e:
            raise PreprocessorError(
                f"Failed to read input file: {str(e)}",
                file=str(input_path),
                help_text=("Ensure the file exists and has proper " "read permissions"),
            )
    
        # Create a temporary file for the preprocessor input
        tmp_input = tempfile.NamedTemporaryFile(
            mode="w",
            delete=False,
            suffix=".dts",
            dir=None,  # Use system default temp dir (usually /tmp)
        )
        tmp_input.write(content_for_cpp)
        tmp_input.close()
        tmp_input_file = Path(tmp_input.name)
    
        # Debug: print environment and temp file contents
        print("[DtsPreprocessor] ENVIRONMENT:")
        for k, v in os.environ.items():
            if len(v) > 40:
                print(f"  {k}={v[:20]}...{v[-20:]}")
            else:
                print(f"  {k}={v}")
        if len(str(tmp_input_file)) > 70:
            print(f"[DtsPreprocessor] Temp file: " f"{str(tmp_input_file)[:70]}...")
        else:
            print(f"[DtsPreprocessor] Temp file: {tmp_input_file}")
        with open(tmp_input_file, "r") as f:
            print("[DtsPreprocessor] Temp file contents:")
            print(f.read())
    
        try:
            # Build cpp command as a list for shell=False
            cpp_cmd = [
                str(self.cpp_path),
                "-E",
            ]
            for path in self.include_paths:
                cpp_cmd.extend(["-I", str(path)])
            cpp_cmd.append(str(tmp_input_file))
    
            # Debug: print the constructed command list
            print("[DtsPreprocessor] cpp command:", cpp_cmd)
    
            # Run preprocessor with shell=False
            try:
>               result = subprocess.run(
                    cpp_cmd,
                    capture_output=True,
                    text=True,
                    check=True,
                    shell=False,
                )

converter/dts/preprocessor.py:202: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = None, capture_output = True, timeout = None, check = True
popenargs = (['/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/cpp', '-E', '-I', '/var/fold...l697hn0l1cdnx0vrvyr0000gn/T/tmpjl4smb_l/include', '/var/folders/0s/42v7yl697hn0l1cdnx0vrvyr0000gn/T/tmp4tlm6tnt.dts'],)
kwargs = {'shell': False, 'stderr': -1, 'stdout': -1, 'text': True}
process = <Popen: returncode: 1 args: ['/Applications/Xcode.app/Contents/Developer/Too...>
stdout = ''
stderr = "cc: error: no such file or directory: 'c'\ncc: warning: /var/folders/0s/42v7yl697hn0l1cdnx0vrvyr0000gn/T/tmpjl4smb_l/include: 'linker' input unused [-Wunused-command-line-argument]\n"
retcode = 1

    def run(*popenargs,
            input=None, capture_output=False, timeout=None, check=False, **kwargs):
        """Run command with arguments and return a CompletedProcess instance.
    
        The returned instance will have attributes args, returncode, stdout and
        stderr. By default, stdout and stderr are not captured, and those attributes
        will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them,
        or pass capture_output=True to capture both.
    
        If check is True and the exit code was non-zero, it raises a
        CalledProcessError. The CalledProcessError object will have the return code
        in the returncode attribute, and output & stderr attributes if those streams
        were captured.
    
        If timeout is given, and the process takes too long, a TimeoutExpired
        exception will be raised.
    
        There is an optional argument "input", allowing you to
        pass bytes or a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it will be used internally.
    
        By default, all communication is in bytes, and therefore any "input" should
        be bytes, and the stdout and stderr will be bytes. If in text mode, any
        "input" should be a string, and stdout and stderr will be strings decoded
        according to locale encoding, or by "encoding" if set. Text mode is
        triggered by setting any of text, encoding, errors or universal_newlines.
    
        The other arguments are the same as for the Popen constructor.
        """
        if input is not None:
            if kwargs.get('stdin') is not None:
                raise ValueError('stdin and input arguments may not both be used.')
            kwargs['stdin'] = PIPE
    
        if capture_output:
            if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:
                raise ValueError('stdout and stderr arguments may not be used '
                                 'with capture_output.')
            kwargs['stdout'] = PIPE
            kwargs['stderr'] = PIPE
    
        with Popen(*popenargs, **kwargs) as process:
            try:
                stdout, stderr = process.communicate(input, timeout=timeout)
            except TimeoutExpired as exc:
                process.kill()
                if _mswindows:
                    # Windows accumulates the output in a single blocking
                    # read() call run on child threads, with the timeout
                    # being done in a join() on those threads.  communicate()
                    # _after_ kill() is required to collect that and add it
                    # to the exception.
                    exc.stdout, exc.stderr = process.communicate()
                else:
                    # POSIX _communicate already populated the output so
                    # far into the TimeoutExpired exception.
                    process.wait()
                raise
            except:  # Including KeyboardInterrupt, communicate handled that.
                process.kill()
                # We don't call process.wait() as .__exit__ does that for us.
                raise
            retcode = process.poll()
            if check and retcode:
>               raise CalledProcessError(retcode, process.args,
                                         output=stdout, stderr=stderr)
E               subprocess.CalledProcessError: Command '['/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/cpp', '-E', '-I', '/var/folders/0s/42v7yl697hn0l1cdnx0vrvyr0000gn/T/tmpjl4smb_l/include', '/var/folders/0s/42v7yl697hn0l1cdnx0vrvyr0000gn/T/tmp4tlm6tnt.dts']' returned non-zero exit status 1.

/Users/malpern/.pyenv/versions/3.10.16/lib/python3.10/subprocess.py:526: CalledProcessError

During handling of the above exception, another exception occurred:

temp_dir = '/var/folders/0s/42v7yl697hn0l1cdnx0vrvyr0000gn/T/tmpjl4smb_l'

    def test_preprocess_simple_file(temp_dir):
        """Test preprocessing a simple DTS file."""
        # Create a simple DTS file
        input_path = os.path.join(temp_dir, "test.dts")
        with open(input_path, "w") as f:
            f.write(
                """
    #define TEST_VALUE 42
    / {
        test = <TEST_VALUE>;
    };
    """
            )
    
        # Create a temporary include directory with a header file
        include_dir = os.path.join(temp_dir, "include")
        os.makedirs(include_dir)
    
        # Create a header file that defines TEST_VALUE
        header_path = os.path.join(include_dir, "test.h")
        with open(header_path, "w") as f:
            f.write("#define TEST_VALUE 42\n")
    
        preprocessor = DtsPreprocessor(include_paths=[include_dir])
>       result = preprocessor.preprocess(input_path)

tests/dts/test_preprocessor.py:135: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <converter.dts.preprocessor.DtsPreprocessor object at 0x105abfb20>
input_path = PosixPath('/var/folders/0s/42v7yl697hn0l1cdnx0vrvyr0000gn/T/tmpjl4smb_l/test.dts')
matrix_size = None

    def preprocess(
        self,
        input_path: str,
        matrix_size: Optional[Tuple[int, int]] = None,
    ) -> str:
        """Preprocess a DTS file.
    
        Args:
            input_path: Path to the input file
            matrix_size: Optional tuple of (rows, cols) for matrix transform
    
        Returns:
            The preprocessed content as a string
    
        Raises:
            PreprocessorError: If preprocessing fails
        """
        input_path = Path(input_path)
        if not input_path.exists():
            raise PreprocessorError(
                f"Input file does not exist: {input_path}",
                help_text=(
                    "Ensure the input file exists and has proper " "read permissions"
                ),
            )
    
        try:
            with open(input_path, "r") as f:
                content_for_cpp = f.read()
        except Exception as e:
            raise PreprocessorError(
                f"Failed to read input file: {str(e)}",
                file=str(input_path),
                help_text=("Ensure the file exists and has proper " "read permissions"),
            )
    
        # Create a temporary file for the preprocessor input
        tmp_input = tempfile.NamedTemporaryFile(
            mode="w",
            delete=False,
            suffix=".dts",
            dir=None,  # Use system default temp dir (usually /tmp)
        )
        tmp_input.write(content_for_cpp)
        tmp_input.close()
        tmp_input_file = Path(tmp_input.name)
    
        # Debug: print environment and temp file contents
        print("[DtsPreprocessor] ENVIRONMENT:")
        for k, v in os.environ.items():
            if len(v) > 40:
                print(f"  {k}={v[:20]}...{v[-20:]}")
            else:
                print(f"  {k}={v}")
        if len(str(tmp_input_file)) > 70:
            print(f"[DtsPreprocessor] Temp file: " f"{str(tmp_input_file)[:70]}...")
        else:
            print(f"[DtsPreprocessor] Temp file: {tmp_input_file}")
        with open(tmp_input_file, "r") as f:
            print("[DtsPreprocessor] Temp file contents:")
            print(f.read())
    
        try:
            # Build cpp command as a list for shell=False
            cpp_cmd = [
                str(self.cpp_path),
                "-E",
            ]
            for path in self.include_paths:
                cpp_cmd.extend(["-I", str(path)])
            cpp_cmd.append(str(tmp_input_file))
    
            # Debug: print the constructed command list
            print("[DtsPreprocessor] cpp command:", cpp_cmd)
    
            # Run preprocessor with shell=False
            try:
                result = subprocess.run(
                    cpp_cmd,
                    capture_output=True,
                    text=True,
                    check=True,
                    shell=False,
                )
            except subprocess.CalledProcessError as e:
>               raise PreprocessorError(
                    "Failed to process DTS directives",
                    file=str(input_path),
                    context=str(e),
                    help_text=("Check for malformed DTS directives in " "input file"),
                )
E               converter.dts.preprocessor.PreprocessorError: Failed to process DTS directives

converter/dts/preprocessor.py:210: PreprocessorError
----------------------------- Captured stdout call -----------------------------
[DtsPreprocessor] ENVIRONMENT:
  MallocNanoZone=0
  USER=malpern
  SECURITYSESSIONID=186a3
  COMMAND_MODE=unix2003
  __CFBundleIdentifier=com.todesktop.230313mzl4w4u92
  PATH=/Users/malpern/.curs....cache/lm-studio/bin
  LOGNAME=malpern
  SSH_AUTH_SOCK=/private/tmp/com.app...x1qskoux7b/Listeners
  HOME=/Users/malpern
  SHELL=/bin/zsh
  TMPDIR=/var/folders/0s/42v7...1cdnx0vrvyr0000gn/T/
  LaunchInstanceID=BFD4BF06-15BD-4F76-8D8A-1AEC50E6795A
  __CF_USER_TEXT_ENCODING=0x1F5:0x0:0x0
  XPC_SERVICE_NAME=0
  XPC_FLAGS=0x0
  ORIGINAL_XDG_CURRENT_DESKTOP=undefined
  CURSOR_TRACE_ID=f5e099fd466543c5a0d391e03a641e89
  SHLVL=1
  PWD=/Volumes/FlashGordon...ox/code/nicktokatana
  OLDPWD=/Volumes/FlashGordon...ox/code/nicktokatana
  HOMEBREW_PREFIX=/opt/homebrew
  HOMEBREW_CELLAR=/opt/homebrew/Cellar
  HOMEBREW_REPOSITORY=/opt/homebrew
  INFOPATH=/opt/homebrew/share/...homebrew/share/info:
  YOUR_CONSUMER_KEY=ah6HAffNJRCv4xNrV4OZcVIrQ
  YOUR_CONSUMER_SECRET=EXM9IzH9IEdE2yJf0t5F...DPuFXLk55DwB8pLRswR5
  YOUR_ACCESS_TOKEN=1483-5UbadNrxZUkJpAp...JSXPVSxtsPwJyrUrZvcO
  YOUR_ACCESS_TOKEN_SECRET=jeyyEWPHAgoS0ebKus4t...0jH2T3gRCIz3dsYXQwqS
  YOUR_BEARER_TOKEN=AAAAAAAAAAAAAAAAAAAA...8YVAWCOQu6Pyu4yhuY0a
  OPENAI_API_KEY=sk-qVQDNdwpfPhrAvFr9...ob362AQbhWVa3p95yD28
  ANTHROPIC_API_KEY=sk-ant-api03-Tq7nYRm...SCuUoAfwIQg-NWFWuAAA
  TAVILY_API_KEY=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
  BING_SUBSCRIPTION_KEY=bec8ded0f34a421ba60cc3bd4626825e
  EDITOR=vi
  ZSH=/Users/malpern/.oh-my-zsh
  PAGER=head -n 10000 | cat
  LESS=-R
  LSCOLORS=Gxfxcxdxbxegedabagacad
  LS_COLORS=di=1;36:ln=35:so=32:...46:tw=30;42:ow=30;43
  PYENV_ROOT=/Users/malpern/.pyenv
  PYENV_SHELL=zsh
  DISABLE_AUTO_UPDATE=true
  TERM_PROGRAM=vscode
  TERM_PROGRAM_VERSION=0.50.1
  LANG=en_US.UTF-8
  COLORTERM=truecolor
  GIT_ASKPASS=/Applications/Cursor.../git/dist/askpass.sh
  VSCODE_GIT_ASKPASS_NODE=/Applications/Cursor...rsor Helper (Plugin)
  VSCODE_GIT_ASKPASS_EXTRA_ARGS=
  VSCODE_GIT_ASKPASS_MAIN=/Applications/Cursor...dist/askpass-main.js
  VSCODE_GIT_IPC_HANDLE=/var/folders/0s/42v7...-git-14a5ce3e7f.sock
  PYENV_VERSION=3.10.16
  PYENV_DIR=/
  VIRTUAL_ENV=/Volumes/Flash Gordo...e/nicktokatana/.venv
  PYENV_HOOK_PATH=/Users/malpern/.pyen.../usr/lib/pyenv/hooks
  VIRTUAL_ENV_PROMPT=.venv
  VSCODE_INJECTION=1
  ZDOTDIR=/Users/malpern
  USER_ZDOTDIR=/Users/malpern
  TERM=xterm-256color
  PS1=.venv%(?:%{[01;32m%...} $(git_prompt_info)
  PYTHONPATH=.
  _=/Users/malpern/.pyen...s/3.10.16/bin/pytest
  PYTEST_VERSION=8.3.4
  PYTEST_CURRENT_TEST=tests/dts/test_prepr...s_simple_file (call)
[DtsPreprocessor] Temp file: /var/folders/0s/42v7yl697hn0l1cdnx0vrvyr0000gn/T/tmp4tlm6tnt.dts
[DtsPreprocessor] Temp file contents:

#define TEST_VALUE 42
/ {
    test = <TEST_VALUE>;
};

[DtsPreprocessor] cpp command: ['/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/cpp', '-E', '-I', '/var/folders/0s/42v7yl697hn0l1cdnx0vrvyr0000gn/T/tmpjl4smb_l/include', '/var/folders/0s/42v7yl697hn0l1cdnx0vrvyr0000gn/T/tmp4tlm6tnt.dts']
________________________ test_preprocess_with_includes _________________________

self = <converter.dts.preprocessor.DtsPreprocessor object at 0x1057f6dd0>
input_path = PosixPath('/var/folders/0s/42v7yl697hn0l1cdnx0vrvyr0000gn/T/tmpa0raw_hy/main.dts')
matrix_size = None

    def preprocess(
        self,
        input_path: str,
        matrix_size: Optional[Tuple[int, int]] = None,
    ) -> str:
        """Preprocess a DTS file.
    
        Args:
            input_path: Path to the input file
            matrix_size: Optional tuple of (rows, cols) for matrix transform
    
        Returns:
            The preprocessed content as a string
    
        Raises:
            PreprocessorError: If preprocessing fails
        """
        input_path = Path(input_path)
        if not input_path.exists():
            raise PreprocessorError(
                f"Input file does not exist: {input_path}",
                help_text=(
                    "Ensure the input file exists and has proper " "read permissions"
                ),
            )
    
        try:
            with open(input_path, "r") as f:
                content_for_cpp = f.read()
        except Exception as e:
            raise PreprocessorError(
                f"Failed to read input file: {str(e)}",
                file=str(input_path),
                help_text=("Ensure the file exists and has proper " "read permissions"),
            )
    
        # Create a temporary file for the preprocessor input
        tmp_input = tempfile.NamedTemporaryFile(
            mode="w",
            delete=False,
            suffix=".dts",
            dir=None,  # Use system default temp dir (usually /tmp)
        )
        tmp_input.write(content_for_cpp)
        tmp_input.close()
        tmp_input_file = Path(tmp_input.name)
    
        # Debug: print environment and temp file contents
        print("[DtsPreprocessor] ENVIRONMENT:")
        for k, v in os.environ.items():
            if len(v) > 40:
                print(f"  {k}={v[:20]}...{v[-20:]}")
            else:
                print(f"  {k}={v}")
        if len(str(tmp_input_file)) > 70:
            print(f"[DtsPreprocessor] Temp file: " f"{str(tmp_input_file)[:70]}...")
        else:
            print(f"[DtsPreprocessor] Temp file: {tmp_input_file}")
        with open(tmp_input_file, "r") as f:
            print("[DtsPreprocessor] Temp file contents:")
            print(f.read())
    
        try:
            # Build cpp command as a list for shell=False
            cpp_cmd = [
                str(self.cpp_path),
                "-E",
            ]
            for path in self.include_paths:
                cpp_cmd.extend(["-I", str(path)])
            cpp_cmd.append(str(tmp_input_file))
    
            # Debug: print the constructed command list
            print("[DtsPreprocessor] cpp command:", cpp_cmd)
    
            # Run preprocessor with shell=False
            try:
>               result = subprocess.run(
                    cpp_cmd,
                    capture_output=True,
                    text=True,
                    check=True,
                    shell=False,
                )

converter/dts/preprocessor.py:202: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = None, capture_output = True, timeout = None, check = True
popenargs = (['/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/cpp', '-E', '-I', '/var/fold...l697hn0l1cdnx0vrvyr0000gn/T/tmpa0raw_hy/include', '/var/folders/0s/42v7yl697hn0l1cdnx0vrvyr0000gn/T/tmpa7zgritm.dts'],)
kwargs = {'shell': False, 'stderr': -1, 'stdout': -1, 'text': True}
process = <Popen: returncode: 1 args: ['/Applications/Xcode.app/Contents/Developer/Too...>
stdout = ''
stderr = "cc: error: no such file or directory: 'c'\ncc: warning: /var/folders/0s/42v7yl697hn0l1cdnx0vrvyr0000gn/T/tmpa0raw_hy/include: 'linker' input unused [-Wunused-command-line-argument]\n"
retcode = 1

    def run(*popenargs,
            input=None, capture_output=False, timeout=None, check=False, **kwargs):
        """Run command with arguments and return a CompletedProcess instance.
    
        The returned instance will have attributes args, returncode, stdout and
        stderr. By default, stdout and stderr are not captured, and those attributes
        will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them,
        or pass capture_output=True to capture both.
    
        If check is True and the exit code was non-zero, it raises a
        CalledProcessError. The CalledProcessError object will have the return code
        in the returncode attribute, and output & stderr attributes if those streams
        were captured.
    
        If timeout is given, and the process takes too long, a TimeoutExpired
        exception will be raised.
    
        There is an optional argument "input", allowing you to
        pass bytes or a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it will be used internally.
    
        By default, all communication is in bytes, and therefore any "input" should
        be bytes, and the stdout and stderr will be bytes. If in text mode, any
        "input" should be a string, and stdout and stderr will be strings decoded
        according to locale encoding, or by "encoding" if set. Text mode is
        triggered by setting any of text, encoding, errors or universal_newlines.
    
        The other arguments are the same as for the Popen constructor.
        """
        if input is not None:
            if kwargs.get('stdin') is not None:
                raise ValueError('stdin and input arguments may not both be used.')
            kwargs['stdin'] = PIPE
    
        if capture_output:
            if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:
                raise ValueError('stdout and stderr arguments may not be used '
                                 'with capture_output.')
            kwargs['stdout'] = PIPE
            kwargs['stderr'] = PIPE
    
        with Popen(*popenargs, **kwargs) as process:
            try:
                stdout, stderr = process.communicate(input, timeout=timeout)
            except TimeoutExpired as exc:
                process.kill()
                if _mswindows:
                    # Windows accumulates the output in a single blocking
                    # read() call run on child threads, with the timeout
                    # being done in a join() on those threads.  communicate()
                    # _after_ kill() is required to collect that and add it
                    # to the exception.
                    exc.stdout, exc.stderr = process.communicate()
                else:
                    # POSIX _communicate already populated the output so
                    # far into the TimeoutExpired exception.
                    process.wait()
                raise
            except:  # Including KeyboardInterrupt, communicate handled that.
                process.kill()
                # We don't call process.wait() as .__exit__ does that for us.
                raise
            retcode = process.poll()
            if check and retcode:
>               raise CalledProcessError(retcode, process.args,
                                         output=stdout, stderr=stderr)
E               subprocess.CalledProcessError: Command '['/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/cpp', '-E', '-I', '/var/folders/0s/42v7yl697hn0l1cdnx0vrvyr0000gn/T/tmpa0raw_hy/include', '/var/folders/0s/42v7yl697hn0l1cdnx0vrvyr0000gn/T/tmpa7zgritm.dts']' returned non-zero exit status 1.

/Users/malpern/.pyenv/versions/3.10.16/lib/python3.10/subprocess.py:526: CalledProcessError

During handling of the above exception, another exception occurred:

temp_dir = '/var/folders/0s/42v7yl697hn0l1cdnx0vrvyr0000gn/T/tmpa0raw_hy'

    def test_preprocess_with_includes(temp_dir):
        """Test preprocessing with include files."""
        # Create include directory and file
        include_dir = os.path.join(temp_dir, "include")
        os.makedirs(include_dir)
    
        header_path = os.path.join(include_dir, "test.h")
        with open(header_path, "w") as f:
            f.write("#define HEADER_VALUE 123\n")
    
        # Create main DTS file
        input_path = os.path.join(temp_dir, "main.dts")
        with open(input_path, "w") as f:
            f.write(
                """
    #include "test.h"
    / {
        test = <HEADER_VALUE>;
    };
    """
            )
    
        preprocessor = DtsPreprocessor(include_paths=[include_dir])
>       result = preprocessor.preprocess(input_path)

tests/dts/test_preprocessor.py:190: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <converter.dts.preprocessor.DtsPreprocessor object at 0x1057f6dd0>
input_path = PosixPath('/var/folders/0s/42v7yl697hn0l1cdnx0vrvyr0000gn/T/tmpa0raw_hy/main.dts')
matrix_size = None

    def preprocess(
        self,
        input_path: str,
        matrix_size: Optional[Tuple[int, int]] = None,
    ) -> str:
        """Preprocess a DTS file.
    
        Args:
            input_path: Path to the input file
            matrix_size: Optional tuple of (rows, cols) for matrix transform
    
        Returns:
            The preprocessed content as a string
    
        Raises:
            PreprocessorError: If preprocessing fails
        """
        input_path = Path(input_path)
        if not input_path.exists():
            raise PreprocessorError(
                f"Input file does not exist: {input_path}",
                help_text=(
                    "Ensure the input file exists and has proper " "read permissions"
                ),
            )
    
        try:
            with open(input_path, "r") as f:
                content_for_cpp = f.read()
        except Exception as e:
            raise PreprocessorError(
                f"Failed to read input file: {str(e)}",
                file=str(input_path),
                help_text=("Ensure the file exists and has proper " "read permissions"),
            )
    
        # Create a temporary file for the preprocessor input
        tmp_input = tempfile.NamedTemporaryFile(
            mode="w",
            delete=False,
            suffix=".dts",
            dir=None,  # Use system default temp dir (usually /tmp)
        )
        tmp_input.write(content_for_cpp)
        tmp_input.close()
        tmp_input_file = Path(tmp_input.name)
    
        # Debug: print environment and temp file contents
        print("[DtsPreprocessor] ENVIRONMENT:")
        for k, v in os.environ.items():
            if len(v) > 40:
                print(f"  {k}={v[:20]}...{v[-20:]}")
            else:
                print(f"  {k}={v}")
        if len(str(tmp_input_file)) > 70:
            print(f"[DtsPreprocessor] Temp file: " f"{str(tmp_input_file)[:70]}...")
        else:
            print(f"[DtsPreprocessor] Temp file: {tmp_input_file}")
        with open(tmp_input_file, "r") as f:
            print("[DtsPreprocessor] Temp file contents:")
            print(f.read())
    
        try:
            # Build cpp command as a list for shell=False
            cpp_cmd = [
                str(self.cpp_path),
                "-E",
            ]
            for path in self.include_paths:
                cpp_cmd.extend(["-I", str(path)])
            cpp_cmd.append(str(tmp_input_file))
    
            # Debug: print the constructed command list
            print("[DtsPreprocessor] cpp command:", cpp_cmd)
    
            # Run preprocessor with shell=False
            try:
                result = subprocess.run(
                    cpp_cmd,
                    capture_output=True,
                    text=True,
                    check=True,
                    shell=False,
                )
            except subprocess.CalledProcessError as e:
>               raise PreprocessorError(
                    "Failed to process DTS directives",
                    file=str(input_path),
                    context=str(e),
                    help_text=("Check for malformed DTS directives in " "input file"),
                )
E               converter.dts.preprocessor.PreprocessorError: Failed to process DTS directives

converter/dts/preprocessor.py:210: PreprocessorError
----------------------------- Captured stdout call -----------------------------
[DtsPreprocessor] ENVIRONMENT:
  MallocNanoZone=0
  USER=malpern
  SECURITYSESSIONID=186a3
  COMMAND_MODE=unix2003
  __CFBundleIdentifier=com.todesktop.230313mzl4w4u92
  PATH=/Users/malpern/.curs....cache/lm-studio/bin
  LOGNAME=malpern
  SSH_AUTH_SOCK=/private/tmp/com.app...x1qskoux7b/Listeners
  HOME=/Users/malpern
  SHELL=/bin/zsh
  TMPDIR=/var/folders/0s/42v7...1cdnx0vrvyr0000gn/T/
  LaunchInstanceID=BFD4BF06-15BD-4F76-8D8A-1AEC50E6795A
  __CF_USER_TEXT_ENCODING=0x1F5:0x0:0x0
  XPC_SERVICE_NAME=0
  XPC_FLAGS=0x0
  ORIGINAL_XDG_CURRENT_DESKTOP=undefined
  CURSOR_TRACE_ID=f5e099fd466543c5a0d391e03a641e89
  SHLVL=1
  PWD=/Volumes/FlashGordon...ox/code/nicktokatana
  OLDPWD=/Volumes/FlashGordon...ox/code/nicktokatana
  HOMEBREW_PREFIX=/opt/homebrew
  HOMEBREW_CELLAR=/opt/homebrew/Cellar
  HOMEBREW_REPOSITORY=/opt/homebrew
  INFOPATH=/opt/homebrew/share/...homebrew/share/info:
  YOUR_CONSUMER_KEY=ah6HAffNJRCv4xNrV4OZcVIrQ
  YOUR_CONSUMER_SECRET=EXM9IzH9IEdE2yJf0t5F...DPuFXLk55DwB8pLRswR5
  YOUR_ACCESS_TOKEN=1483-5UbadNrxZUkJpAp...JSXPVSxtsPwJyrUrZvcO
  YOUR_ACCESS_TOKEN_SECRET=jeyyEWPHAgoS0ebKus4t...0jH2T3gRCIz3dsYXQwqS
  YOUR_BEARER_TOKEN=AAAAAAAAAAAAAAAAAAAA...8YVAWCOQu6Pyu4yhuY0a
  OPENAI_API_KEY=sk-qVQDNdwpfPhrAvFr9...ob362AQbhWVa3p95yD28
  ANTHROPIC_API_KEY=sk-ant-api03-Tq7nYRm...SCuUoAfwIQg-NWFWuAAA
  TAVILY_API_KEY=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
  BING_SUBSCRIPTION_KEY=bec8ded0f34a421ba60cc3bd4626825e
  EDITOR=vi
  ZSH=/Users/malpern/.oh-my-zsh
  PAGER=head -n 10000 | cat
  LESS=-R
  LSCOLORS=Gxfxcxdxbxegedabagacad
  LS_COLORS=di=1;36:ln=35:so=32:...46:tw=30;42:ow=30;43
  PYENV_ROOT=/Users/malpern/.pyenv
  PYENV_SHELL=zsh
  DISABLE_AUTO_UPDATE=true
  TERM_PROGRAM=vscode
  TERM_PROGRAM_VERSION=0.50.1
  LANG=en_US.UTF-8
  COLORTERM=truecolor
  GIT_ASKPASS=/Applications/Cursor.../git/dist/askpass.sh
  VSCODE_GIT_ASKPASS_NODE=/Applications/Cursor...rsor Helper (Plugin)
  VSCODE_GIT_ASKPASS_EXTRA_ARGS=
  VSCODE_GIT_ASKPASS_MAIN=/Applications/Cursor...dist/askpass-main.js
  VSCODE_GIT_IPC_HANDLE=/var/folders/0s/42v7...-git-14a5ce3e7f.sock
  PYENV_VERSION=3.10.16
  PYENV_DIR=/
  VIRTUAL_ENV=/Volumes/Flash Gordo...e/nicktokatana/.venv
  PYENV_HOOK_PATH=/Users/malpern/.pyen.../usr/lib/pyenv/hooks
  VIRTUAL_ENV_PROMPT=.venv
  VSCODE_INJECTION=1
  ZDOTDIR=/Users/malpern
  USER_ZDOTDIR=/Users/malpern
  TERM=xterm-256color
  PS1=.venv%(?:%{[01;32m%...} $(git_prompt_info)
  PYTHONPATH=.
  _=/Users/malpern/.pyen...s/3.10.16/bin/pytest
  PYTEST_VERSION=8.3.4
  PYTEST_CURRENT_TEST=tests/dts/test_prepr...with_includes (call)
[DtsPreprocessor] Temp file: /var/folders/0s/42v7yl697hn0l1cdnx0vrvyr0000gn/T/tmpa7zgritm.dts
[DtsPreprocessor] Temp file contents:

#include "test.h"
/ {
    test = <HEADER_VALUE>;
};

[DtsPreprocessor] cpp command: ['/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/cpp', '-E', '-I', '/var/folders/0s/42v7yl697hn0l1cdnx0vrvyr0000gn/T/tmpa0raw_hy/include', '/var/folders/0s/42v7yl697hn0l1cdnx0vrvyr0000gn/T/tmpa7zgritm.dts']
_________________________ test_preprocess_invalid_file _________________________

    def test_preprocess_invalid_file():
        """Test preprocessing a non-existent file."""
        preprocessor = DtsPreprocessor()
        with pytest.raises(FileNotFoundError):
>           preprocessor.preprocess("nonexistent.dts")

tests/dts/test_preprocessor.py:201: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <converter.dts.preprocessor.DtsPreprocessor object at 0x105a4bd90>
input_path = PosixPath('nonexistent.dts'), matrix_size = None

    def preprocess(
        self,
        input_path: str,
        matrix_size: Optional[Tuple[int, int]] = None,
    ) -> str:
        """Preprocess a DTS file.
    
        Args:
            input_path: Path to the input file
            matrix_size: Optional tuple of (rows, cols) for matrix transform
    
        Returns:
            The preprocessed content as a string
    
        Raises:
            PreprocessorError: If preprocessing fails
        """
        input_path = Path(input_path)
        if not input_path.exists():
>           raise PreprocessorError(
                f"Input file does not exist: {input_path}",
                help_text=(
                    "Ensure the input file exists and has proper " "read permissions"
                ),
            )
E           converter.dts.preprocessor.PreprocessorError: Input file does not exist: nonexistent.dts

converter/dts/preprocessor.py:144: PreprocessorError
_____________________ test_preprocess_invalid_cpp_command ______________________

temp_dir = '/var/folders/0s/42v7yl697hn0l1cdnx0vrvyr0000gn/T/tmp8ymxfgy_'

    def test_preprocess_invalid_cpp_command(temp_dir):
        """Test preprocessing with invalid cpp command."""
        # Create a simple DTS file
        input_path = os.path.join(temp_dir, "test.dts")
        with open(input_path, "w") as f:
            f.write("/ { test = <1>; };")
    
        # Use invalid cpp path
        preprocessor = DtsPreprocessor(cpp_path="invalid_cpp")
        with pytest.raises(PreprocessorError):
>           preprocessor.preprocess(input_path)

tests/dts/test_preprocessor.py:214: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
converter/dts/preprocessor.py:202: in preprocess
    result = subprocess.run(
/Users/malpern/.pyenv/versions/3.10.16/lib/python3.10/subprocess.py:503: in run
    with Popen(*popenargs, **kwargs) as process:
/Users/malpern/.pyenv/versions/3.10.16/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen: returncode: 255 args: ['invalid_cpp', '-E', '/var/folders/0s/42v7yl6...>
args = ['invalid_cpp', '-E', '/var/folders/0s/42v7yl697hn0l1cdnx0vrvyr0000gn/T/tmpbamugo33.dts']
executable = b'invalid_cpp', preexec_fn = None, close_fds = True, pass_fds = ()
cwd = None, env = None, startupinfo = None, creationflags = 0, shell = False
p2cread = -1, p2cwrite = -1, c2pread = 11, c2pwrite = 12, errread = 13
errwrite = 14, restore_signals = True, gid = None, gids = None, uid = None
umask = -1, start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""
    
        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)
    
        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable
    
        if executable is None:
            executable = args[0]
    
        sys.audit("subprocess.Popen", executable, args, cwd, env)
    
        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return
    
        orig_executable = executable
    
        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()
    
                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)
    
            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)
    
            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)
    
        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass
    
            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: 'invalid_cpp'

/Users/malpern/.pyenv/versions/3.10.16/lib/python3.10/subprocess.py:1863: FileNotFoundError
----------------------------- Captured stdout call -----------------------------
[DtsPreprocessor] ENVIRONMENT:
  MallocNanoZone=0
  USER=malpern
  SECURITYSESSIONID=186a3
  COMMAND_MODE=unix2003
  __CFBundleIdentifier=com.todesktop.230313mzl4w4u92
  PATH=/Users/malpern/.curs....cache/lm-studio/bin
  LOGNAME=malpern
  SSH_AUTH_SOCK=/private/tmp/com.app...x1qskoux7b/Listeners
  HOME=/Users/malpern
  SHELL=/bin/zsh
  TMPDIR=/var/folders/0s/42v7...1cdnx0vrvyr0000gn/T/
  LaunchInstanceID=BFD4BF06-15BD-4F76-8D8A-1AEC50E6795A
  __CF_USER_TEXT_ENCODING=0x1F5:0x0:0x0
  XPC_SERVICE_NAME=0
  XPC_FLAGS=0x0
  ORIGINAL_XDG_CURRENT_DESKTOP=undefined
  CURSOR_TRACE_ID=f5e099fd466543c5a0d391e03a641e89
  SHLVL=1
  PWD=/Volumes/FlashGordon...ox/code/nicktokatana
  OLDPWD=/Volumes/FlashGordon...ox/code/nicktokatana
  HOMEBREW_PREFIX=/opt/homebrew
  HOMEBREW_CELLAR=/opt/homebrew/Cellar
  HOMEBREW_REPOSITORY=/opt/homebrew
  INFOPATH=/opt/homebrew/share/...homebrew/share/info:
  YOUR_CONSUMER_KEY=ah6HAffNJRCv4xNrV4OZcVIrQ
  YOUR_CONSUMER_SECRET=EXM9IzH9IEdE2yJf0t5F...DPuFXLk55DwB8pLRswR5
  YOUR_ACCESS_TOKEN=1483-5UbadNrxZUkJpAp...JSXPVSxtsPwJyrUrZvcO
  YOUR_ACCESS_TOKEN_SECRET=jeyyEWPHAgoS0ebKus4t...0jH2T3gRCIz3dsYXQwqS
  YOUR_BEARER_TOKEN=AAAAAAAAAAAAAAAAAAAA...8YVAWCOQu6Pyu4yhuY0a
  OPENAI_API_KEY=sk-qVQDNdwpfPhrAvFr9...ob362AQbhWVa3p95yD28
  ANTHROPIC_API_KEY=sk-ant-api03-Tq7nYRm...SCuUoAfwIQg-NWFWuAAA
  TAVILY_API_KEY=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
  BING_SUBSCRIPTION_KEY=bec8ded0f34a421ba60cc3bd4626825e
  EDITOR=vi
  ZSH=/Users/malpern/.oh-my-zsh
  PAGER=head -n 10000 | cat
  LESS=-R
  LSCOLORS=Gxfxcxdxbxegedabagacad
  LS_COLORS=di=1;36:ln=35:so=32:...46:tw=30;42:ow=30;43
  PYENV_ROOT=/Users/malpern/.pyenv
  PYENV_SHELL=zsh
  DISABLE_AUTO_UPDATE=true
  TERM_PROGRAM=vscode
  TERM_PROGRAM_VERSION=0.50.1
  LANG=en_US.UTF-8
  COLORTERM=truecolor
  GIT_ASKPASS=/Applications/Cursor.../git/dist/askpass.sh
  VSCODE_GIT_ASKPASS_NODE=/Applications/Cursor...rsor Helper (Plugin)
  VSCODE_GIT_ASKPASS_EXTRA_ARGS=
  VSCODE_GIT_ASKPASS_MAIN=/Applications/Cursor...dist/askpass-main.js
  VSCODE_GIT_IPC_HANDLE=/var/folders/0s/42v7...-git-14a5ce3e7f.sock
  PYENV_VERSION=3.10.16
  PYENV_DIR=/
  VIRTUAL_ENV=/Volumes/Flash Gordo...e/nicktokatana/.venv
  PYENV_HOOK_PATH=/Users/malpern/.pyen.../usr/lib/pyenv/hooks
  VIRTUAL_ENV_PROMPT=.venv
  VSCODE_INJECTION=1
  ZDOTDIR=/Users/malpern
  USER_ZDOTDIR=/Users/malpern
  TERM=xterm-256color
  PS1=.venv%(?:%{[01;32m%...} $(git_prompt_info)
  PYTHONPATH=.
  _=/Users/malpern/.pyen...s/3.10.16/bin/pytest
  PYTEST_VERSION=8.3.4
  PYTEST_CURRENT_TEST=tests/dts/test_prepr...d_cpp_command (call)
[DtsPreprocessor] Temp file: /var/folders/0s/42v7yl697hn0l1cdnx0vrvyr0000gn/T/tmpbamugo33.dts
[DtsPreprocessor] Temp file contents:
/ { test = <1>; };
[DtsPreprocessor] cpp command: ['invalid_cpp', '-E', '/var/folders/0s/42v7yl697hn0l1cdnx0vrvyr0000gn/T/tmpbamugo33.dts']
________________________ test_preprocess_simple_keymap _________________________

self = <converter.dts.preprocessor.DtsPreprocessor object at 0x1058f7820>
input_path = PosixPath('/Volumes/FlashGordon/Dropbox/code/nicktokatana/tests/fixtures/dts/simple_keymap.zmk')
matrix_size = None

    def preprocess(
        self,
        input_path: str,
        matrix_size: Optional[Tuple[int, int]] = None,
    ) -> str:
        """Preprocess a DTS file.
    
        Args:
            input_path: Path to the input file
            matrix_size: Optional tuple of (rows, cols) for matrix transform
    
        Returns:
            The preprocessed content as a string
    
        Raises:
            PreprocessorError: If preprocessing fails
        """
        input_path = Path(input_path)
        if not input_path.exists():
            raise PreprocessorError(
                f"Input file does not exist: {input_path}",
                help_text=(
                    "Ensure the input file exists and has proper " "read permissions"
                ),
            )
    
        try:
            with open(input_path, "r") as f:
                content_for_cpp = f.read()
        except Exception as e:
            raise PreprocessorError(
                f"Failed to read input file: {str(e)}",
                file=str(input_path),
                help_text=("Ensure the file exists and has proper " "read permissions"),
            )
    
        # Create a temporary file for the preprocessor input
        tmp_input = tempfile.NamedTemporaryFile(
            mode="w",
            delete=False,
            suffix=".dts",
            dir=None,  # Use system default temp dir (usually /tmp)
        )
        tmp_input.write(content_for_cpp)
        tmp_input.close()
        tmp_input_file = Path(tmp_input.name)
    
        # Debug: print environment and temp file contents
        print("[DtsPreprocessor] ENVIRONMENT:")
        for k, v in os.environ.items():
            if len(v) > 40:
                print(f"  {k}={v[:20]}...{v[-20:]}")
            else:
                print(f"  {k}={v}")
        if len(str(tmp_input_file)) > 70:
            print(f"[DtsPreprocessor] Temp file: " f"{str(tmp_input_file)[:70]}...")
        else:
            print(f"[DtsPreprocessor] Temp file: {tmp_input_file}")
        with open(tmp_input_file, "r") as f:
            print("[DtsPreprocessor] Temp file contents:")
            print(f.read())
    
        try:
            # Build cpp command as a list for shell=False
            cpp_cmd = [
                str(self.cpp_path),
                "-E",
            ]
            for path in self.include_paths:
                cpp_cmd.extend(["-I", str(path)])
            cpp_cmd.append(str(tmp_input_file))
    
            # Debug: print the constructed command list
            print("[DtsPreprocessor] cpp command:", cpp_cmd)
    
            # Run preprocessor with shell=False
            try:
>               result = subprocess.run(
                    cpp_cmd,
                    capture_output=True,
                    text=True,
                    check=True,
                    shell=False,
                )

converter/dts/preprocessor.py:202: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = None, capture_output = True, timeout = None, check = True
popenargs = (['/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/cpp', '-E', '-I', '/Volumes/...ox/code/nicktokatana/tests/fixtures/dts/include', '/var/folders/0s/42v7yl697hn0l1cdnx0vrvyr0000gn/T/tmpk0hyfblh.dts'],)
kwargs = {'shell': False, 'stderr': -1, 'stdout': -1, 'text': True}
process = <Popen: returncode: 1 args: ['/Applications/Xcode.app/Contents/Developer/Too...>
stdout = ''
stderr = "cc: error: no such file or directory: 'c'\ncc: warning: /Volumes/FlashGordon/Dropbox/code/nicktokatana/tests/fixtures/dts/include: 'linker' input unused [-Wunused-command-line-argument]\n"
retcode = 1

    def run(*popenargs,
            input=None, capture_output=False, timeout=None, check=False, **kwargs):
        """Run command with arguments and return a CompletedProcess instance.
    
        The returned instance will have attributes args, returncode, stdout and
        stderr. By default, stdout and stderr are not captured, and those attributes
        will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them,
        or pass capture_output=True to capture both.
    
        If check is True and the exit code was non-zero, it raises a
        CalledProcessError. The CalledProcessError object will have the return code
        in the returncode attribute, and output & stderr attributes if those streams
        were captured.
    
        If timeout is given, and the process takes too long, a TimeoutExpired
        exception will be raised.
    
        There is an optional argument "input", allowing you to
        pass bytes or a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it will be used internally.
    
        By default, all communication is in bytes, and therefore any "input" should
        be bytes, and the stdout and stderr will be bytes. If in text mode, any
        "input" should be a string, and stdout and stderr will be strings decoded
        according to locale encoding, or by "encoding" if set. Text mode is
        triggered by setting any of text, encoding, errors or universal_newlines.
    
        The other arguments are the same as for the Popen constructor.
        """
        if input is not None:
            if kwargs.get('stdin') is not None:
                raise ValueError('stdin and input arguments may not both be used.')
            kwargs['stdin'] = PIPE
    
        if capture_output:
            if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:
                raise ValueError('stdout and stderr arguments may not be used '
                                 'with capture_output.')
            kwargs['stdout'] = PIPE
            kwargs['stderr'] = PIPE
    
        with Popen(*popenargs, **kwargs) as process:
            try:
                stdout, stderr = process.communicate(input, timeout=timeout)
            except TimeoutExpired as exc:
                process.kill()
                if _mswindows:
                    # Windows accumulates the output in a single blocking
                    # read() call run on child threads, with the timeout
                    # being done in a join() on those threads.  communicate()
                    # _after_ kill() is required to collect that and add it
                    # to the exception.
                    exc.stdout, exc.stderr = process.communicate()
                else:
                    # POSIX _communicate already populated the output so
                    # far into the TimeoutExpired exception.
                    process.wait()
                raise
            except:  # Including KeyboardInterrupt, communicate handled that.
                process.kill()
                # We don't call process.wait() as .__exit__ does that for us.
                raise
            retcode = process.poll()
            if check and retcode:
>               raise CalledProcessError(retcode, process.args,
                                         output=stdout, stderr=stderr)
E               subprocess.CalledProcessError: Command '['/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/cpp', '-E', '-I', '/Volumes/FlashGordon/Dropbox/code/nicktokatana/tests/fixtures/dts/include', '/var/folders/0s/42v7yl697hn0l1cdnx0vrvyr0000gn/T/tmpk0hyfblh.dts']' returned non-zero exit status 1.

/Users/malpern/.pyenv/versions/3.10.16/lib/python3.10/subprocess.py:526: CalledProcessError

During handling of the above exception, another exception occurred:

preprocessor = <converter.dts.preprocessor.DtsPreprocessor object at 0x1058f7820>
simple_keymap_path = PosixPath('/Volumes/FlashGordon/Dropbox/code/nicktokatana/tests/fixtures/dts/simple_keymap.zmk')

    def test_preprocess_simple_keymap(preprocessor, simple_keymap_path):
        """Test preprocessing a simple keymap."""
>       result = preprocessor.preprocess(str(simple_keymap_path))

tests/dts/test_preprocessor.py:245: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <converter.dts.preprocessor.DtsPreprocessor object at 0x1058f7820>
input_path = PosixPath('/Volumes/FlashGordon/Dropbox/code/nicktokatana/tests/fixtures/dts/simple_keymap.zmk')
matrix_size = None

    def preprocess(
        self,
        input_path: str,
        matrix_size: Optional[Tuple[int, int]] = None,
    ) -> str:
        """Preprocess a DTS file.
    
        Args:
            input_path: Path to the input file
            matrix_size: Optional tuple of (rows, cols) for matrix transform
    
        Returns:
            The preprocessed content as a string
    
        Raises:
            PreprocessorError: If preprocessing fails
        """
        input_path = Path(input_path)
        if not input_path.exists():
            raise PreprocessorError(
                f"Input file does not exist: {input_path}",
                help_text=(
                    "Ensure the input file exists and has proper " "read permissions"
                ),
            )
    
        try:
            with open(input_path, "r") as f:
                content_for_cpp = f.read()
        except Exception as e:
            raise PreprocessorError(
                f"Failed to read input file: {str(e)}",
                file=str(input_path),
                help_text=("Ensure the file exists and has proper " "read permissions"),
            )
    
        # Create a temporary file for the preprocessor input
        tmp_input = tempfile.NamedTemporaryFile(
            mode="w",
            delete=False,
            suffix=".dts",
            dir=None,  # Use system default temp dir (usually /tmp)
        )
        tmp_input.write(content_for_cpp)
        tmp_input.close()
        tmp_input_file = Path(tmp_input.name)
    
        # Debug: print environment and temp file contents
        print("[DtsPreprocessor] ENVIRONMENT:")
        for k, v in os.environ.items():
            if len(v) > 40:
                print(f"  {k}={v[:20]}...{v[-20:]}")
            else:
                print(f"  {k}={v}")
        if len(str(tmp_input_file)) > 70:
            print(f"[DtsPreprocessor] Temp file: " f"{str(tmp_input_file)[:70]}...")
        else:
            print(f"[DtsPreprocessor] Temp file: {tmp_input_file}")
        with open(tmp_input_file, "r") as f:
            print("[DtsPreprocessor] Temp file contents:")
            print(f.read())
    
        try:
            # Build cpp command as a list for shell=False
            cpp_cmd = [
                str(self.cpp_path),
                "-E",
            ]
            for path in self.include_paths:
                cpp_cmd.extend(["-I", str(path)])
            cpp_cmd.append(str(tmp_input_file))
    
            # Debug: print the constructed command list
            print("[DtsPreprocessor] cpp command:", cpp_cmd)
    
            # Run preprocessor with shell=False
            try:
                result = subprocess.run(
                    cpp_cmd,
                    capture_output=True,
                    text=True,
                    check=True,
                    shell=False,
                )
            except subprocess.CalledProcessError as e:
>               raise PreprocessorError(
                    "Failed to process DTS directives",
                    file=str(input_path),
                    context=str(e),
                    help_text=("Check for malformed DTS directives in " "input file"),
                )
E               converter.dts.preprocessor.PreprocessorError: Failed to process DTS directives

converter/dts/preprocessor.py:210: PreprocessorError
----------------------------- Captured stdout call -----------------------------
[DtsPreprocessor] ENVIRONMENT:
  MallocNanoZone=0
  USER=malpern
  SECURITYSESSIONID=186a3
  COMMAND_MODE=unix2003
  __CFBundleIdentifier=com.todesktop.230313mzl4w4u92
  PATH=/Users/malpern/.curs....cache/lm-studio/bin
  LOGNAME=malpern
  SSH_AUTH_SOCK=/private/tmp/com.app...x1qskoux7b/Listeners
  HOME=/Users/malpern
  SHELL=/bin/zsh
  TMPDIR=/var/folders/0s/42v7...1cdnx0vrvyr0000gn/T/
  LaunchInstanceID=BFD4BF06-15BD-4F76-8D8A-1AEC50E6795A
  __CF_USER_TEXT_ENCODING=0x1F5:0x0:0x0
  XPC_SERVICE_NAME=0
  XPC_FLAGS=0x0
  ORIGINAL_XDG_CURRENT_DESKTOP=undefined
  CURSOR_TRACE_ID=f5e099fd466543c5a0d391e03a641e89
  SHLVL=1
  PWD=/Volumes/FlashGordon...ox/code/nicktokatana
  OLDPWD=/Volumes/FlashGordon...ox/code/nicktokatana
  HOMEBREW_PREFIX=/opt/homebrew
  HOMEBREW_CELLAR=/opt/homebrew/Cellar
  HOMEBREW_REPOSITORY=/opt/homebrew
  INFOPATH=/opt/homebrew/share/...homebrew/share/info:
  YOUR_CONSUMER_KEY=ah6HAffNJRCv4xNrV4OZcVIrQ
  YOUR_CONSUMER_SECRET=EXM9IzH9IEdE2yJf0t5F...DPuFXLk55DwB8pLRswR5
  YOUR_ACCESS_TOKEN=1483-5UbadNrxZUkJpAp...JSXPVSxtsPwJyrUrZvcO
  YOUR_ACCESS_TOKEN_SECRET=jeyyEWPHAgoS0ebKus4t...0jH2T3gRCIz3dsYXQwqS
  YOUR_BEARER_TOKEN=AAAAAAAAAAAAAAAAAAAA...8YVAWCOQu6Pyu4yhuY0a
  OPENAI_API_KEY=sk-qVQDNdwpfPhrAvFr9...ob362AQbhWVa3p95yD28
  ANTHROPIC_API_KEY=sk-ant-api03-Tq7nYRm...SCuUoAfwIQg-NWFWuAAA
  TAVILY_API_KEY=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
  BING_SUBSCRIPTION_KEY=bec8ded0f34a421ba60cc3bd4626825e
  EDITOR=vi
  ZSH=/Users/malpern/.oh-my-zsh
  PAGER=head -n 10000 | cat
  LESS=-R
  LSCOLORS=Gxfxcxdxbxegedabagacad
  LS_COLORS=di=1;36:ln=35:so=32:...46:tw=30;42:ow=30;43
  PYENV_ROOT=/Users/malpern/.pyenv
  PYENV_SHELL=zsh
  DISABLE_AUTO_UPDATE=true
  TERM_PROGRAM=vscode
  TERM_PROGRAM_VERSION=0.50.1
  LANG=en_US.UTF-8
  COLORTERM=truecolor
  GIT_ASKPASS=/Applications/Cursor.../git/dist/askpass.sh
  VSCODE_GIT_ASKPASS_NODE=/Applications/Cursor...rsor Helper (Plugin)
  VSCODE_GIT_ASKPASS_EXTRA_ARGS=
  VSCODE_GIT_ASKPASS_MAIN=/Applications/Cursor...dist/askpass-main.js
  VSCODE_GIT_IPC_HANDLE=/var/folders/0s/42v7...-git-14a5ce3e7f.sock
  PYENV_VERSION=3.10.16
  PYENV_DIR=/
  VIRTUAL_ENV=/Volumes/Flash Gordo...e/nicktokatana/.venv
  PYENV_HOOK_PATH=/Users/malpern/.pyen.../usr/lib/pyenv/hooks
  VIRTUAL_ENV_PROMPT=.venv
  VSCODE_INJECTION=1
  ZDOTDIR=/Users/malpern
  USER_ZDOTDIR=/Users/malpern
  TERM=xterm-256color
  PS1=.venv%(?:%{[01;32m%...} $(git_prompt_info)
  PYTHONPATH=.
  _=/Users/malpern/.pyen...s/3.10.16/bin/pytest
  PYTEST_VERSION=8.3.4
  PYTEST_CURRENT_TEST=tests/dts/test_prepr...simple_keymap (call)
[DtsPreprocessor] Temp file: /var/folders/0s/42v7yl697hn0l1cdnx0vrvyr0000gn/T/tmpk0hyfblh.dts
[DtsPreprocessor] Temp file contents:
#include <dt-bindings/zmk/keys.h>
#include <dt-bindings/zmk/matrix_transform.h>

/ {
    chosen {
        zmk,matrix_transform = &default_transform;
    };

    default_transform: matrix_transform {
        compatible = "zmk,matrix-transform";
        rows = <2>;
        columns = <3>;
        map = <
            RC(0,0) RC(0,1) RC(0,2)
            RC(1,0) RC(1,1) RC(1,2)
        >;
    };

    keymap {
        compatible = "zmk,keymap";
        
        default_layer {
            bindings = <
                &kp A &kp B &kp C
                &kp D &kp E &kp F
            >;
        };
    };
}; 
[DtsPreprocessor] cpp command: ['/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/cpp', '-E', '-I', '/Volumes/FlashGordon/Dropbox/code/nicktokatana/tests/fixtures/dts/include', '/var/folders/0s/42v7yl697hn0l1cdnx0vrvyr0000gn/T/tmpk0hyfblh.dts']
______________________________ test_preprocessor _______________________________

self = <converter.dts.preprocessor.DtsPreprocessor object at 0x105a528f0>
input_path = PosixPath('/Volumes/FlashGordon/Dropbox/code/nicktokatana/tests/fixtures/dts/simple_keymap.zmk')
matrix_size = None

    def preprocess(
        self,
        input_path: str,
        matrix_size: Optional[Tuple[int, int]] = None,
    ) -> str:
        """Preprocess a DTS file.
    
        Args:
            input_path: Path to the input file
            matrix_size: Optional tuple of (rows, cols) for matrix transform
    
        Returns:
            The preprocessed content as a string
    
        Raises:
            PreprocessorError: If preprocessing fails
        """
        input_path = Path(input_path)
        if not input_path.exists():
            raise PreprocessorError(
                f"Input file does not exist: {input_path}",
                help_text=(
                    "Ensure the input file exists and has proper " "read permissions"
                ),
            )
    
        try:
            with open(input_path, "r") as f:
                content_for_cpp = f.read()
        except Exception as e:
            raise PreprocessorError(
                f"Failed to read input file: {str(e)}",
                file=str(input_path),
                help_text=("Ensure the file exists and has proper " "read permissions"),
            )
    
        # Create a temporary file for the preprocessor input
        tmp_input = tempfile.NamedTemporaryFile(
            mode="w",
            delete=False,
            suffix=".dts",
            dir=None,  # Use system default temp dir (usually /tmp)
        )
        tmp_input.write(content_for_cpp)
        tmp_input.close()
        tmp_input_file = Path(tmp_input.name)
    
        # Debug: print environment and temp file contents
        print("[DtsPreprocessor] ENVIRONMENT:")
        for k, v in os.environ.items():
            if len(v) > 40:
                print(f"  {k}={v[:20]}...{v[-20:]}")
            else:
                print(f"  {k}={v}")
        if len(str(tmp_input_file)) > 70:
            print(f"[DtsPreprocessor] Temp file: " f"{str(tmp_input_file)[:70]}...")
        else:
            print(f"[DtsPreprocessor] Temp file: {tmp_input_file}")
        with open(tmp_input_file, "r") as f:
            print("[DtsPreprocessor] Temp file contents:")
            print(f.read())
    
        try:
            # Build cpp command as a list for shell=False
            cpp_cmd = [
                str(self.cpp_path),
                "-E",
            ]
            for path in self.include_paths:
                cpp_cmd.extend(["-I", str(path)])
            cpp_cmd.append(str(tmp_input_file))
    
            # Debug: print the constructed command list
            print("[DtsPreprocessor] cpp command:", cpp_cmd)
    
            # Run preprocessor with shell=False
            try:
>               result = subprocess.run(
                    cpp_cmd,
                    capture_output=True,
                    text=True,
                    check=True,
                    shell=False,
                )

converter/dts/preprocessor.py:202: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = None, capture_output = True, timeout = None, check = True
popenargs = (['/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/cpp', '-E', '-I', '/Volumes/...ox/code/nicktokatana/tests/fixtures/dts/include', '/var/folders/0s/42v7yl697hn0l1cdnx0vrvyr0000gn/T/tmpll1u6m5w.dts'],)
kwargs = {'shell': False, 'stderr': -1, 'stdout': -1, 'text': True}
process = <Popen: returncode: 1 args: ['/Applications/Xcode.app/Contents/Developer/Too...>
stdout = ''
stderr = "cc: error: no such file or directory: 'c'\ncc: warning: /Volumes/FlashGordon/Dropbox/code/nicktokatana/tests/fixtures/dts/include: 'linker' input unused [-Wunused-command-line-argument]\n"
retcode = 1

    def run(*popenargs,
            input=None, capture_output=False, timeout=None, check=False, **kwargs):
        """Run command with arguments and return a CompletedProcess instance.
    
        The returned instance will have attributes args, returncode, stdout and
        stderr. By default, stdout and stderr are not captured, and those attributes
        will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them,
        or pass capture_output=True to capture both.
    
        If check is True and the exit code was non-zero, it raises a
        CalledProcessError. The CalledProcessError object will have the return code
        in the returncode attribute, and output & stderr attributes if those streams
        were captured.
    
        If timeout is given, and the process takes too long, a TimeoutExpired
        exception will be raised.
    
        There is an optional argument "input", allowing you to
        pass bytes or a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it will be used internally.
    
        By default, all communication is in bytes, and therefore any "input" should
        be bytes, and the stdout and stderr will be bytes. If in text mode, any
        "input" should be a string, and stdout and stderr will be strings decoded
        according to locale encoding, or by "encoding" if set. Text mode is
        triggered by setting any of text, encoding, errors or universal_newlines.
    
        The other arguments are the same as for the Popen constructor.
        """
        if input is not None:
            if kwargs.get('stdin') is not None:
                raise ValueError('stdin and input arguments may not both be used.')
            kwargs['stdin'] = PIPE
    
        if capture_output:
            if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:
                raise ValueError('stdout and stderr arguments may not be used '
                                 'with capture_output.')
            kwargs['stdout'] = PIPE
            kwargs['stderr'] = PIPE
    
        with Popen(*popenargs, **kwargs) as process:
            try:
                stdout, stderr = process.communicate(input, timeout=timeout)
            except TimeoutExpired as exc:
                process.kill()
                if _mswindows:
                    # Windows accumulates the output in a single blocking
                    # read() call run on child threads, with the timeout
                    # being done in a join() on those threads.  communicate()
                    # _after_ kill() is required to collect that and add it
                    # to the exception.
                    exc.stdout, exc.stderr = process.communicate()
                else:
                    # POSIX _communicate already populated the output so
                    # far into the TimeoutExpired exception.
                    process.wait()
                raise
            except:  # Including KeyboardInterrupt, communicate handled that.
                process.kill()
                # We don't call process.wait() as .__exit__ does that for us.
                raise
            retcode = process.poll()
            if check and retcode:
>               raise CalledProcessError(retcode, process.args,
                                         output=stdout, stderr=stderr)
E               subprocess.CalledProcessError: Command '['/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/cpp', '-E', '-I', '/Volumes/FlashGordon/Dropbox/code/nicktokatana/tests/fixtures/dts/include', '/var/folders/0s/42v7yl697hn0l1cdnx0vrvyr0000gn/T/tmpll1u6m5w.dts']' returned non-zero exit status 1.

/Users/malpern/.pyenv/versions/3.10.16/lib/python3.10/subprocess.py:526: CalledProcessError

During handling of the above exception, another exception occurred:

    def test_preprocessor():
        # Get the absolute path to the test fixtures directory
        fixtures_dir = os.path.join(os.path.dirname(__file__), "fixtures", "dts")
        include_path = os.path.join(fixtures_dir, "include")
    
        # Create preprocessor with include path
        preprocessor = DtsPreprocessor(include_paths=[include_path])
    
        # Preprocess the test file
        input_file = os.path.join(fixtures_dir, "simple_keymap.zmk")
>       result = preprocessor.preprocess(input_file)

tests/test_dts_preprocessor.py:18: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <converter.dts.preprocessor.DtsPreprocessor object at 0x105a528f0>
input_path = PosixPath('/Volumes/FlashGordon/Dropbox/code/nicktokatana/tests/fixtures/dts/simple_keymap.zmk')
matrix_size = None

    def preprocess(
        self,
        input_path: str,
        matrix_size: Optional[Tuple[int, int]] = None,
    ) -> str:
        """Preprocess a DTS file.
    
        Args:
            input_path: Path to the input file
            matrix_size: Optional tuple of (rows, cols) for matrix transform
    
        Returns:
            The preprocessed content as a string
    
        Raises:
            PreprocessorError: If preprocessing fails
        """
        input_path = Path(input_path)
        if not input_path.exists():
            raise PreprocessorError(
                f"Input file does not exist: {input_path}",
                help_text=(
                    "Ensure the input file exists and has proper " "read permissions"
                ),
            )
    
        try:
            with open(input_path, "r") as f:
                content_for_cpp = f.read()
        except Exception as e:
            raise PreprocessorError(
                f"Failed to read input file: {str(e)}",
                file=str(input_path),
                help_text=("Ensure the file exists and has proper " "read permissions"),
            )
    
        # Create a temporary file for the preprocessor input
        tmp_input = tempfile.NamedTemporaryFile(
            mode="w",
            delete=False,
            suffix=".dts",
            dir=None,  # Use system default temp dir (usually /tmp)
        )
        tmp_input.write(content_for_cpp)
        tmp_input.close()
        tmp_input_file = Path(tmp_input.name)
    
        # Debug: print environment and temp file contents
        print("[DtsPreprocessor] ENVIRONMENT:")
        for k, v in os.environ.items():
            if len(v) > 40:
                print(f"  {k}={v[:20]}...{v[-20:]}")
            else:
                print(f"  {k}={v}")
        if len(str(tmp_input_file)) > 70:
            print(f"[DtsPreprocessor] Temp file: " f"{str(tmp_input_file)[:70]}...")
        else:
            print(f"[DtsPreprocessor] Temp file: {tmp_input_file}")
        with open(tmp_input_file, "r") as f:
            print("[DtsPreprocessor] Temp file contents:")
            print(f.read())
    
        try:
            # Build cpp command as a list for shell=False
            cpp_cmd = [
                str(self.cpp_path),
                "-E",
            ]
            for path in self.include_paths:
                cpp_cmd.extend(["-I", str(path)])
            cpp_cmd.append(str(tmp_input_file))
    
            # Debug: print the constructed command list
            print("[DtsPreprocessor] cpp command:", cpp_cmd)
    
            # Run preprocessor with shell=False
            try:
                result = subprocess.run(
                    cpp_cmd,
                    capture_output=True,
                    text=True,
                    check=True,
                    shell=False,
                )
            except subprocess.CalledProcessError as e:
>               raise PreprocessorError(
                    "Failed to process DTS directives",
                    file=str(input_path),
                    context=str(e),
                    help_text=("Check for malformed DTS directives in " "input file"),
                )
E               converter.dts.preprocessor.PreprocessorError: Failed to process DTS directives

converter/dts/preprocessor.py:210: PreprocessorError
----------------------------- Captured stdout call -----------------------------
[DtsPreprocessor] ENVIRONMENT:
  MallocNanoZone=0
  USER=malpern
  SECURITYSESSIONID=186a3
  COMMAND_MODE=unix2003
  __CFBundleIdentifier=com.todesktop.230313mzl4w4u92
  PATH=/Users/malpern/.curs....cache/lm-studio/bin
  LOGNAME=malpern
  SSH_AUTH_SOCK=/private/tmp/com.app...x1qskoux7b/Listeners
  HOME=/Users/malpern
  SHELL=/bin/zsh
  TMPDIR=/var/folders/0s/42v7...1cdnx0vrvyr0000gn/T/
  LaunchInstanceID=BFD4BF06-15BD-4F76-8D8A-1AEC50E6795A
  __CF_USER_TEXT_ENCODING=0x1F5:0x0:0x0
  XPC_SERVICE_NAME=0
  XPC_FLAGS=0x0
  ORIGINAL_XDG_CURRENT_DESKTOP=undefined
  CURSOR_TRACE_ID=f5e099fd466543c5a0d391e03a641e89
  SHLVL=1
  PWD=/Volumes/FlashGordon...ox/code/nicktokatana
  OLDPWD=/Volumes/FlashGordon...ox/code/nicktokatana
  HOMEBREW_PREFIX=/opt/homebrew
  HOMEBREW_CELLAR=/opt/homebrew/Cellar
  HOMEBREW_REPOSITORY=/opt/homebrew
  INFOPATH=/opt/homebrew/share/...homebrew/share/info:
  YOUR_CONSUMER_KEY=ah6HAffNJRCv4xNrV4OZcVIrQ
  YOUR_CONSUMER_SECRET=EXM9IzH9IEdE2yJf0t5F...DPuFXLk55DwB8pLRswR5
  YOUR_ACCESS_TOKEN=1483-5UbadNrxZUkJpAp...JSXPVSxtsPwJyrUrZvcO
  YOUR_ACCESS_TOKEN_SECRET=jeyyEWPHAgoS0ebKus4t...0jH2T3gRCIz3dsYXQwqS
  YOUR_BEARER_TOKEN=AAAAAAAAAAAAAAAAAAAA...8YVAWCOQu6Pyu4yhuY0a
  OPENAI_API_KEY=sk-qVQDNdwpfPhrAvFr9...ob362AQbhWVa3p95yD28
  ANTHROPIC_API_KEY=sk-ant-api03-Tq7nYRm...SCuUoAfwIQg-NWFWuAAA
  TAVILY_API_KEY=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
  BING_SUBSCRIPTION_KEY=bec8ded0f34a421ba60cc3bd4626825e
  EDITOR=vi
  ZSH=/Users/malpern/.oh-my-zsh
  PAGER=head -n 10000 | cat
  LESS=-R
  LSCOLORS=Gxfxcxdxbxegedabagacad
  LS_COLORS=di=1;36:ln=35:so=32:...46:tw=30;42:ow=30;43
  PYENV_ROOT=/Users/malpern/.pyenv
  PYENV_SHELL=zsh
  DISABLE_AUTO_UPDATE=true
  TERM_PROGRAM=vscode
  TERM_PROGRAM_VERSION=0.50.1
  LANG=en_US.UTF-8
  COLORTERM=truecolor
  GIT_ASKPASS=/Applications/Cursor.../git/dist/askpass.sh
  VSCODE_GIT_ASKPASS_NODE=/Applications/Cursor...rsor Helper (Plugin)
  VSCODE_GIT_ASKPASS_EXTRA_ARGS=
  VSCODE_GIT_ASKPASS_MAIN=/Applications/Cursor...dist/askpass-main.js
  VSCODE_GIT_IPC_HANDLE=/var/folders/0s/42v7...-git-14a5ce3e7f.sock
  PYENV_VERSION=3.10.16
  PYENV_DIR=/
  VIRTUAL_ENV=/Volumes/Flash Gordo...e/nicktokatana/.venv
  PYENV_HOOK_PATH=/Users/malpern/.pyen.../usr/lib/pyenv/hooks
  VIRTUAL_ENV_PROMPT=.venv
  VSCODE_INJECTION=1
  ZDOTDIR=/Users/malpern
  USER_ZDOTDIR=/Users/malpern
  TERM=xterm-256color
  PS1=.venv%(?:%{[01;32m%...} $(git_prompt_info)
  PYTHONPATH=.
  _=/Users/malpern/.pyen...s/3.10.16/bin/pytest
  PYTEST_VERSION=8.3.4
  PYTEST_CURRENT_TEST=tests/test_dts_prepr..._preprocessor (call)
[DtsPreprocessor] Temp file: /var/folders/0s/42v7yl697hn0l1cdnx0vrvyr0000gn/T/tmpll1u6m5w.dts
[DtsPreprocessor] Temp file contents:
#include <dt-bindings/zmk/keys.h>
#include <dt-bindings/zmk/matrix_transform.h>

/ {
    chosen {
        zmk,matrix_transform = &default_transform;
    };

    default_transform: matrix_transform {
        compatible = "zmk,matrix-transform";
        rows = <2>;
        columns = <3>;
        map = <
            RC(0,0) RC(0,1) RC(0,2)
            RC(1,0) RC(1,1) RC(1,2)
        >;
    };

    keymap {
        compatible = "zmk,keymap";
        
        default_layer {
            bindings = <
                &kp A &kp B &kp C
                &kp D &kp E &kp F
            >;
        };
    };
}; 
[DtsPreprocessor] cpp command: ['/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/cpp', '-E', '-I', '/Volumes/FlashGordon/Dropbox/code/nicktokatana/tests/fixtures/dts/include', '/var/folders/0s/42v7yl697hn0l1cdnx0vrvyr0000gn/T/tmpll1u6m5w.dts']
________________________ test_preprocessor_large_matrix ________________________

self = <converter.dts.preprocessor.DtsPreprocessor object at 0x1059c7e80>
input_path = PosixPath('/Volumes/FlashGordon/Dropbox/code/nicktokatana/tests/fixtures/dts/large_keymap.zmk')
matrix_size = None

    def preprocess(
        self,
        input_path: str,
        matrix_size: Optional[Tuple[int, int]] = None,
    ) -> str:
        """Preprocess a DTS file.
    
        Args:
            input_path: Path to the input file
            matrix_size: Optional tuple of (rows, cols) for matrix transform
    
        Returns:
            The preprocessed content as a string
    
        Raises:
            PreprocessorError: If preprocessing fails
        """
        input_path = Path(input_path)
        if not input_path.exists():
            raise PreprocessorError(
                f"Input file does not exist: {input_path}",
                help_text=(
                    "Ensure the input file exists and has proper " "read permissions"
                ),
            )
    
        try:
            with open(input_path, "r") as f:
                content_for_cpp = f.read()
        except Exception as e:
            raise PreprocessorError(
                f"Failed to read input file: {str(e)}",
                file=str(input_path),
                help_text=("Ensure the file exists and has proper " "read permissions"),
            )
    
        # Create a temporary file for the preprocessor input
        tmp_input = tempfile.NamedTemporaryFile(
            mode="w",
            delete=False,
            suffix=".dts",
            dir=None,  # Use system default temp dir (usually /tmp)
        )
        tmp_input.write(content_for_cpp)
        tmp_input.close()
        tmp_input_file = Path(tmp_input.name)
    
        # Debug: print environment and temp file contents
        print("[DtsPreprocessor] ENVIRONMENT:")
        for k, v in os.environ.items():
            if len(v) > 40:
                print(f"  {k}={v[:20]}...{v[-20:]}")
            else:
                print(f"  {k}={v}")
        if len(str(tmp_input_file)) > 70:
            print(f"[DtsPreprocessor] Temp file: " f"{str(tmp_input_file)[:70]}...")
        else:
            print(f"[DtsPreprocessor] Temp file: {tmp_input_file}")
        with open(tmp_input_file, "r") as f:
            print("[DtsPreprocessor] Temp file contents:")
            print(f.read())
    
        try:
            # Build cpp command as a list for shell=False
            cpp_cmd = [
                str(self.cpp_path),
                "-E",
            ]
            for path in self.include_paths:
                cpp_cmd.extend(["-I", str(path)])
            cpp_cmd.append(str(tmp_input_file))
    
            # Debug: print the constructed command list
            print("[DtsPreprocessor] cpp command:", cpp_cmd)
    
            # Run preprocessor with shell=False
            try:
>               result = subprocess.run(
                    cpp_cmd,
                    capture_output=True,
                    text=True,
                    check=True,
                    shell=False,
                )

converter/dts/preprocessor.py:202: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = None, capture_output = True, timeout = None, check = True
popenargs = (['/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/cpp', '-E', '-I', '/Volumes/...ox/code/nicktokatana/tests/fixtures/dts/include', '/var/folders/0s/42v7yl697hn0l1cdnx0vrvyr0000gn/T/tmp0z4ax127.dts'],)
kwargs = {'shell': False, 'stderr': -1, 'stdout': -1, 'text': True}
process = <Popen: returncode: 1 args: ['/Applications/Xcode.app/Contents/Developer/Too...>
stdout = ''
stderr = "cc: error: no such file or directory: 'c'\ncc: warning: /Volumes/FlashGordon/Dropbox/code/nicktokatana/tests/fixtures/dts/include: 'linker' input unused [-Wunused-command-line-argument]\n"
retcode = 1

    def run(*popenargs,
            input=None, capture_output=False, timeout=None, check=False, **kwargs):
        """Run command with arguments and return a CompletedProcess instance.
    
        The returned instance will have attributes args, returncode, stdout and
        stderr. By default, stdout and stderr are not captured, and those attributes
        will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them,
        or pass capture_output=True to capture both.
    
        If check is True and the exit code was non-zero, it raises a
        CalledProcessError. The CalledProcessError object will have the return code
        in the returncode attribute, and output & stderr attributes if those streams
        were captured.
    
        If timeout is given, and the process takes too long, a TimeoutExpired
        exception will be raised.
    
        There is an optional argument "input", allowing you to
        pass bytes or a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it will be used internally.
    
        By default, all communication is in bytes, and therefore any "input" should
        be bytes, and the stdout and stderr will be bytes. If in text mode, any
        "input" should be a string, and stdout and stderr will be strings decoded
        according to locale encoding, or by "encoding" if set. Text mode is
        triggered by setting any of text, encoding, errors or universal_newlines.
    
        The other arguments are the same as for the Popen constructor.
        """
        if input is not None:
            if kwargs.get('stdin') is not None:
                raise ValueError('stdin and input arguments may not both be used.')
            kwargs['stdin'] = PIPE
    
        if capture_output:
            if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:
                raise ValueError('stdout and stderr arguments may not be used '
                                 'with capture_output.')
            kwargs['stdout'] = PIPE
            kwargs['stderr'] = PIPE
    
        with Popen(*popenargs, **kwargs) as process:
            try:
                stdout, stderr = process.communicate(input, timeout=timeout)
            except TimeoutExpired as exc:
                process.kill()
                if _mswindows:
                    # Windows accumulates the output in a single blocking
                    # read() call run on child threads, with the timeout
                    # being done in a join() on those threads.  communicate()
                    # _after_ kill() is required to collect that and add it
                    # to the exception.
                    exc.stdout, exc.stderr = process.communicate()
                else:
                    # POSIX _communicate already populated the output so
                    # far into the TimeoutExpired exception.
                    process.wait()
                raise
            except:  # Including KeyboardInterrupt, communicate handled that.
                process.kill()
                # We don't call process.wait() as .__exit__ does that for us.
                raise
            retcode = process.poll()
            if check and retcode:
>               raise CalledProcessError(retcode, process.args,
                                         output=stdout, stderr=stderr)
E               subprocess.CalledProcessError: Command '['/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/cpp', '-E', '-I', '/Volumes/FlashGordon/Dropbox/code/nicktokatana/tests/fixtures/dts/include', '/var/folders/0s/42v7yl697hn0l1cdnx0vrvyr0000gn/T/tmp0z4ax127.dts']' returned non-zero exit status 1.

/Users/malpern/.pyenv/versions/3.10.16/lib/python3.10/subprocess.py:526: CalledProcessError

During handling of the above exception, another exception occurred:

    def test_preprocessor_large_matrix():
        # Get the absolute path to the test fixtures directory
        fixtures_dir = os.path.join(os.path.dirname(__file__), "fixtures", "dts")
        include_path = os.path.join(fixtures_dir, "include")
    
        # Create preprocessor with include path
        preprocessor = DtsPreprocessor(include_paths=[include_path])
    
        # Preprocess the test file
        input_file = os.path.join(fixtures_dir, "large_keymap.zmk")
>       result = preprocessor.preprocess(input_file)

tests/test_dts_preprocessor.py:45: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <converter.dts.preprocessor.DtsPreprocessor object at 0x1059c7e80>
input_path = PosixPath('/Volumes/FlashGordon/Dropbox/code/nicktokatana/tests/fixtures/dts/large_keymap.zmk')
matrix_size = None

    def preprocess(
        self,
        input_path: str,
        matrix_size: Optional[Tuple[int, int]] = None,
    ) -> str:
        """Preprocess a DTS file.
    
        Args:
            input_path: Path to the input file
            matrix_size: Optional tuple of (rows, cols) for matrix transform
    
        Returns:
            The preprocessed content as a string
    
        Raises:
            PreprocessorError: If preprocessing fails
        """
        input_path = Path(input_path)
        if not input_path.exists():
            raise PreprocessorError(
                f"Input file does not exist: {input_path}",
                help_text=(
                    "Ensure the input file exists and has proper " "read permissions"
                ),
            )
    
        try:
            with open(input_path, "r") as f:
                content_for_cpp = f.read()
        except Exception as e:
            raise PreprocessorError(
                f"Failed to read input file: {str(e)}",
                file=str(input_path),
                help_text=("Ensure the file exists and has proper " "read permissions"),
            )
    
        # Create a temporary file for the preprocessor input
        tmp_input = tempfile.NamedTemporaryFile(
            mode="w",
            delete=False,
            suffix=".dts",
            dir=None,  # Use system default temp dir (usually /tmp)
        )
        tmp_input.write(content_for_cpp)
        tmp_input.close()
        tmp_input_file = Path(tmp_input.name)
    
        # Debug: print environment and temp file contents
        print("[DtsPreprocessor] ENVIRONMENT:")
        for k, v in os.environ.items():
            if len(v) > 40:
                print(f"  {k}={v[:20]}...{v[-20:]}")
            else:
                print(f"  {k}={v}")
        if len(str(tmp_input_file)) > 70:
            print(f"[DtsPreprocessor] Temp file: " f"{str(tmp_input_file)[:70]}...")
        else:
            print(f"[DtsPreprocessor] Temp file: {tmp_input_file}")
        with open(tmp_input_file, "r") as f:
            print("[DtsPreprocessor] Temp file contents:")
            print(f.read())
    
        try:
            # Build cpp command as a list for shell=False
            cpp_cmd = [
                str(self.cpp_path),
                "-E",
            ]
            for path in self.include_paths:
                cpp_cmd.extend(["-I", str(path)])
            cpp_cmd.append(str(tmp_input_file))
    
            # Debug: print the constructed command list
            print("[DtsPreprocessor] cpp command:", cpp_cmd)
    
            # Run preprocessor with shell=False
            try:
                result = subprocess.run(
                    cpp_cmd,
                    capture_output=True,
                    text=True,
                    check=True,
                    shell=False,
                )
            except subprocess.CalledProcessError as e:
>               raise PreprocessorError(
                    "Failed to process DTS directives",
                    file=str(input_path),
                    context=str(e),
                    help_text=("Check for malformed DTS directives in " "input file"),
                )
E               converter.dts.preprocessor.PreprocessorError: Failed to process DTS directives

converter/dts/preprocessor.py:210: PreprocessorError
----------------------------- Captured stdout call -----------------------------
[DtsPreprocessor] ENVIRONMENT:
  MallocNanoZone=0
  USER=malpern
  SECURITYSESSIONID=186a3
  COMMAND_MODE=unix2003
  __CFBundleIdentifier=com.todesktop.230313mzl4w4u92
  PATH=/Users/malpern/.curs....cache/lm-studio/bin
  LOGNAME=malpern
  SSH_AUTH_SOCK=/private/tmp/com.app...x1qskoux7b/Listeners
  HOME=/Users/malpern
  SHELL=/bin/zsh
  TMPDIR=/var/folders/0s/42v7...1cdnx0vrvyr0000gn/T/
  LaunchInstanceID=BFD4BF06-15BD-4F76-8D8A-1AEC50E6795A
  __CF_USER_TEXT_ENCODING=0x1F5:0x0:0x0
  XPC_SERVICE_NAME=0
  XPC_FLAGS=0x0
  ORIGINAL_XDG_CURRENT_DESKTOP=undefined
  CURSOR_TRACE_ID=f5e099fd466543c5a0d391e03a641e89
  SHLVL=1
  PWD=/Volumes/FlashGordon...ox/code/nicktokatana
  OLDPWD=/Volumes/FlashGordon...ox/code/nicktokatana
  HOMEBREW_PREFIX=/opt/homebrew
  HOMEBREW_CELLAR=/opt/homebrew/Cellar
  HOMEBREW_REPOSITORY=/opt/homebrew
  INFOPATH=/opt/homebrew/share/...homebrew/share/info:
  YOUR_CONSUMER_KEY=ah6HAffNJRCv4xNrV4OZcVIrQ
  YOUR_CONSUMER_SECRET=EXM9IzH9IEdE2yJf0t5F...DPuFXLk55DwB8pLRswR5
  YOUR_ACCESS_TOKEN=1483-5UbadNrxZUkJpAp...JSXPVSxtsPwJyrUrZvcO
  YOUR_ACCESS_TOKEN_SECRET=jeyyEWPHAgoS0ebKus4t...0jH2T3gRCIz3dsYXQwqS
  YOUR_BEARER_TOKEN=AAAAAAAAAAAAAAAAAAAA...8YVAWCOQu6Pyu4yhuY0a
  OPENAI_API_KEY=sk-qVQDNdwpfPhrAvFr9...ob362AQbhWVa3p95yD28
  ANTHROPIC_API_KEY=sk-ant-api03-Tq7nYRm...SCuUoAfwIQg-NWFWuAAA
  TAVILY_API_KEY=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
  BING_SUBSCRIPTION_KEY=bec8ded0f34a421ba60cc3bd4626825e
  EDITOR=vi
  ZSH=/Users/malpern/.oh-my-zsh
  PAGER=head -n 10000 | cat
  LESS=-R
  LSCOLORS=Gxfxcxdxbxegedabagacad
  LS_COLORS=di=1;36:ln=35:so=32:...46:tw=30;42:ow=30;43
  PYENV_ROOT=/Users/malpern/.pyenv
  PYENV_SHELL=zsh
  DISABLE_AUTO_UPDATE=true
  TERM_PROGRAM=vscode
  TERM_PROGRAM_VERSION=0.50.1
  LANG=en_US.UTF-8
  COLORTERM=truecolor
  GIT_ASKPASS=/Applications/Cursor.../git/dist/askpass.sh
  VSCODE_GIT_ASKPASS_NODE=/Applications/Cursor...rsor Helper (Plugin)
  VSCODE_GIT_ASKPASS_EXTRA_ARGS=
  VSCODE_GIT_ASKPASS_MAIN=/Applications/Cursor...dist/askpass-main.js
  VSCODE_GIT_IPC_HANDLE=/var/folders/0s/42v7...-git-14a5ce3e7f.sock
  PYENV_VERSION=3.10.16
  PYENV_DIR=/
  VIRTUAL_ENV=/Volumes/Flash Gordo...e/nicktokatana/.venv
  PYENV_HOOK_PATH=/Users/malpern/.pyen.../usr/lib/pyenv/hooks
  VIRTUAL_ENV_PROMPT=.venv
  VSCODE_INJECTION=1
  ZDOTDIR=/Users/malpern
  USER_ZDOTDIR=/Users/malpern
  TERM=xterm-256color
  PS1=.venv%(?:%{[01;32m%...} $(git_prompt_info)
  PYTHONPATH=.
  _=/Users/malpern/.pyen...s/3.10.16/bin/pytest
  PYTEST_VERSION=8.3.4
  PYTEST_CURRENT_TEST=tests/test_dts_prepr..._large_matrix (call)
[DtsPreprocessor] Temp file: /var/folders/0s/42v7yl697hn0l1cdnx0vrvyr0000gn/T/tmp0z4ax127.dts
[DtsPreprocessor] Temp file contents:
#include <dt-bindings/zmk/keys.h>
#include <dt-bindings/zmk/matrix_transform.h>

/ {
    chosen {
        zmk,matrix_transform = &default_transform;
    };

    default_transform: matrix_transform {
        compatible = "zmk,matrix-transform";
        rows = <4>;
        columns = <5>;
        map = <
            RC(0,0) RC(0,1) RC(0,2) RC(0,3) RC(0,4)
            RC(1,0) RC(1,1) RC(1,2) RC(1,3) RC(1,4)
            RC(2,0) RC(2,1) RC(2,2) RC(2,3) RC(2,4)
            RC(3,0) RC(3,1) RC(3,2) RC(3,3) RC(3,4)
        >;
    };

    keymap {
        compatible = "zmk,keymap";
        
        default_layer {
            bindings = <
                &kp A &kp B &kp C &kp D &kp E
                &kp F &kp G &kp H &kp I &kp J
                &kp K &kp L &kp M &kp N &kp O
                &kp P &kp Q &kp R &kp S &kp T
            >;
        };
    };
}; 
[DtsPreprocessor] cpp command: ['/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/cpp', '-E', '-I', '/Volumes/FlashGordon/Dropbox/code/nicktokatana/tests/fixtures/dts/include', '/var/folders/0s/42v7yl697hn0l1cdnx0vrvyr0000gn/T/tmp0z4ax127.dts']
_______________________ test_preprocessor_error_handling _______________________

    def test_preprocessor_error_handling():
        # Test with non-existent file
>       preprocessor = DtsPreprocessor(include_paths=["/nonexistent/path"])

tests/test_dts_preprocessor.py:60: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <converter.dts.preprocessor.DtsPreprocessor object at 0x105a4d1b0>
cpp_path = '/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/cpp'
include_paths = ['/nonexistent/path']

    def __init__(
        self,
        cpp_path: Optional[str] = None,
        include_paths: Optional[List[str]] = None,
    ):
        """Initialize the preprocessor.
    
        Args:
            cpp_path: Path to the C preprocessor executable
            include_paths: List of paths to search for include files
        """
        if cpp_path is None:
            cpp_path = (
                "/Applications/Xcode.app/Contents/Developer/Toolchains/"
                "XcodeDefault.xctoolchain/usr/bin/cpp"
            )
        cpp_path = str(cpp_path)
        if not cpp_path.endswith("cpp"):
            raise PreprocessorError(
                "Invalid cpp path",
                help_text="The cpp path must point to a cpp executable",
            )
        self.cpp_path = Path(cpp_path)
    
        self.include_paths = []
        if include_paths:
            for path in include_paths:
                path_obj = Path(path)
                if not path_obj.exists():
                    msg = f"Include path does not exist: {path}"
                    help_text = "Ensure all include paths exist and are " "accessible"
>                   raise PreprocessorError(msg, help_text=help_text)
E                   converter.dts.preprocessor.PreprocessorError: Include path does not exist: /nonexistent/path

converter/dts/preprocessor.py:80: PreprocessorError
=========================== short test summary info ============================
FAILED tests/dts/test_performance.py::test_preprocessor_performance - convert...
FAILED tests/dts/test_preprocessor.py::test_preprocessor_initialization - Att...
FAILED tests/dts/test_preprocessor.py::test_preprocess_simple_file - converte...
FAILED tests/dts/test_preprocessor.py::test_preprocess_with_includes - conver...
FAILED tests/dts/test_preprocessor.py::test_preprocess_invalid_file - convert...
FAILED tests/dts/test_preprocessor.py::test_preprocess_invalid_cpp_command - ...
FAILED tests/dts/test_preprocessor.py::test_preprocess_simple_keymap - conver...
FAILED tests/test_dts_preprocessor.py::test_preprocessor - converter.dts.prep...
FAILED tests/test_dts_preprocessor.py::test_preprocessor_large_matrix - conve...
FAILED tests/test_dts_preprocessor.py::test_preprocessor_error_handling - con...
================= 10 failed, 5 passed, 57 deselected in 0.28s ==================
