============================= test session starts ==============================
platform darwin -- Python 3.10.16, pytest-8.3.4, pluggy-1.5.0 -- /Users/malpern/.pyenv/versions/3.10.16/bin/python3.10
cachedir: .pytest_cache
rootdir: /Volumes/FlashGordon/Dropbox/code/nicktokatana
configfile: pyproject.toml
plugins: anyio-4.7.0
collecting ... collected 5 items

tests/dts/test_extractor.py::test_extract_simple_keymap PASSED           [ 20%]
tests/dts/test_extractor.py::test_extract_with_behaviors PASSED          [ 40%]
tests/dts/test_extractor.py::test_extract_multiple_layers PASSED         [ 60%]
tests/dts/test_extractor.py::test_extract_complex_bindings PASSED        [ 80%]
tests/dts/test_extractor.py::test_extract_invalid_content FAILED         [100%]

=================================== FAILURES ===================================
_________________________ test_extract_invalid_content _________________________

    def test_extract_invalid_content():
        """Test extracting invalid content."""
        content = """
        / {
            keymap {
                invalid_layer {
                    # Missing bindings
                };
            };
        };
        """
    
        parser = DtsParser()
>       ast = parser.parse(content)

tests/dts/test_extractor.py:166: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
converter/dts/parser.py:76: in parse
    self._parse_node_body(parsed_root_node)
converter/dts/parser.py:545: in _parse_node_body
    self._parse_node_body(child)
converter/dts/parser.py:545: in _parse_node_body
    self._parse_node_body(child)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <converter.dts.parser.DtsParser object at 0x101e2dff0>
node = DtsNode(name='invalid_layer', parent=None, children={}, properties={}, labels={})

    def _parse_node_body(self, node: DtsNode) -> None:
        """Parse the body of a DTS node.
    
        Args:
            node: DtsNode to parse body into
    
        Raises:
            DtsParseError: If node body format is invalid
        """
        while self.pos < len(self.tokens):
            token = self.tokens[self.pos]
    
            if token == "}":
                self.pos += 1
                return
            elif token == "{":
                line, col = self._get_pos_info(self.pos)
                raise DtsParseError(
                    "Unexpected '{' in node body",
                    line=line,
                    column=col,
                    context=format_error_context(self.content, line, col),
                    help_text="Node definitions must have a label or reference",
                )
    
            if token == ";":  # Handle empty statements
                self.pos += 1
                continue
    
            # Handle boolean properties (e.g., "prop_name;")
            if self.pos + 1 < len(self.tokens) and self.tokens[self.pos + 1] == ";":
                name = token
                # Basic check for valid property name (alphanumeric, _, -)
                # This helps distinguish from stray semicolons or other constructs.
                # The tokenizer should ideally guarantee 'token' is a potential identifier here.
                if (
                    name
                    and all(c.isalnum() or c in ("_", "-", "#") for c in name)
                    and (name[0].isalpha() or name[0] == "#" or name[0] == "_")
                ):
                    prop = DtsProperty(name=name, value=True, type="boolean")
                    node.add_property(prop)
                    self.pos += 2  # Consume name and ';'
                    continue
    
            # Handle properties with assignment (e.g. "prop_name = value;")
            if self.pos + 2 < len(self.tokens) and self.tokens[self.pos + 1] == "=":
                name = token
                value_token = self.tokens[self.pos + 2]
                try:
                    prop = self._parse_property_value(name, value_token)
                    node.add_property(prop)
                    self.pos += 3
    
                    # Check for additional comma-separated array cells
                    if prop.type == "array":
                        while (
                            self.pos < len(self.tokens) and self.tokens[self.pos] == ","
                        ):
                            self.pos += 1
                            if self.pos >= len(self.tokens):
                                line, col = self._get_pos_info(self.pos - 1)
                                raise DtsParseError(
                                    "Unexpected end of file after ',' in property value",
                                    line=line,
                                    column=col,
                                    context=format_error_context(
                                        self.content, line, col
                                    ),
                                )
                            next_value_token = self.tokens[self.pos]
                            # Parse the next array cell. We expect it to be an array itself.
                            # _parse_property_value will return a DtsProperty, we need its value.
                            additional_prop_part = self._parse_property_value(
                                "_{temp}", next_value_token
                            )
                            if additional_prop_part.type == "array":
                                if isinstance(prop.value, list) and isinstance(
                                    additional_prop_part.value, list
                                ):
                                    prop.value.extend(additional_prop_part.value)
                                else:
                                    # This case should ideally not happen if tokens are well-formed <...>
                                    line, col = self._get_pos_info(self.pos)
                                    raise DtsParseError(
                                        f"Expected array type for subsequent part of property '{name}'",
                                        line=line,
                                        column=col,
                                        context=format_error_context(
                                            self.content, line, col
                                        ),
                                    )
                            else:
                                line, col = self._get_pos_info(self.pos)
                                raise DtsParseError(
                                    f"Expected array for subsequent part of property '{name}', got {additional_prop_part.type}",
                                    line=line,
                                    column=col,
                                    context=format_error_context(
                                        self.content, line, col
                                    ),
                                )
                            self.pos += 1
                except DtsParseError as e:
                    if not e.help_text:
                        e.help_text = f"Invalid value for property '{name}'"
                    raise
                if self.pos >= len(self.tokens) or self.tokens[self.pos] != ";":
                    line, col = self._get_pos_info(self.pos)
                    raise DtsParseError(
                        "Expected ';' after property value",
                        line=line,
                        column=col,
                        context=format_error_context(self.content, line, col),
                        help_text="Property definitions must end with a semicolon",
                    )
                self.pos += 1
                continue
    
            # Handle child nodes. At this point, 'token' is either a node name or a label.
            current_labels_for_node: List[str] = []
            current_token = token  # Start with the first token we haven't processed as property/etc.
    
            # Loop to gather all labels: label1: label2: ... node_name
            while self.pos + 1 < len(self.tokens) and self.tokens[self.pos + 1] == ":":
                # Current token is a label
                current_labels_for_node.append(current_token)
                self.pos += 2  # Consume label and ':'
                if self.pos >= len(self.tokens):
                    line, col = self._get_pos_info(self.pos - 1)
                    raise DtsParseError(
                        "Unexpected end of file after label expecting node name or another label",
                        line=line,
                        column=col,
                        context=format_error_context(self.content, line, col),
                    )
                current_token = self.tokens[
                    self.pos
                ]  # This is the next potential label or the actual node name
    
            # After the loop, current_token is the actual node name
            actual_node_name = current_token
            self.pos += 1  # Consume the actual_node_name token
    
            child = DtsNode(name=actual_node_name)
            for lbl in current_labels_for_node:
                child.add_label(lbl)
    
            if self.pos >= len(self.tokens) or self.tokens[self.pos] != "{":
                line, col = self._get_pos_info(self.pos)
                # Provide more context in error: what token did we actually find?
                found_token_msg = (
                    f"Found '{self.tokens[self.pos]}' instead."
                    if self.pos < len(self.tokens)
                    else "Found end of input."
                )
>               raise DtsParseError(
                    f"Expected '{{ ' after node '{actual_node_name}'. {found_token_msg}",
                    line=line,
                    column=col,
                    context=format_error_context(self.content, line, col),
                    help_text="Node definitions must be enclosed in curly braces and start with '{'.",
                )
E               converter.dts.error_handler.DtsParseError: Expected '{ ' after node '#'. Found 'Missing' instead. at line 6, column -34
E               
E               4 |             invalid_layer {
E               5 |                 # Missing bindings
E               6 |             };
E                 | ^
E               7 |         };
E               8 |     };
E               
E               Help: Node definitions must be enclosed in curly braces and start with '{'.

converter/dts/parser.py:536: DtsParseError
=========================== short test summary info ============================
FAILED tests/dts/test_extractor.py::test_extract_invalid_content - converter....
========================= 1 failed, 4 passed in 0.03s ==========================
