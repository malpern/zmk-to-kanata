============================= test session starts ==============================
platform darwin -- Python 3.10.16, pytest-8.3.4, pluggy-1.5.0 -- /Users/malpern/.pyenv/versions/3.10.16/bin/python3.10
cachedir: .pytest_cache
rootdir: /Volumes/FlashGordon/Dropbox/code/nicktokatana
configfile: pyproject.toml
testpaths: tests
plugins: anyio-4.7.0
collecting ... collected 72 items

tests/dts/test_ast.py::test_dts_property_creation PASSED                 [  1%]
tests/dts/test_ast.py::test_dts_node_creation PASSED                     [  2%]
tests/dts/test_ast.py::test_dts_node_find PASSED                         [  4%]
tests/dts/test_ast.py::test_dts_root_creation PASSED                     [  5%]
tests/dts/test_ast.py::test_dts_root_label_map PASSED                    [  6%]
tests/dts/test_end_to_end.py::test_simple_keymap PASSED                  [  8%]
tests/dts/test_end_to_end.py::test_complex_keymap_with_behaviors PASSED  [  9%]
tests/dts/test_end_to_end.py::test_keymap_with_unicode FAILED            [ 11%]
tests/dts/test_end_to_end.py::test_error_handling FAILED                 [ 12%]
tests/dts/test_end_to_end.py::test_keymap_with_combos PASSED             [ 13%]
tests/dts/test_end_to_end.py::test_keymap_with_conditional_layers PASSED [ 15%]
tests/dts/test_extractor.py::test_extract_simple_keymap PASSED           [ 16%]
tests/dts/test_extractor.py::test_extract_with_behaviors PASSED          [ 18%]
tests/dts/test_extractor.py::test_extract_multiple_layers PASSED         [ 19%]
tests/dts/test_extractor.py::test_extract_complex_bindings PASSED        [ 20%]
tests/dts/test_extractor.py::test_extract_invalid_content FAILED         [ 22%]
tests/dts/test_integration.py::test_full_pipeline_simple_keymap PASSED   [ 23%]
tests/dts/test_integration.py::test_full_pipeline_with_behaviors PASSED  [ 25%]
tests/dts/test_integration.py::test_full_pipeline_multiple_layers PASSED [ 26%]
tests/dts/test_integration.py::test_full_pipeline_complex_bindings PASSED [ 27%]
tests/dts/test_integration.py::test_full_pipeline_error_handling FAILED  [ 29%]
tests/dts/test_parser.py::test_parse_simple_dts PASSED                   [ 30%]
tests/dts/test_parser.py::test_parse_with_labels PASSED                  [ 31%]
tests/dts/test_parser.py::test_parse_with_references PASSED              [ 33%]
tests/dts/test_parser.py::test_parse_error_handling PASSED               [ 34%]
tests/dts/test_parser.py::test_parse_complex_dts PASSED                  [ 36%]
tests/dts/test_parser.py::test_parse_nested_nodes PASSED                 [ 37%]
tests/dts/test_parser.py::test_parse_multiple_labels PASSED              [ 38%]
tests/dts/test_parser.py::test_parse_complex_arrays PASSED               [ 40%]
tests/dts/test_parser.py::test_parse_boolean_properties PASSED           [ 41%]
tests/dts/test_parser.py::test_parse_empty_nodes_and_properties PASSED   [ 43%]
tests/dts/test_parser.py::test_parse_comments PASSED                     [ 44%]
tests/dts/test_parser.py::test_parse_zmk_specific_constructs PASSED      [ 45%]
tests/dts/test_parser.py::test_parse_array_with_mixed_cell_types_and_references PASSED [ 47%]
tests/dts/test_performance.py::test_preprocessor_performance FAILED      [ 48%]
tests/dts/test_performance.py::test_parser_performance FAILED            [ 50%]
tests/dts/test_performance.py::test_extractor_performance FAILED         [ 51%]
tests/dts/test_performance.py::test_full_pipeline_performance FAILED     [ 52%]
tests/dts/test_preprocessor.py::test_preprocessor_initialization PASSED  [ 54%]
tests/dts/test_preprocessor.py::test_preprocess_simple_file PASSED       [ 55%]
tests/dts/test_preprocessor.py::test_preprocess_with_matrix PASSED       [ 56%]
tests/dts/test_preprocessor.py::test_preprocess_with_includes PASSED     [ 58%]
tests/dts/test_preprocessor.py::test_preprocess_invalid_file PASSED      [ 59%]
tests/dts/test_preprocessor.py::test_preprocess_invalid_cpp_command PASSED [ 61%]
tests/dts/test_preprocessor.py::test_matrix_size_extraction PASSED       [ 62%]
tests/dts/test_preprocessor.py::test_preprocess_simple_keymap PASSED     [ 63%]
tests/dts/test_preprocessor.py::test_preprocess_with_include_paths PASSED [ 65%]
tests/dts/test_preprocessor.py::test_matrix_size_detection PASSED        [ 66%]
tests/dts/test_preprocessor.py::test_matrix_size_detection_no_matrix PASSED [ 68%]
tests/test_dts_parser.py::test_parse_simple_keymap PASSED                [ 69%]
tests/test_dts_parser.py::test_parse_large_keymap PASSED                 [ 70%]
tests/test_dts_parser.py::test_parse_simple_dts PASSED                   [ 72%]
tests/test_dts_parser.py::test_parse_with_labels PASSED                  [ 73%]
tests/test_dts_parser.py::test_parse_complex_bindings PASSED             [ 75%]
tests/test_dts_parser.py::test_parse_error_handling PASSED               [ 76%]
tests/test_dts_parser.py::test_parse_invalid_content PASSED              [ 77%]
tests/test_dts_parser.py::test_find_node PASSED                          [ 79%]
tests/test_dts_preprocessor.py::test_preprocessor PASSED                 [ 80%]
tests/test_dts_preprocessor.py::test_preprocessor_large_matrix PASSED    [ 81%]
tests/test_dts_preprocessor.py::test_preprocessor_error_handling PASSED  [ 83%]
tests/test_kanata_converter.py::test_convert_simple_keymap PASSED        [ 84%]
tests/test_kanata_converter.py::test_convert_large_keymap PASSED         [ 86%]
tests/test_kanata_converter.py::test_convert_multiple_layers PASSED      [ 87%]
tests/test_kanata_converter.py::test_convert_invalid_key_code PASSED     [ 88%]
tests/test_kanata_converter.py::test_convert_invalid_key_type PASSED     [ 90%]
tests/test_main.py::test_main_simple_conversion_stdout PASSED            [ 91%]
tests/test_main.py::test_main_simple_conversion_outfile PASSED           [ 93%]
tests/test_main.py::test_main_with_include PASSED                        [ 94%]
tests/test_main.py::test_main_input_file_not_found PASSED                [ 95%]
tests/test_main.py::test_main_invalid_dts PASSED                         [ 97%]
tests/test_main.py::test_main_no_args PASSED                             [ 98%]
tests/test_main.py::test_main_help PASSED                                [100%]

=================================== FAILURES ===================================
___________________________ test_keymap_with_unicode ___________________________

    def test_keymap_with_unicode():
        """Test parsing a keymap with unicode behaviors."""
        content = """
        / {
            behaviors {
                unicode: unicode {
                    compatible = "zmk,behavior-unicode";
                    #binding-cells = <1>;
                };
    
                uc_string: unicode_string {
                    compatible = "zmk,behavior-unicode-string";
                    #binding-cells = <1>;
                    strings = <
                        "smile" "ðŸ˜Š"
                        "heart" "â¤ï¸"
                    >;
                };
            };
    
            keymap {
                compatible = "zmk,keymap";
    
                default_layer {
                    bindings = <
                        &unicode U0001F600  &uc_string smile  &kp A
                        &unicode U2764      &uc_string heart  &kp B
                    >;
                };
            };
        };
        """
    
        # Parse and extract
        parser = DtsParser()
        ast = parser.parse(content)
    
        extractor = KeymapExtractor()
        config = extractor.extract(ast)
    
        # Verify behaviors
        assert len(config.behaviors) == 2
    
        unicode = next(b for b in config.behaviors.values() if b.name == "unicode")
        assert isinstance(unicode, Behavior)
    
        uc_string = next(b for b in config.behaviors.values() if b.name == "uc_string")
        assert isinstance(uc_string, Behavior)
    
        # Verify bindings
        layer_node = config.layers[0]
>       assert len(layer_node.bindings) == 6
E       AssertionError: assert 10 == 6
E        +  where 10 = len([Binding(behavior=Behavior(name='unicode', type='unicode'), params=[]), Binding(behavior=None, params=['U0001F600']), Binding(behavior=Behavior(name='uc_string', type='unicode_string'), params=[]), Binding(behavior=None, params=['smile']), Binding(behavior=None, params=['A']), Binding(behavior=Behavior(name='unicode', type='unicode'), params=[]), ...])
E        +    where [Binding(behavior=Behavior(name='unicode', type='unicode'), params=[]), Binding(behavior=None, params=['U0001F600']), Binding(behavior=Behavior(name='uc_string', type='unicode_string'), params=[]), Binding(behavior=None, params=['smile']), Binding(behavior=None, params=['A']), Binding(behavior=Behavior(name='unicode', type='unicode'), params=[]), ...] = Layer(name='default_layer', bindings=[Binding(behavior=Behavior(name='unicode', type='unicode'), params=[]), Binding(behavior=None, params=['U0001F600']), Binding(behavior=Behavior(name='uc_string', type='unicode_string'), params=[]), Binding(behavior=None, params=['smile']), Binding(behavior=None, params=['A']), Binding(behavior=Behavior(name='unicode', type='unicode'), params=[]), Binding(behavior=None, params=['U2764']), Binding(behavior=Behavior(name='uc_string', type='unicode_string'), params=[]), Binding(behavior=None, params=['heart']), Binding(behavior=None, params=['B'])], index=0).bindings

tests/dts/test_end_to_end.py:203: AssertionError
----------------------------- Captured stdout call -----------------------------
[DEBUG] i=147, char='1', depth=1, snippet=<1
[DEBUG] i=148, char='>', depth=1, snippet=<1>
[DEBUG] i=313, char='1', depth=1, snippet=<1
[DEBUG] i=314, char='>', depth=1, snippet=<1>
[DEBUG] i=344, char='\n', depth=1, snippet=<

[DEBUG] i=345, char=' ', depth=1, snippet=<
 
[DEBUG] i=346, char=' ', depth=1, snippet=<
  
[DEBUG] i=347, char=' ', depth=1, snippet=<
   
[DEBUG] i=348, char=' ', depth=1, snippet=<
    
[DEBUG] i=349, char=' ', depth=1, snippet=<
     
[DEBUG] i=350, char=' ', depth=1, snippet=<
      
[DEBUG] i=351, char=' ', depth=1, snippet=<
       
[DEBUG] i=352, char=' ', depth=1, snippet=<
        
[DEBUG] i=353, char=' ', depth=1, snippet=<
         
[DEBUG] i=354, char=' ', depth=1, snippet=<
          
[DEBUG] i=355, char=' ', depth=1, snippet=<
           
[DEBUG] i=356, char=' ', depth=1, snippet=<
            
[DEBUG] i=357, char=' ', depth=1, snippet=<
             
[DEBUG] i=358, char=' ', depth=1, snippet=<
              
[DEBUG] i=359, char=' ', depth=1, snippet=<
               
[DEBUG] i=360, char=' ', depth=1, snippet=<
                
[DEBUG] i=361, char=' ', depth=1, snippet=<
                 
[DEBUG] i=362, char=' ', depth=1, snippet=<
                  
[DEBUG] i=363, char=' ', depth=1, snippet=<
                   
[DEBUG] i=364, char=' ', depth=1, snippet=<
                    
[DEBUG] i=365, char='"', depth=1, snippet=<
                    "
[DEBUG] i=366, char='s', depth=1, snippet=<
                    "s
[DEBUG] i=367, char='m', depth=1, snippet=<
                    "sm
[DEBUG] i=368, char='i', depth=1, snippet=<
                    "smi
[DEBUG] i=369, char='l', depth=1, snippet=<
                    "smil
[DEBUG] i=370, char='e', depth=1, snippet=<
                    "smile
[DEBUG] i=371, char='"', depth=1, snippet=<
                    "smile"
[DEBUG] i=372, char=' ', depth=1, snippet=<
                    "smile" 
[DEBUG] i=373, char='"', depth=1, snippet=<
                    "smile" "
[DEBUG] i=374, char='ðŸ˜Š', depth=1, snippet=<
                    "smile" "ðŸ˜Š
[DEBUG] i=375, char='"', depth=1, snippet=<
                    "smile" "ðŸ˜Š"
[DEBUG] i=376, char='\n', depth=1, snippet=<
                    "smile" "ðŸ˜Š"

[DEBUG] i=377, char=' ', depth=1, snippet=<
                    "smile" "ðŸ˜Š"
 
[DEBUG] i=378, char=' ', depth=1, snippet=<
                    "smile" "ðŸ˜Š"
  
[DEBUG] i=379, char=' ', depth=1, snippet=<
                    "smile" "ðŸ˜Š"
   
[DEBUG] i=380, char=' ', depth=1, snippet=<
                    "smile" "ðŸ˜Š"
    
[DEBUG] i=381, char=' ', depth=1, snippet=<
                    "smile" "ðŸ˜Š"
     
[DEBUG] i=382, char=' ', depth=1, snippet=<
                    "smile" "ðŸ˜Š"
      
[DEBUG] i=383, char=' ', depth=1, snippet=<
                    "smile" "ðŸ˜Š"
       
[DEBUG] i=384, char=' ', depth=1, snippet=<
                    "smile" "ðŸ˜Š"
        
[DEBUG] i=385, char=' ', depth=1, snippet=<
                    "smile" "ðŸ˜Š"
         
[DEBUG] i=386, char=' ', depth=1, snippet=<
                    "smile" "ðŸ˜Š"
          
[DEBUG] i=387, char=' ', depth=1, snippet=<
                    "smile" "ðŸ˜Š"
           
[DEBUG] i=388, char=' ', depth=1, snippet=<
                    "smile" "ðŸ˜Š"
            
[DEBUG] i=389, char=' ', depth=1, snippet=<
                    "smile" "ðŸ˜Š"
             
[DEBUG] i=390, char=' ', depth=1, snippet=<
                    "smile" "ðŸ˜Š"
              
[DEBUG] i=391, char=' ', depth=1, snippet=<
                    "smile" "ðŸ˜Š"
               
[DEBUG] i=392, char=' ', depth=1, snippet=<
                    "smile" "ðŸ˜Š"
                
[DEBUG] i=393, char=' ', depth=1, snippet=<
                    "smile" "ðŸ˜Š"
                 
[DEBUG] i=394, char=' ', depth=1, snippet=<
                    "smile" "ðŸ˜Š"
                  
[DEBUG] i=395, char=' ', depth=1, snippet=<
                    "smile" "ðŸ˜Š"
                   
[DEBUG] i=396, char=' ', depth=1, snippet=<
                    "smile" "ðŸ˜Š"
                    
[DEBUG] i=397, char='"', depth=1, snippet=<
                    "smile" "ðŸ˜Š"
                    "
[DEBUG] i=398, char='h', depth=1, snippet=<
                    "smile" "ðŸ˜Š"
                    "h
[DEBUG] i=399, char='e', depth=1, snippet=<
                    "smile" "ðŸ˜Š"
                    "he
[DEBUG] i=400, char='a', depth=1, snippet=<
                    "smile" "ðŸ˜Š"
                    "hea
[DEBUG] i=401, char='r', depth=1, snippet=<
                    "smile" "ðŸ˜Š"
                    "hear
[DEBUG] i=402, char='t', depth=1, snippet=<
                    "smile" "ðŸ˜Š"
                    "heart
[DEBUG] i=403, char='"', depth=1, snippet=<
                    "smile" "ðŸ˜Š"
                    "heart"
[DEBUG] i=404, char=' ', depth=1, snippet=<
                    "smile" "ðŸ˜Š"
                    "heart" 
[DEBUG] i=405, char='"', depth=1, snippet=<
                    "smile" "ðŸ˜Š"
                    "heart" "
[DEBUG] i=406, char='â¤', depth=1, snippet=<
                    "smile" "ðŸ˜Š"
                    "heart" "â¤
[DEBUG] i=407, char='ï¸', depth=1, snippet=<
                    "smile" "ðŸ˜Š"
                    "heart" "â¤ï¸
[DEBUG] i=408, char='"', depth=1, snippet=<
                    "smile" "ðŸ˜Š"
                    "heart" "â¤ï¸"
[DEBUG] i=409, char='\n', depth=1, snippet=<
                    "smile" "ðŸ˜Š"
                    "heart" "â¤ï¸"

[DEBUG] i=410, char=' ', depth=1, snippet=<
                    "smile" "ðŸ˜Š"
                    "heart" "â¤ï¸"
 
[DEBUG] i=411, char=' ', depth=1, snippet=<
                    "smile" "ðŸ˜Š"
                    "heart" "â¤ï¸"
  
[DEBUG] i=412, char=' ', depth=1, snippet=<
                    "smile" "ðŸ˜Š"
                    "heart" "â¤ï¸"
   
[DEBUG] i=413, char=' ', depth=1, snippet=<
                    "smile" "ðŸ˜Š"
                    "heart" "â¤ï¸"
    
[DEBUG] i=414, char=' ', depth=1, snippet=<
                    "smile" "ðŸ˜Š"
                    "heart" "â¤ï¸"
     
[DEBUG] i=415, char=' ', depth=1, snippet=<
                    "smile" "ðŸ˜Š"
                    "heart" "â¤ï¸"
      
[DEBUG] i=416, char=' ', depth=1, snippet=<
                    "smile" "ðŸ˜Š"
                    "heart" "â¤ï¸"
       
[DEBUG] i=417, char=' ', depth=1, snippet=<
                    "smile" "ðŸ˜Š"
                    "heart" "â¤ï¸"
        
[DEBUG] i=418, char=' ', depth=1, snippet=<
                    "smile" "ðŸ˜Š"
                    "heart" "â¤ï¸"
         
[DEBUG] i=419, char=' ', depth=1, snippet=<
                    "smile" "ðŸ˜Š"
                    "heart" "â¤ï¸"
          
[DEBUG] i=420, char=' ', depth=1, snippet=<
                    "smile" "ðŸ˜Š"
                    "heart" "â¤ï¸"
           
[DEBUG] i=421, char=' ', depth=1, snippet=<
                    "smile" "ðŸ˜Š"
                    "heart" "â¤ï¸"
            
[DEBUG] i=422, char=' ', depth=1, snippet=<
                    "smile" "ðŸ˜Š"
                    "heart" "â¤ï¸"
             
[DEBUG] i=423, char=' ', depth=1, snippet=<
                    "smile" "ðŸ˜Š"
                    "heart" "â¤ï¸"
              
[DEBUG] i=424, char=' ', depth=1, snippet=<
                    "smile" "ðŸ˜Š"
                    "heart" "â¤ï¸"
               
[DEBUG] i=425, char=' ', depth=1, snippet=<
                    "smile" "ðŸ˜Š"
                    "heart" "â¤ï¸"
                
[DEBUG] i=426, char='>', depth=1, snippet=<
                    "smile" "ðŸ˜Š"
                    "heart" "â¤ï¸"
                >
[DEBUG] i=589, char='\n', depth=1, snippet=<

[DEBUG] i=590, char=' ', depth=1, snippet=<
 
[DEBUG] i=591, char=' ', depth=1, snippet=<
  
[DEBUG] i=592, char=' ', depth=1, snippet=<
   
[DEBUG] i=593, char=' ', depth=1, snippet=<
    
[DEBUG] i=594, char=' ', depth=1, snippet=<
     
[DEBUG] i=595, char=' ', depth=1, snippet=<
      
[DEBUG] i=596, char=' ', depth=1, snippet=<
       
[DEBUG] i=597, char=' ', depth=1, snippet=<
        
[DEBUG] i=598, char=' ', depth=1, snippet=<
         
[DEBUG] i=599, char=' ', depth=1, snippet=<
          
[DEBUG] i=600, char=' ', depth=1, snippet=<
           
[DEBUG] i=601, char=' ', depth=1, snippet=<
            
[DEBUG] i=602, char=' ', depth=1, snippet=<
             
[DEBUG] i=603, char=' ', depth=1, snippet=<
              
[DEBUG] i=604, char=' ', depth=1, snippet=<
               
[DEBUG] i=605, char=' ', depth=1, snippet=<
                
[DEBUG] i=606, char=' ', depth=1, snippet=<
                 
[DEBUG] i=607, char=' ', depth=1, snippet=<
                  
[DEBUG] i=608, char=' ', depth=1, snippet=<
                   
[DEBUG] i=609, char=' ', depth=1, snippet=<
                    
[DEBUG] i=610, char='&', depth=1, snippet=<
                    &
[DEBUG] i=611, char='u', depth=1, snippet=<
                    &u
[DEBUG] i=612, char='n', depth=1, snippet=<
                    &un
[DEBUG] i=613, char='i', depth=1, snippet=<
                    &uni
[DEBUG] i=614, char='c', depth=1, snippet=<
                    &unic
[DEBUG] i=615, char='o', depth=1, snippet=<
                    &unico
[DEBUG] i=616, char='d', depth=1, snippet=<
                    &unicod
[DEBUG] i=617, char='e', depth=1, snippet=<
                    &unicode
[DEBUG] i=618, char=' ', depth=1, snippet=<
                    &unicode 
[DEBUG] i=619, char='U', depth=1, snippet=<
                    &unicode U
[DEBUG] i=620, char='0', depth=1, snippet=<
                    &unicode U0
[DEBUG] i=621, char='0', depth=1, snippet=<
                    &unicode U00
[DEBUG] i=622, char='0', depth=1, snippet=<
                    &unicode U000
[DEBUG] i=623, char='1', depth=1, snippet=<
                    &unicode U0001
[DEBUG] i=624, char='F', depth=1, snippet=<
                    &unicode U0001F
[DEBUG] i=625, char='6', depth=1, snippet=<
                    &unicode U0001F6
[DEBUG] i=626, char='0', depth=1, snippet=<
                    &unicode U0001F60
[DEBUG] i=627, char='0', depth=1, snippet=<
                    &unicode U0001F600
[DEBUG] i=628, char=' ', depth=1, snippet=<
                    &unicode U0001F600 
[DEBUG] i=629, char=' ', depth=1, snippet=<
                    &unicode U0001F600  
[DEBUG] i=630, char='&', depth=1, snippet=<
                    &unicode U0001F600  &
[DEBUG] i=631, char='u', depth=1, snippet=<
                    &unicode U0001F600  &u
[DEBUG] i=632, char='c', depth=1, snippet=<
                    &unicode U0001F600  &uc
[DEBUG] i=633, char='_', depth=1, snippet=<
                    &unicode U0001F600  &uc_
[DEBUG] i=634, char='s', depth=1, snippet=<
                    &unicode U0001F600  &uc_s
[DEBUG] i=635, char='t', depth=1, snippet=<
                    &unicode U0001F600  &uc_st
[DEBUG] i=636, char='r', depth=1, snippet=<
                    &unicode U0001F600  &uc_str
[DEBUG] i=637, char='i', depth=1, snippet=<
                    &unicode U0001F600  &uc_stri
[DEBUG] i=638, char='n', depth=1, snippet=<
                    &unicode U0001F600  &uc_strin
[DEBUG] i=639, char='g', depth=1, snippet=<
                    &unicode U0001F600  &uc_string
[DEBUG] i=640, char=' ', depth=1, snippet=<
                    &unicode U0001F600  &uc_string 
[DEBUG] i=641, char='s', depth=1, snippet=<
                    &unicode U0001F600  &uc_string s
[DEBUG] i=642, char='m', depth=1, snippet=<
                    &unicode U0001F600  &uc_string sm
[DEBUG] i=643, char='i', depth=1, snippet=<
                    &unicode U0001F600  &uc_string smi
[DEBUG] i=644, char='l', depth=1, snippet=<
                    &unicode U0001F600  &uc_string smil
[DEBUG] i=645, char='e', depth=1, snippet=<
                    &unicode U0001F600  &uc_string smile
[DEBUG] i=646, char=' ', depth=1, snippet=<
                    &unicode U0001F600  &uc_string smile 
[DEBUG] i=647, char=' ', depth=1, snippet=<
                    &unicode U0001F600  &uc_string smile  
[DEBUG] i=648, char='&', depth=1, snippet=<
                    &unicode U0001F600  &uc_string smile  &
[DEBUG] i=649, char='k', depth=1, snippet=<
                    &unicode U0001F600  &uc_string smile  &k
[DEBUG] i=650, char='p', depth=1, snippet=<
                    &unicode U0001F600  &uc_string smile  &kp
[DEBUG] i=651, char=' ', depth=1, snippet=<
                    &unicode U0001F600  &uc_string smile  &kp 
[DEBUG] i=652, char='A', depth=1, snippet=<
                    &unicode U0001F600  &uc_string smile  &kp A
[DEBUG] i=653, char='\n', depth=1, snippet=<
                    &unicode U0001F600  &uc_string smile  &kp A

[DEBUG] i=654, char=' ', depth=1, snippet=<
                    &unicode U0001F600  &uc_string smile  &kp A
 
[DEBUG] i=655, char=' ', depth=1, snippet=<
                    &unicode U0001F600  &uc_string smile  &kp A
  
[DEBUG] i=656, char=' ', depth=1, snippet=<
                    &unicode U0001F600  &uc_string smile  &kp A
   
[DEBUG] i=657, char=' ', depth=1, snippet=<
                    &unicode U0001F600  &uc_string smile  &kp A
    
[DEBUG] i=658, char=' ', depth=1, snippet=<
                    &unicode U0001F600  &uc_string smile  &kp A
     
[DEBUG] i=659, char=' ', depth=1, snippet=<
                    &unicode U0001F600  &uc_string smile  &kp A
      
[DEBUG] i=660, char=' ', depth=1, snippet=<
                    &unicode U0001F600  &uc_string smile  &kp A
       
[DEBUG] i=661, char=' ', depth=1, snippet=<
                    &unicode U0001F600  &uc_string smile  &kp A
        
[DEBUG] i=662, char=' ', depth=1, snippet=<
                    &unicode U0001F600  &uc_string smile  &kp A
         
[DEBUG] i=663, char=' ', depth=1, snippet=<
                    &unicode U0001F600  &uc_string smile  &kp A
          
[DEBUG] i=664, char=' ', depth=1, snippet=<
                    &unicode U0001F600  &uc_string smile  &kp A
           
[DEBUG] i=665, char=' ', depth=1, snippet=<
                    &unicode U0001F600  &uc_string smile  &kp A
            
[DEBUG] i=666, char=' ', depth=1, snippet=<
                    &unicode U0001F600  &uc_string smile  &kp A
             
[DEBUG] i=667, char=' ', depth=1, snippet=<
                    &unicode U0001F600  &uc_string smile  &kp A
              
[DEBUG] i=668, char=' ', depth=1, snippet=<
                    &unicode U0001F600  &uc_string smile  &kp A
               
[DEBUG] i=669, char=' ', depth=1, snippet=<
                    &unicode U0001F600  &uc_string smile  &kp A
                
[DEBUG] i=670, char=' ', depth=1, snippet=<
                    &unicode U0001F600  &uc_string smile  &kp A
                 
[DEBUG] i=671, char=' ', depth=1, snippet=<
                    &unicode U0001F600  &uc_string smile  &kp A
                  
[DEBUG] i=672, char=' ', depth=1, snippet=<
                    &unicode U0001F600  &uc_string smile  &kp A
                   
[DEBUG] i=673, char=' ', depth=1, snippet=<
                    &unicode U0001F600  &uc_string smile  &kp A
                    
[DEBUG] i=674, char='&', depth=1, snippet=<
                    &unicode U0001F600  &uc_string smile  &kp A
                    &
[DEBUG] i=675, char='u', depth=1, snippet=<
                    &unicode U0001F600  &uc_string smile  &kp A
                    &u
[DEBUG] i=676, char='n', depth=1, snippet=<
                    &unicode U0001F600  &uc_string smile  &kp A
                    &un
[DEBUG] i=677, char='i', depth=1, snippet=<
                    &unicode U0001F600  &uc_string smile  &kp A
                    &uni
[DEBUG] i=678, char='c', depth=1, snippet=<
                    &unicode U0001F600  &uc_string smile  &kp A
                    &unic
[DEBUG] i=679, char='o', depth=1, snippet=<
                    &unicode U0001F600  &uc_string smile  &kp A
                    &unico
[DEBUG] i=680, char='d', depth=1, snippet=<
                    &unicode U0001F600  &uc_string smile  &kp A
                    &unicod
[DEBUG] i=681, char='e', depth=1, snippet=<
                    &unicode U0001F600  &uc_string smile  &kp A
                    &unicode
[DEBUG] i=682, char=' ', depth=1, snippet=<
                    &unicode U0001F600  &uc_string smile  &kp A
                    &unicode 
[DEBUG] i=683, char='U', depth=1, snippet=<
                    &unicode U0001F600  &uc_string smile  &kp A
                    &unicode U
[DEBUG] i=684, char='2', depth=1, snippet=<
                    &unicode U0001F600  &uc_string smile  &kp A
                    &unicode U2
[DEBUG] i=685, char='7', depth=1, snippet=<
                    &unicode U0001F600  &uc_string smile  &kp A
                    &unicode U27
[DEBUG] i=686, char='6', depth=1, snippet=<
                    &unicode U0001F600  &uc_string smile  &kp A
                    &unicode U276
[DEBUG] i=687, char='4', depth=1, snippet=<
                    &unicode U0001F600  &uc_string smile  &kp A
                    &unicode U2764
Added layer default_layer: Layer(name='default_layer', bindings=[Binding(behavior=Behavior(name='unicode', type='unicode'), params=[]), Binding(behavior=None, params=['U0001F600']), Binding(behavior=Behavior(name='uc_string', type='unicode_string'), params=[]), Binding(behavior=None, params=['smile']), Binding(behavior=None, params=['A']), Binding(behavior=Behavior(name='unicode', type='unicode'), params=[]), Binding(behavior=None, params=['U2764']), Binding(behavior=Behavior(name='uc_string', type='unicode_string'), params=[]), Binding(behavior=None, params=['heart']), Binding(behavior=None, params=['B'])], index=0)
_____________________________ test_error_handling ______________________________

    def test_error_handling():
        """Test error handling with malformed input."""
        # Test missing root node
        with pytest.raises(DtsParseError, match="DTS must start with root node"):
            parser = DtsParser()
            parser.parse("keymap { };")
    
        # Test invalid property assignment
        with pytest.raises(DtsParseError, match="Invalid property value: value"):
            parser = DtsParser()
            parser.parse(
                """
            / {
                keymap {
                    prop = value
                };
            };
            """
            )
    
        # Test invalid binding format
        parser = DtsParser()
        ast = parser.parse(
            """
        / {
            keymap {
                default_layer {
                    bindings = <&invalid_binding>;
                };
            };
        };
        """
        )
        extractor = KeymapExtractor()
        with pytest.raises(ValueError, match="Invalid binding format: invalid_binding"):
>           extractor.extract(ast)

tests/dts/test_end_to_end.py:247: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
converter/dts/extractor.py:77: in extract
    self._extract_layers(keymap_node)
converter/dts/extractor.py:300: in _extract_layers
    layer = self._create_layer(child, idx)
converter/dts/extractor.py:319: in _create_layer
    parsed_bindings = self._parse_bindings(bindings_prop.value)
converter/dts/extractor.py:362: in _parse_bindings
    bindings.append(self._create_binding([behavior_name] + params))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <converter.dts.extractor.KeymapExtractor object at 0x105ed9e70>
value = ['invalid_binding']

    def _create_binding(self, value: str | List[str]) -> Binding:
        """Create a binding instance from a value."""
        if isinstance(value, list):
            # Handle list format [behavior_name, param1, ...]
            if not value:
                raise ValueError("Empty binding list value")
            behavior_name = value[0]
            params = value[1:]
    
            if behavior_name == "kp":
                if len(params) != 1:
                    raise ValueError(
                        f"kp behavior expects 1 parameter, "
                        f"got {len(params)}: {params}"
                    )
                # Ensure params is always a list
                return Binding(behavior=None, params=[params[0]])  # Wrap param
    
            # Look up custom behavior - should exist now
            behavior = self.behaviors.get(behavior_name)
            if behavior:
                # TODO: Validate params against behavior definition if needed
                return Binding(behavior=behavior, params=params)
            else:
                # This shouldn't happen if pass logic is correct
>               raise ValueError(
                    f"Unknown behavior referenced during binding creation: "
                    f"{behavior_name}"
                )
E               ValueError: Unknown behavior referenced during binding creation: invalid_binding

converter/dts/extractor.py:395: ValueError

During handling of the above exception, another exception occurred:

    def test_error_handling():
        """Test error handling with malformed input."""
        # Test missing root node
        with pytest.raises(DtsParseError, match="DTS must start with root node"):
            parser = DtsParser()
            parser.parse("keymap { };")
    
        # Test invalid property assignment
        with pytest.raises(DtsParseError, match="Invalid property value: value"):
            parser = DtsParser()
            parser.parse(
                """
            / {
                keymap {
                    prop = value
                };
            };
            """
            )
    
        # Test invalid binding format
        parser = DtsParser()
        ast = parser.parse(
            """
        / {
            keymap {
                default_layer {
                    bindings = <&invalid_binding>;
                };
            };
        };
        """
        )
        extractor = KeymapExtractor()
>       with pytest.raises(ValueError, match="Invalid binding format: invalid_binding"):
E       AssertionError: Regex pattern did not match.
E        Regex: 'Invalid binding format: invalid_binding'
E        Input: 'Unknown behavior referenced during binding creation: invalid_binding'

tests/dts/test_end_to_end.py:246: AssertionError
----------------------------- Captured stdout call -----------------------------
[DEBUG] i=82, char='&', depth=1, snippet=<&
[DEBUG] i=83, char='i', depth=1, snippet=<&i
[DEBUG] i=84, char='n', depth=1, snippet=<&in
[DEBUG] i=85, char='v', depth=1, snippet=<&inv
[DEBUG] i=86, char='a', depth=1, snippet=<&inva
[DEBUG] i=87, char='l', depth=1, snippet=<&inval
[DEBUG] i=88, char='i', depth=1, snippet=<&invali
[DEBUG] i=89, char='d', depth=1, snippet=<&invalid
[DEBUG] i=90, char='_', depth=1, snippet=<&invalid_
[DEBUG] i=91, char='b', depth=1, snippet=<&invalid_b
[DEBUG] i=92, char='i', depth=1, snippet=<&invalid_bi
[DEBUG] i=93, char='n', depth=1, snippet=<&invalid_bin
[DEBUG] i=94, char='d', depth=1, snippet=<&invalid_bind
[DEBUG] i=95, char='i', depth=1, snippet=<&invalid_bindi
[DEBUG] i=96, char='n', depth=1, snippet=<&invalid_bindin
[DEBUG] i=97, char='g', depth=1, snippet=<&invalid_binding
[DEBUG] i=98, char='>', depth=1, snippet=<&invalid_binding>
_________________________ test_extract_invalid_content _________________________

    def test_extract_invalid_content():
        """Test extracting invalid content."""
        content = """
        / {
            keymap {
                invalid_layer {
                    # Missing bindings
                };
            };
        };
        """
    
        parser = DtsParser()
>       ast = parser.parse(content)

tests/dts/test_extractor.py:166: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
converter/dts/parser.py:76: in parse
    self._parse_node_body(parsed_root_node)
converter/dts/parser.py:545: in _parse_node_body
    self._parse_node_body(child)
converter/dts/parser.py:545: in _parse_node_body
    self._parse_node_body(child)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <converter.dts.parser.DtsParser object at 0x105e3f100>
node = DtsNode(name='invalid_layer', parent=None, children={}, properties={}, labels={})

    def _parse_node_body(self, node: DtsNode) -> None:
        """Parse the body of a DTS node.
    
        Args:
            node: DtsNode to parse body into
    
        Raises:
            DtsParseError: If node body format is invalid
        """
        while self.pos < len(self.tokens):
            token = self.tokens[self.pos]
    
            if token == "}":
                self.pos += 1
                return
            elif token == "{":
                line, col = self._get_pos_info(self.pos)
                raise DtsParseError(
                    "Unexpected '{' in node body",
                    line=line,
                    column=col,
                    context=format_error_context(self.content, line, col),
                    help_text="Node definitions must have a label or reference",
                )
    
            if token == ";":  # Handle empty statements
                self.pos += 1
                continue
    
            # Handle boolean properties (e.g., "prop_name;")
            if self.pos + 1 < len(self.tokens) and self.tokens[self.pos + 1] == ";":
                name = token
                # Basic check for valid property name (alphanumeric, _, -)
                # This helps distinguish from stray semicolons or other constructs.
                # The tokenizer should ideally guarantee 'token' is a potential identifier here.
                if (
                    name
                    and all(c.isalnum() or c in ("_", "-", "#") for c in name)
                    and (name[0].isalpha() or name[0] == "#" or name[0] == "_")
                ):
                    prop = DtsProperty(name=name, value=True, type="boolean")
                    node.add_property(prop)
                    self.pos += 2  # Consume name and ';'
                    continue
    
            # Handle properties with assignment (e.g. "prop_name = value;")
            if self.pos + 2 < len(self.tokens) and self.tokens[self.pos + 1] == "=":
                name = token
                value_token = self.tokens[self.pos + 2]
                try:
                    prop = self._parse_property_value(name, value_token)
                    node.add_property(prop)
                    self.pos += 3
    
                    # Check for additional comma-separated array cells
                    if prop.type == "array":
                        while (
                            self.pos < len(self.tokens) and self.tokens[self.pos] == ","
                        ):
                            self.pos += 1
                            if self.pos >= len(self.tokens):
                                line, col = self._get_pos_info(self.pos - 1)
                                raise DtsParseError(
                                    "Unexpected end of file after ',' in property value",
                                    line=line,
                                    column=col,
                                    context=format_error_context(
                                        self.content, line, col
                                    ),
                                )
                            next_value_token = self.tokens[self.pos]
                            # Parse the next array cell. We expect it to be an array itself.
                            # _parse_property_value will return a DtsProperty, we need its value.
                            additional_prop_part = self._parse_property_value(
                                "_{temp}", next_value_token
                            )
                            if additional_prop_part.type == "array":
                                if isinstance(prop.value, list) and isinstance(
                                    additional_prop_part.value, list
                                ):
                                    prop.value.extend(additional_prop_part.value)
                                else:
                                    # This case should ideally not happen if tokens are well-formed <...>
                                    line, col = self._get_pos_info(self.pos)
                                    raise DtsParseError(
                                        f"Expected array type for subsequent part of property '{name}'",
                                        line=line,
                                        column=col,
                                        context=format_error_context(
                                            self.content, line, col
                                        ),
                                    )
                            else:
                                line, col = self._get_pos_info(self.pos)
                                raise DtsParseError(
                                    f"Expected array for subsequent part of property '{name}', got {additional_prop_part.type}",
                                    line=line,
                                    column=col,
                                    context=format_error_context(
                                        self.content, line, col
                                    ),
                                )
                            self.pos += 1
                except DtsParseError as e:
                    if not e.help_text:
                        e.help_text = f"Invalid value for property '{name}'"
                    raise
                if self.pos >= len(self.tokens) or self.tokens[self.pos] != ";":
                    line, col = self._get_pos_info(self.pos)
                    raise DtsParseError(
                        "Expected ';' after property value",
                        line=line,
                        column=col,
                        context=format_error_context(self.content, line, col),
                        help_text="Property definitions must end with a semicolon",
                    )
                self.pos += 1
                continue
    
            # Handle child nodes. At this point, 'token' is either a node name or a label.
            current_labels_for_node: List[str] = []
            current_token = token  # Start with the first token we haven't processed as property/etc.
    
            # Loop to gather all labels: label1: label2: ... node_name
            while self.pos + 1 < len(self.tokens) and self.tokens[self.pos + 1] == ":":
                # Current token is a label
                current_labels_for_node.append(current_token)
                self.pos += 2  # Consume label and ':'
                if self.pos >= len(self.tokens):
                    line, col = self._get_pos_info(self.pos - 1)
                    raise DtsParseError(
                        "Unexpected end of file after label expecting node name or another label",
                        line=line,
                        column=col,
                        context=format_error_context(self.content, line, col),
                    )
                current_token = self.tokens[
                    self.pos
                ]  # This is the next potential label or the actual node name
    
            # After the loop, current_token is the actual node name
            actual_node_name = current_token
            self.pos += 1  # Consume the actual_node_name token
    
            child = DtsNode(name=actual_node_name)
            for lbl in current_labels_for_node:
                child.add_label(lbl)
    
            if self.pos >= len(self.tokens) or self.tokens[self.pos] != "{":
                line, col = self._get_pos_info(self.pos)
                # Provide more context in error: what token did we actually find?
                found_token_msg = (
                    f"Found '{self.tokens[self.pos]}' instead."
                    if self.pos < len(self.tokens)
                    else "Found end of input."
                )
>               raise DtsParseError(
                    f"Expected '{{ ' after node '{actual_node_name}'. {found_token_msg}",
                    line=line,
                    column=col,
                    context=format_error_context(self.content, line, col),
                    help_text="Node definitions must be enclosed in curly braces and start with '{'.",
                )
E               converter.dts.error_handler.DtsParseError: Expected '{ ' after node '#'. Found 'Missing' instead. at line 6, column -34
E               
E               4 |             invalid_layer {
E               5 |                 # Missing bindings
E               6 |             };
E                 | ^
E               7 |         };
E               8 |     };
E               
E               Help: Node definitions must be enclosed in curly braces and start with '{'.

converter/dts/parser.py:536: DtsParseError
______________________ test_full_pipeline_error_handling _______________________

    def test_full_pipeline_error_handling():
        """Test error handling in the full pipeline."""
        # Test missing root node
        content = "node1 { };"
        parser = DtsParser()
        with pytest.raises(ValueError, match="Expected root node"):
>           parser.parse(content)

tests/dts/test_integration.py:212: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <converter.dts.parser.DtsParser object at 0x105ecbb80>
content = 'node1 { };', file = None

    def parse(self, content: str, file: Optional[str] = None) -> DtsRoot:
        """Parse DTS content into an AST.
    
        Args:
            content: DTS content string
            file: Optional file path for error reporting
    
        Returns:
            DtsRoot object representing the parsed AST
    
        Raises:
            DtsParseError: If the content is not valid DTS
        """
        # Remove preprocessor line markers (lines starting with '# <digit>')
        content = "\n".join(
            line
            for line in content.splitlines()
            if not (
                line.lstrip().startswith("#")
                and line.lstrip()[1:2] == " "
                and line.lstrip()[2:3].isdigit()
            )
        )
        self.content = content
        self.tokens = []
        self.line_map = []
        self._tokenize(content)
        self.pos = 0
    
        # Check for root node token '/'
        if not self.tokens or self.tokens[0] != "/":
>           raise DtsParseError(
                "DTS must start with root node '/'",
                file=file,
                line=1,
                column=1,
                context=format_error_context(content, 1, 1),
            )
E           converter.dts.error_handler.DtsParseError: DTS must start with root node '/' at line 1, column 1
E           
E           1 | node1 { };
E             | ^
E           
E           Help: Check the DTS syntax and ensure it follows the specification.

converter/dts/parser.py:49: DtsParseError
________________________ test_preprocessor_performance _________________________

sample_keymap_path = '/Volumes/FlashGordon/Dropbox/code/nicktokatana/tests/fixtures/dts/complex_keymap.zmk'

    def test_preprocessor_performance(sample_keymap_path):
        """Test the performance of the preprocessor."""
>       preprocessor = DtsPreprocessor(
            include_paths=[str(Path(__file__).parent / "fixtures" / "dts" / "include")]
        )

tests/dts/test_performance.py:29: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <converter.dts.preprocessor.DtsPreprocessor object at 0x105ed0850>
cpp_path = '/usr/bin/cpp'
include_paths = ['/Volumes/FlashGordon/Dropbox/code/nicktokatana/tests/dts/fixtures/dts/include']

    def __init__(
        self,
        cpp_path: Optional[str] = None,
        include_paths: Optional[List[str]] = None,
    ):
        """Initialize the preprocessor.
    
        Args:
            cpp_path: Path to the C preprocessor executable
            include_paths: List of paths to search for include files
        """
        if cpp_path is None:
            cpp_path = "/usr/bin/cpp"
        cpp_path = str(cpp_path)
        if not cpp_path.endswith("cpp"):
            raise PreprocessorError(
                "Invalid cpp path",
                help_text="The cpp path must point to a cpp executable",
            )
        self.cpp_path = Path(cpp_path)
    
        self.include_paths = []
        if include_paths:
            for path in include_paths:
                path_obj = Path(path)
                if not path_obj.exists():
                    msg = f"Include path does not exist: {path}"
                    help_text = "Ensure all include paths exist and are " "accessible"
>                   raise PreprocessorError(msg, help_text=help_text)
E                   converter.dts.preprocessor.PreprocessorError: Include path does not exist: /Volumes/FlashGordon/Dropbox/code/nicktokatana/tests/dts/fixtures/dts/include

converter/dts/preprocessor.py:77: PreprocessorError
___________________________ test_parser_performance ____________________________

sample_keymap_path = '/Volumes/FlashGordon/Dropbox/code/nicktokatana/tests/fixtures/dts/complex_keymap.zmk'

    def test_parser_performance(sample_keymap_path):
        """Test the performance of the parser."""
>       preprocessor = DtsPreprocessor(
            include_paths=[str(Path(__file__).parent / "fixtures" / "dts" / "include")]
        )

tests/dts/test_performance.py:54: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <converter.dts.preprocessor.DtsPreprocessor object at 0x105ed5ba0>
cpp_path = '/usr/bin/cpp'
include_paths = ['/Volumes/FlashGordon/Dropbox/code/nicktokatana/tests/dts/fixtures/dts/include']

    def __init__(
        self,
        cpp_path: Optional[str] = None,
        include_paths: Optional[List[str]] = None,
    ):
        """Initialize the preprocessor.
    
        Args:
            cpp_path: Path to the C preprocessor executable
            include_paths: List of paths to search for include files
        """
        if cpp_path is None:
            cpp_path = "/usr/bin/cpp"
        cpp_path = str(cpp_path)
        if not cpp_path.endswith("cpp"):
            raise PreprocessorError(
                "Invalid cpp path",
                help_text="The cpp path must point to a cpp executable",
            )
        self.cpp_path = Path(cpp_path)
    
        self.include_paths = []
        if include_paths:
            for path in include_paths:
                path_obj = Path(path)
                if not path_obj.exists():
                    msg = f"Include path does not exist: {path}"
                    help_text = "Ensure all include paths exist and are " "accessible"
>                   raise PreprocessorError(msg, help_text=help_text)
E                   converter.dts.preprocessor.PreprocessorError: Include path does not exist: /Volumes/FlashGordon/Dropbox/code/nicktokatana/tests/dts/fixtures/dts/include

converter/dts/preprocessor.py:77: PreprocessorError
__________________________ test_extractor_performance __________________________

sample_keymap_path = '/Volumes/FlashGordon/Dropbox/code/nicktokatana/tests/fixtures/dts/complex_keymap.zmk'

    def test_extractor_performance(sample_keymap_path):
        """Test the performance of the extractor."""
>       preprocessor = DtsPreprocessor(
            include_paths=[str(Path(__file__).parent / "fixtures" / "dts" / "include")]
        )

tests/dts/test_performance.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <converter.dts.preprocessor.DtsPreprocessor object at 0x105e3e620>
cpp_path = '/usr/bin/cpp'
include_paths = ['/Volumes/FlashGordon/Dropbox/code/nicktokatana/tests/dts/fixtures/dts/include']

    def __init__(
        self,
        cpp_path: Optional[str] = None,
        include_paths: Optional[List[str]] = None,
    ):
        """Initialize the preprocessor.
    
        Args:
            cpp_path: Path to the C preprocessor executable
            include_paths: List of paths to search for include files
        """
        if cpp_path is None:
            cpp_path = "/usr/bin/cpp"
        cpp_path = str(cpp_path)
        if not cpp_path.endswith("cpp"):
            raise PreprocessorError(
                "Invalid cpp path",
                help_text="The cpp path must point to a cpp executable",
            )
        self.cpp_path = Path(cpp_path)
    
        self.include_paths = []
        if include_paths:
            for path in include_paths:
                path_obj = Path(path)
                if not path_obj.exists():
                    msg = f"Include path does not exist: {path}"
                    help_text = "Ensure all include paths exist and are " "accessible"
>                   raise PreprocessorError(msg, help_text=help_text)
E                   converter.dts.preprocessor.PreprocessorError: Include path does not exist: /Volumes/FlashGordon/Dropbox/code/nicktokatana/tests/dts/fixtures/dts/include

converter/dts/preprocessor.py:77: PreprocessorError
________________________ test_full_pipeline_performance ________________________

sample_keymap_path = '/Volumes/FlashGordon/Dropbox/code/nicktokatana/tests/fixtures/dts/complex_keymap.zmk'

    def test_full_pipeline_performance(sample_keymap_path):
        """Test the performance of the full conversion pipeline."""
>       preprocessor = DtsPreprocessor(
            include_paths=[str(Path(__file__).parent / "fixtures" / "dts" / "include")]
        )

tests/dts/test_performance.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <converter.dts.preprocessor.DtsPreprocessor object at 0x105ed68f0>
cpp_path = '/usr/bin/cpp'
include_paths = ['/Volumes/FlashGordon/Dropbox/code/nicktokatana/tests/dts/fixtures/dts/include']

    def __init__(
        self,
        cpp_path: Optional[str] = None,
        include_paths: Optional[List[str]] = None,
    ):
        """Initialize the preprocessor.
    
        Args:
            cpp_path: Path to the C preprocessor executable
            include_paths: List of paths to search for include files
        """
        if cpp_path is None:
            cpp_path = "/usr/bin/cpp"
        cpp_path = str(cpp_path)
        if not cpp_path.endswith("cpp"):
            raise PreprocessorError(
                "Invalid cpp path",
                help_text="The cpp path must point to a cpp executable",
            )
        self.cpp_path = Path(cpp_path)
    
        self.include_paths = []
        if include_paths:
            for path in include_paths:
                path_obj = Path(path)
                if not path_obj.exists():
                    msg = f"Include path does not exist: {path}"
                    help_text = "Ensure all include paths exist and are " "accessible"
>                   raise PreprocessorError(msg, help_text=help_text)
E                   converter.dts.preprocessor.PreprocessorError: Include path does not exist: /Volumes/FlashGordon/Dropbox/code/nicktokatana/tests/dts/fixtures/dts/include

converter/dts/preprocessor.py:77: PreprocessorError
=========================== short test summary info ============================
FAILED tests/dts/test_end_to_end.py::test_keymap_with_unicode - AssertionErro...
FAILED tests/dts/test_end_to_end.py::test_error_handling - AssertionError: Re...
FAILED tests/dts/test_extractor.py::test_extract_invalid_content - converter....
FAILED tests/dts/test_integration.py::test_full_pipeline_error_handling - con...
FAILED tests/dts/test_performance.py::test_preprocessor_performance - convert...
FAILED tests/dts/test_performance.py::test_parser_performance - converter.dts...
FAILED tests/dts/test_performance.py::test_extractor_performance - converter....
FAILED tests/dts/test_performance.py::test_full_pipeline_performance - conver...
========================= 8 failed, 64 passed in 0.68s =========================
