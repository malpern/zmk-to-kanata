============================= test session starts ==============================
platform darwin -- Python 3.10.16, pytest-8.3.4, pluggy-1.5.0 -- /Users/malpern/.pyenv/versions/3.10.16/bin/python3.10
cachedir: .pytest_cache
rootdir: /Volumes/FlashGordon/Dropbox/code/nicktokatana
configfile: pyproject.toml
testpaths: tests
plugins: anyio-4.7.0
collecting ... collected 72 items

tests/dts/test_ast.py::test_dts_property_creation PASSED                 [  1%]
tests/dts/test_ast.py::test_dts_node_creation PASSED                     [  2%]
tests/dts/test_ast.py::test_dts_node_find PASSED                         [  4%]
tests/dts/test_ast.py::test_dts_root_creation PASSED                     [  5%]
tests/dts/test_ast.py::test_dts_root_label_map PASSED                    [  6%]
tests/dts/test_end_to_end.py::test_simple_keymap PASSED                  [  8%]
tests/dts/test_end_to_end.py::test_complex_keymap_with_behaviors PASSED  [  9%]
tests/dts/test_end_to_end.py::test_keymap_with_unicode FAILED            [ 11%]
tests/dts/test_end_to_end.py::test_error_handling FAILED                 [ 12%]
tests/dts/test_end_to_end.py::test_keymap_with_combos PASSED             [ 13%]
tests/dts/test_end_to_end.py::test_keymap_with_conditional_layers PASSED [ 15%]
tests/dts/test_extractor.py::test_extract_simple_keymap PASSED           [ 16%]
tests/dts/test_extractor.py::test_extract_with_behaviors PASSED          [ 18%]
tests/dts/test_extractor.py::test_extract_multiple_layers PASSED         [ 19%]
tests/dts/test_extractor.py::test_extract_complex_bindings PASSED        [ 20%]
tests/dts/test_extractor.py::test_extract_invalid_content FAILED         [ 22%]
tests/dts/test_integration.py::test_full_pipeline_simple_keymap PASSED   [ 23%]
tests/dts/test_integration.py::test_full_pipeline_with_behaviors PASSED  [ 25%]
tests/dts/test_integration.py::test_full_pipeline_multiple_layers PASSED [ 26%]
tests/dts/test_integration.py::test_full_pipeline_complex_bindings PASSED [ 27%]
tests/dts/test_integration.py::test_full_pipeline_error_handling FAILED  [ 29%]
tests/dts/test_parser.py::test_parse_simple_dts PASSED                   [ 30%]
tests/dts/test_parser.py::test_parse_with_labels PASSED                  [ 31%]
tests/dts/test_parser.py::test_parse_with_references PASSED              [ 33%]
tests/dts/test_parser.py::test_parse_error_handling PASSED               [ 34%]
tests/dts/test_parser.py::test_parse_complex_dts PASSED                  [ 36%]
tests/dts/test_parser.py::test_parse_nested_nodes PASSED                 [ 37%]
tests/dts/test_parser.py::test_parse_multiple_labels PASSED              [ 38%]
tests/dts/test_parser.py::test_parse_complex_arrays PASSED               [ 40%]
tests/dts/test_parser.py::test_parse_boolean_properties PASSED           [ 41%]
tests/dts/test_parser.py::test_parse_empty_nodes_and_properties PASSED   [ 43%]
tests/dts/test_parser.py::test_parse_comments PASSED                     [ 44%]
tests/dts/test_parser.py::test_parse_zmk_specific_constructs PASSED      [ 45%]
tests/dts/test_parser.py::test_parse_array_with_mixed_cell_types_and_references PASSED [ 47%]
tests/dts/test_performance.py::test_preprocessor_performance FAILED      [ 48%]
tests/dts/test_performance.py::test_parser_performance FAILED            [ 50%]
tests/dts/test_performance.py::test_extractor_performance FAILED         [ 51%]
tests/dts/test_performance.py::test_full_pipeline_performance FAILED     [ 52%]
tests/dts/test_preprocessor.py::test_preprocessor_initialization PASSED  [ 54%]
tests/dts/test_preprocessor.py::test_preprocess_simple_file PASSED       [ 55%]
tests/dts/test_preprocessor.py::test_preprocess_with_matrix PASSED       [ 56%]
tests/dts/test_preprocessor.py::test_preprocess_with_includes PASSED     [ 58%]
tests/dts/test_preprocessor.py::test_preprocess_invalid_file PASSED      [ 59%]
tests/dts/test_preprocessor.py::test_preprocess_invalid_cpp_command PASSED [ 61%]
tests/dts/test_preprocessor.py::test_matrix_size_extraction PASSED       [ 62%]
tests/dts/test_preprocessor.py::test_preprocess_simple_keymap PASSED     [ 63%]
tests/dts/test_preprocessor.py::test_preprocess_with_include_paths PASSED [ 65%]
tests/dts/test_preprocessor.py::test_matrix_size_detection PASSED        [ 66%]
tests/dts/test_preprocessor.py::test_matrix_size_detection_no_matrix PASSED [ 68%]
tests/test_dts_parser.py::test_parse_simple_keymap PASSED                [ 69%]
tests/test_dts_parser.py::test_parse_large_keymap PASSED                 [ 70%]
tests/test_dts_parser.py::test_parse_simple_dts PASSED                   [ 72%]
tests/test_dts_parser.py::test_parse_with_labels PASSED                  [ 73%]
tests/test_dts_parser.py::test_parse_complex_bindings PASSED             [ 75%]
tests/test_dts_parser.py::test_parse_error_handling PASSED               [ 76%]
tests/test_dts_parser.py::test_parse_invalid_content PASSED              [ 77%]
tests/test_dts_parser.py::test_find_node PASSED                          [ 79%]
tests/test_dts_preprocessor.py::test_preprocessor PASSED                 [ 80%]
tests/test_dts_preprocessor.py::test_preprocessor_large_matrix PASSED    [ 81%]
tests/test_dts_preprocessor.py::test_preprocessor_error_handling PASSED  [ 83%]
tests/test_kanata_converter.py::test_convert_simple_keymap PASSED        [ 84%]
tests/test_kanata_converter.py::test_convert_large_keymap PASSED         [ 86%]
tests/test_kanata_converter.py::test_convert_multiple_layers PASSED      [ 87%]
tests/test_kanata_converter.py::test_convert_invalid_key_code PASSED     [ 88%]
tests/test_kanata_converter.py::test_convert_invalid_key_type PASSED     [ 90%]
tests/test_main.py::test_main_simple_conversion_stdout PASSED            [ 91%]
tests/test_main.py::test_main_simple_conversion_outfile PASSED           [ 93%]
tests/test_main.py::test_main_with_include PASSED                        [ 94%]
tests/test_main.py::test_main_input_file_not_found PASSED                [ 95%]
tests/test_main.py::test_main_invalid_dts PASSED                         [ 97%]
tests/test_main.py::test_main_no_args PASSED                             [ 98%]
tests/test_main.py::test_main_help PASSED                                [100%]

=================================== FAILURES ===================================
___________________________ test_keymap_with_unicode ___________________________

    def test_keymap_with_unicode():
        """Test parsing a keymap with unicode behaviors."""
        content = """
        / {
            behaviors {
                unicode: unicode {
                    compatible = "zmk,behavior-unicode";
                    #binding-cells = <1>;
                };
    
                uc_string: unicode_string {
                    compatible = "zmk,behavior-unicode-string";
                    #binding-cells = <1>;
                    strings = <
                        "smile" "ðŸ˜Š"
                        "heart" "â¤ï¸"
                    >;
                };
            };
    
            keymap {
                compatible = "zmk,keymap";
    
                default_layer {
                    bindings = <
                        &unicode U0001F600  &uc_string smile  &kp A
                        &unicode U2764      &uc_string heart  &kp B
                    >;
                };
            };
        };
        """
    
        # Parse and extract
        parser = DtsParser()
        ast = parser.parse(content)
    
        extractor = KeymapExtractor()
        config = extractor.extract(ast)
    
        # Verify behaviors
        assert len(config.behaviors) == 2
    
        unicode = next(b for b in config.behaviors.values() if b.name == "unicode")
        assert isinstance(unicode, Behavior)
    
        uc_string = next(b for b in config.behaviors.values() if b.name == "uc_string")
        assert isinstance(uc_string, Behavior)
    
        # Verify bindings
        layer_node = config.layers[0]
>       assert len(layer_node.bindings) == 6
E       AssertionError: assert 10 == 6
E        +  where 10 = len([Binding(behavior=Behavior(name='unicode', type='unicode'), params=[]), Binding(behavior=None, params=['U0001F600']), Binding(behavior=Behavior(name='uc_string', type='unicode_string'), params=[]), Binding(behavior=None, params=['smile']), Binding(behavior=None, params=['A']), Binding(behavior=Behavior(name='unicode', type='unicode'), params=[]), ...])
E        +    where [Binding(behavior=Behavior(name='unicode', type='unicode'), params=[]), Binding(behavior=None, params=['U0001F600']), Binding(behavior=Behavior(name='uc_string', type='unicode_string'), params=[]), Binding(behavior=None, params=['smile']), Binding(behavior=None, params=['A']), Binding(behavior=Behavior(name='unicode', type='unicode'), params=[]), ...] = Layer(name='default_layer', bindings=[Binding(behavior=Behavior(name='unicode', type='unicode'), params=[]), Binding(behavior=None, params=['U0001F600']), Binding(behavior=Behavior(name='uc_string', type='unicode_string'), params=[]), Binding(behavior=None, params=['smile']), Binding(behavior=None, params=['A']), Binding(behavior=Behavior(name='unicode', type='unicode'), params=[]), Binding(behavior=None, params=['U2764']), Binding(behavior=Behavior(name='uc_string', type='unicode_string'), params=[]), Binding(behavior=None, params=['heart']), Binding(behavior=None, params=['B'])], index=0).bindings

tests/dts/test_end_to_end.py:203: AssertionError
----------------------------- Captured stdout call -----------------------------
[DEBUG] i=147, char='1', depth=1, snippet=<1
[DEBUG] i=148, char='>', depth=1, snippet=<1>
[DEBUG] i=313, char='1', depth=1, snippet=<1
[DEBUG] i=314, char='>', depth=1, snippet=<1>
[DEBUG] i=344, char='\n', depth=1, snippet=<

[DEBUG] i=345, char=' ', depth=1, snippet=<
 
[DEBUG] i=346, char=' ', depth=1, snippet=<
  
[DEBUG] i=347, char=' ', depth=1, snippet=<
   
[DEBUG] i=348, char=' ', depth=1, snippet=<
    
[DEBUG] i=349, char=' ', depth=1, snippet=<
     
[DEBUG] i=350, char=' ', depth=1, snippet=<
      
[DEBUG] i=351, char=' ', depth=1, snippet=<
       
[DEBUG] i=352, char=' ', depth=1, snippet=<
        
[DEBUG] i=353, char=' ', depth=1, snippet=<
         
[DEBUG] i=354, char=' ', depth=1, snippet=<
          
[DEBUG] i=355, char=' ', depth=1, snippet=<
           
[DEBUG] i=356, char=' ', depth=1, snippet=<
            
[DEBUG] i=357, char=' ', depth=1, snippet=<
             
[DEBUG] i=358, char=' ', depth=1, snippet=<
              
[DEBUG] i=359, char=' ', depth=1, snippet=<
               
[DEBUG] i=360, char=' ', depth=1, snippet=<
                
[DEBUG] i=361, char=' ', depth=1, snippet=<
                 
[DEBUG] i=362, char=' ', depth=1, snippet=<
                  
[DEBUG] i=363, char=' ', depth=1, snippet=<
                   
[DEBUG] i=364, char=' ', depth=1, snippet=<
                    
[DEBUG] i=365, char='"', depth=1, snippet=<
                    "
[DEBUG] i=366, char='s', depth=1, snippet=<
                    "s
[DEBUG] i=367, char='m', depth=1, snippet=<
                    "sm
[DEBUG] i=368, char='i', depth=1, snippet=<
                    "smi
[DEBUG] i=369, char='l', depth=1, snippet=<
                    "smil
[DEBUG] i=370, char='e', depth=1, snippet=<
                    "smile
[DEBUG] i=371, char='"', depth=1, snippet=<
                    "smile"
[DEBUG] i=372, char=' ', depth=1, snippet=<
                    "smile" 
[DEBUG] i=373, char='"', depth=1, snippet=<
                    "smile" "
[DEBUG] i=374, char='ðŸ˜Š', depth=1, snippet=<
                    "smile" "ðŸ˜Š
[DEBUG] i=375, char='"', depth=1, snippet=<
                    "smile" "ðŸ˜Š"
[DEBUG] i=376, char='\n', depth=1, snippet=<
                    "smile" "ðŸ˜Š"

[DEBUG] i=377, char=' ', depth=1, snippet=<
                    "smile" "ðŸ˜Š"
 
[DEBUG] i=378, char=' ', depth=1, snippet=<
                    "smile" "ðŸ˜Š"
  
[DEBUG] i=379, char=' ', depth=1, snippet=<
                    "smile" "ðŸ˜Š"
   
[DEBUG] i=380, char=' ', depth=1, snippet=<
                    "smile" "ðŸ˜Š"
    
[DEBUG] i=381, char=' ', depth=1, snippet=<
                    "smile" "ðŸ˜Š"
     
[DEBUG] i=382, char=' ', depth=1, snippet=<
                    "smile" "ðŸ˜Š"
      
[DEBUG] i=383, char=' ', depth=1, snippet=<
                    "smile" "ðŸ˜Š"
       
[DEBUG] i=384, char=' ', depth=1, snippet=<
                    "smile" "ðŸ˜Š"
        
[DEBUG] i=385, char=' ', depth=1, snippet=<
                    "smile" "ðŸ˜Š"
         
[DEBUG] i=386, char=' ', depth=1, snippet=<
                    "smile" "ðŸ˜Š"
          
[DEBUG] i=387, char=' ', depth=1, snippet=<
                    "smile" "ðŸ˜Š"
           
[DEBUG] i=388, char=' ', depth=1, snippet=<
                    "smile" "ðŸ˜Š"
            
[DEBUG] i=389, char=' ', depth=1, snippet=<
                    "smile" "ðŸ˜Š"
             
[DEBUG] i=390, char=' ', depth=1, snippet=<
                    "smile" "ðŸ˜Š"
              
[DEBUG] i=391, char=' ', depth=1, snippet=<
                    "smile" "ðŸ˜Š"
               
[DEBUG] i=392, char=' ', depth=1, snippet=<
                    "smile" "ðŸ˜Š"
                
[DEBUG] i=393, char=' ', depth=1, snippet=<
                    "smile" "ðŸ˜Š"
                 
[DEBUG] i=394, char=' ', depth=1, snippet=<
                    "smile" "ðŸ˜Š"
                  
[DEBUG] i=395, char=' ', depth=1, snippet=<
                    "smile" "ðŸ˜Š"
                   
[DEBUG] i=396, char=' ', depth=1, snippet=<
                    "smile" "ðŸ˜Š"
                    
[DEBUG] i=397, char='"', depth=1, snippet=<
                    "smile" "ðŸ˜Š"
                    "
[DEBUG] i=398, char='h', depth=1, snippet=<
                    "smile" "ðŸ˜Š"
                    "h
[DEBUG] i=399, char='e', depth=1, snippet=<
                    "smile" "ðŸ˜Š"
                    "he
[DEBUG] i=400, char='a', depth=1, snippet=<
                    "smile" "ðŸ˜Š"
                    "hea
[DEBUG] i=401, char='r', depth=1, snippet=<
                    "smile" "ðŸ˜Š"
                    "hear
[DEBUG] i=402, char='t', depth=1, snippet=<
                    "smile" "ðŸ˜Š"
                    "heart
[DEBUG] i=403, char='"', depth=1, snippet=<
                    "smile" "ðŸ˜Š"
                    "heart"
[DEBUG] i=404, char=' ', depth=1, snippet=<
                    "smile" "ðŸ˜Š"
                    "heart" 
[DEBUG] i=405, char='"', depth=1, snippet=<
                    "smile" "ðŸ˜Š"
                    "heart" "
[DEBUG] i=406, char='â¤', depth=1, snippet=<
                    "smile" "ðŸ˜Š"
                    "heart" "â¤
[DEBUG] i=407, char='ï¸', depth=1, snippet=<
                    "smile" "ðŸ˜Š"
                    "heart" "â¤ï¸
[DEBUG] i=408, char='"', depth=1, snippet=<
                    "smile" "ðŸ˜Š"
                    "heart" "â¤ï¸"
[DEBUG] i=409, char='\n', depth=1, snippet=<
                    "smile" "ðŸ˜Š"
                    "heart" "â¤ï¸"

[DEBUG] i=410, char=' ', depth=1, snippet=<
                    "smile" "ðŸ˜Š"
                    "heart" "â¤ï¸"
 
[DEBUG] i=411, char=' ', depth=1, snippet=<
                    "smile" "ðŸ˜Š"
                    "heart" "â¤ï¸"
  
[DEBUG] i=412, char=' ', depth=1, snippet=<
                    "smile" "ðŸ˜Š"
                    "heart" "â¤ï¸"
   
[DEBUG] i=413, char=' ', depth=1, snippet=<
                    "smile" "ðŸ˜Š"
                    "heart" "â¤ï¸"
    
[DEBUG] i=414, char=' ', depth=1, snippet=<
                    "smile" "ðŸ˜Š"
                    "heart" "â¤ï¸"
     
[DEBUG] i=415, char=' ', depth=1, snippet=<
                    "smile" "ðŸ˜Š"
                    "heart" "â¤ï¸"
      
[DEBUG] i=416, char=' ', depth=1, snippet=<
                    "smile" "ðŸ˜Š"
                    "heart" "â¤ï¸"
       
[DEBUG] i=417, char=' ', depth=1, snippet=<
                    "smile" "ðŸ˜Š"
                    "heart" "â¤ï¸"
        
[DEBUG] i=418, char=' ', depth=1, snippet=<
                    "smile" "ðŸ˜Š"
                    "heart" "â¤ï¸"
         
[DEBUG] i=419, char=' ', depth=1, snippet=<
                    "smile" "ðŸ˜Š"
                    "heart" "â¤ï¸"
          
[DEBUG] i=420, char=' ', depth=1, snippet=<
                    "smile" "ðŸ˜Š"
                    "heart" "â¤ï¸"
           
[DEBUG] i=421, char=' ', depth=1, snippet=<
                    "smile" "ðŸ˜Š"
                    "heart" "â¤ï¸"
            
[DEBUG] i=422, char=' ', depth=1, snippet=<
                    "smile" "ðŸ˜Š"
                    "heart" "â¤ï¸"
             
[DEBUG] i=423, char=' ', depth=1, snippet=<
                    "smile" "ðŸ˜Š"
                    "heart" "â¤ï¸"
              
[DEBUG] i=424, char=' ', depth=1, snippet=<
                    "smile" "ðŸ˜Š"
                    "heart" "â¤ï¸"
               
[DEBUG] i=425, char=' ', depth=1, snippet=<
                    "smile" "ðŸ˜Š"
                    "heart" "â¤ï¸"
                
[DEBUG] i=426, char='>', depth=1, snippet=<
                    "smile" "ðŸ˜Š"
                    "heart" "â¤ï¸"
                >
[DEBUG] i=589, char='\n', depth=1, snippet=<

[DEBUG] i=590, char=' ', depth=1, snippet=<
 
[DEBUG] i=591, char=' ', depth=1, snippet=<
  
[DEBUG] i=592, char=' ', depth=1, snippet=<
   
[DEBUG] i=593, char=' ', depth=1, snippet=<
    
[DEBUG] i=594, char=' ', depth=1, snippet=<
     
[DEBUG] i=595, char=' ', depth=1, snippet=<
      
[DEBUG] i=596, char=' ', depth=1, snippet=<
       
[DEBUG] i=597, char=' ', depth=1, snippet=<
        
[DEBUG] i=598, char=' ', depth=1, snippet=<
         
[DEBUG] i=599, char=' ', depth=1, snippet=<
          
[DEBUG] i=600, char=' ', depth=1, snippet=<
           
[DEBUG] i=601, char=' ', depth=1, snippet=<
            
[DEBUG] i=602, char=' ', depth=1, snippet=<
             
[DEBUG] i=603, char=' ', depth=1, snippet=<
              
[DEBUG] i=604, char=' ', depth=1, snippet=<
               
[DEBUG] i=605, char=' ', depth=1, snippet=<
                
[DEBUG] i=606, char=' ', depth=1, snippet=<
                 
[DEBUG] i=607, char=' ', depth=1, snippet=<
                  
[DEBUG] i=608, char=' ', depth=1, snippet=<
                   
[DEBUG] i=609, char=' ', depth=1, snippet=<
                    
[DEBUG] i=610, char='&', depth=1, snippet=<
                    &
[DEBUG] i=611, char='u', depth=1, snippet=<
                    &u
[DEBUG] i=612, char='n', depth=1, snippet=<
                    &un
[DEBUG] i=613, char='i', depth=1, snippet=<
                    &uni
[DEBUG] i=614, char='c', depth=1, snippet=<
                    &unic
[DEBUG] i=615, char='o', depth=1, snippet=<
                    &unico
[DEBUG] i=616, char='d', depth=1, snippet=<
                    &unicod
[DEBUG] i=617, char='e', depth=1, snippet=<
                    &unicode
[DEBUG] i=618, char=' ', depth=1, snippet=<
                    &unicode 
[DEBUG] i=619, char='U', depth=1, snippet=<
                    &unicode U
[DEBUG] i=620, char='0', depth=1, snippet=<
                    &unicode U0
[DEBUG] i=621, char='0', depth=1, snippet=<
                    &unicode U00
[DEBUG] i=622, char='0', depth=1, snippet=<
                    &unicode U000
[DEBUG] i=623, char='1', depth=1, snippet=<
                    &unicode U0001
[DEBUG] i=624, char='F', depth=1, snippet=<
                    &unicode U0001F
[DEBUG] i=625, char='6', depth=1, snippet=<
                    &unicode U0001F6
[DEBUG] i=626, char='0', depth=1, snippet=<
                    &unicode U0001F60
[DEBUG] i=627, char='0', depth=1, snippet=<
                    &unicode U0001F600
[DEBUG] i=628, char=' ', depth=1, snippet=<
                    &unicode U0001F600 
[DEBUG] i=629, char=' ', depth=1, snippet=<
                    &unicode U0001F600  
[DEBUG] i=630, char='&', depth=1, snippet=<
                    &unicode U0001F600  &
[DEBUG] i=631, char='u', depth=1, snippet=<
                    &unicode U0001F600  &u
[DEBUG] i=632, char='c', depth=1, snippet=<
                    &unicode U0001F600  &uc
[DEBUG] i=633, char='_', depth=1, snippet=<
                    &unicode U0001F600  &uc_
[DEBUG] i=634, char='s', depth=1, snippet=<
                    &unicode U0001F600  &uc_s
[DEBUG] i=635, char='t', depth=1, snippet=<
                    &unicode U0001F600  &uc_st
[DEBUG] i=636, char='r', depth=1, snippet=<
                    &unicode U0001F600  &uc_str
[DEBUG] i=637, char='i', depth=1, snippet=<
                    &unicode U0001F600  &uc_stri
[DEBUG] i=638, char='n', depth=1, snippet=<
                    &unicode U0001F600  &uc_strin
[DEBUG] i=639, char='g', depth=1, snippet=<
                    &unicode U0001F600  &uc_string
[DEBUG] i=640, char=' ', depth=1, snippet=<
                    &unicode U0001F600  &uc_string 
[DEBUG] i=641, char='s', depth=1, snippet=<
                    &unicode U0001F600  &uc_string s
[DEBUG] i=642, char='m', depth=1, snippet=<
                    &unicode U0001F600  &uc_string sm
[DEBUG] i=643, char='i', depth=1, snippet=<
                    &unicode U0001F600  &uc_string smi
[DEBUG] i=644, char='l', depth=1, snippet=<
                    &unicode U0001F600  &uc_string smil
[DEBUG] i=645, char='e', depth=1, snippet=<
                    &unicode U0001F600  &uc_string smile
[DEBUG] i=646, char=' ', depth=1, snippet=<
                    &unicode U0001F600  &uc_string smile 
[DEBUG] i=647, char=' ', depth=1, snippet=<
                    &unicode U0001F600  &uc_string smile  
[DEBUG] i=648, char='&', depth=1, snippet=<
                    &unicode U0001F600  &uc_string smile  &
[DEBUG] i=649, char='k', depth=1, snippet=<
                    &unicode U0001F600  &uc_string smile  &k
[DEBUG] i=650, char='p', depth=1, snippet=<
                    &unicode U0001F600  &uc_string smile  &kp
[DEBUG] i=651, char=' ', depth=1, snippet=<
                    &unicode U0001F600  &uc_string smile  &kp 
[DEBUG] i=652, char='A', depth=1, snippet=<
                    &unicode U0001F600  &uc_string smile  &kp A
[DEBUG] i=653, char='\n', depth=1, snippet=<
                    &unicode U0001F600  &uc_string smile  &kp A

[DEBUG] i=654, char=' ', depth=1, snippet=<
                    &unicode U0001F600  &uc_string smile  &kp A
 
[DEBUG] i=655, char=' ', depth=1, snippet=<
                    &unicode U0001F600  &uc_string smile  &kp A
  
[DEBUG] i=656, char=' ', depth=1, snippet=<
                    &unicode U0001F600  &uc_string smile  &kp A
   
[DEBUG] i=657, char=' ', depth=1, snippet=<
                    &unicode U0001F600  &uc_string smile  &kp A
    
[DEBUG] i=658, char=' ', depth=1, snippet=<
                    &unicode U0001F600  &uc_string smile  &kp A
     
[DEBUG] i=659, char=' ', depth=1, snippet=<
                    &unicode U0001F600  &uc_string smile  &kp A
      
[DEBUG] i=660, char=' ', depth=1, snippet=<
                    &unicode U0001F600  &uc_string smile  &kp A
       
[DEBUG] i=661, char=' ', depth=1, snippet=<
                    &unicode U0001F600  &uc_string smile  &kp A
        
[DEBUG] i=662, char=' ', depth=1, snippet=<
                    &unicode U0001F600  &uc_string smile  &kp A
         
[DEBUG] i=663, char=' ', depth=1, snippet=<
                    &unicode U0001F600  &uc_string smile  &kp A
          
[DEBUG] i=664, char=' ', depth=1, snippet=<
                    &unicode U0001F600  &uc_string smile  &kp A
           
[DEBUG] i=665, char=' ', depth=1, snippet=<
                    &unicode U0001F600  &uc_string smile  &kp A
            
[DEBUG] i=666, char=' ', depth=1, snippet=<
                    &unicode U0001F600  &uc_string smile  &kp A
             
[DEBUG] i=667, char=' ', depth=1, snippet=<
                    &unicode U0001F600  &uc_string smile  &kp A
              
[DEBUG] i=668, char=' ', depth=1, snippet=<
                    &unicode U0001F600  &uc_string smile  &kp A
               
[DEBUG] i=669, char=' ', depth=1, snippet=<
                    &unicode U0001F600  &uc_string smile  &kp A
                
[DEBUG] i=670, char=' ', depth=1, snippet=<
                    &unicode U0001F600  &uc_string smile  &kp A
                 
[DEBUG] i=671, char=' ', depth=1, snippet=<
                    &unicode U0001F600  &uc_string smile  &kp A
                  
[DEBUG] i=672, char=' ', depth=1, snippet=<
                    &unicode U0001F600  &uc_string smile  &kp A
                   
[DEBUG] i=673, char=' ', depth=1, snippet=<
                    &unicode U0001F600  &uc_string smile  &kp A
                    
[DEBUG] i=674, char='&', depth=1, snippet=<
                    &unicode U0001F600  &uc_string smile  &kp A
                    &
[DEBUG] i=675, char='u', depth=1, snippet=<
                    &unicode U0001F600  &uc_string smile  &kp A
                    &u
[DEBUG] i=676, char='n', depth=1, snippet=<
                    &unicode U0001F600  &uc_string smile  &kp A
                    &un
[DEBUG] i=677, char='i', depth=1, snippet=<
                    &unicode U0001F600  &uc_string smile  &kp A
                    &uni
[DEBUG] i=678, char='c', depth=1, snippet=<
                    &unicode U0001F600  &uc_string smile  &kp A
                    &unic
[DEBUG] i=679, char='o', depth=1, snippet=<
                    &unicode U0001F600  &uc_string smile  &kp A
                    &unico
[DEBUG] i=680, char='d', depth=1, snippet=<
                    &unicode U0001F600  &uc_string smile  &kp A
                    &unicod
[DEBUG] i=681, char='e', depth=1, snippet=<
                    &unicode U0001F600  &uc_string smile  &kp A
                    &unicode
[DEBUG] i=682, char=' ', depth=1, snippet=<
                    &unicode U0001F600  &uc_string smile  &kp A
                    &unicode 
[DEBUG] i=683, char='U', depth=1, snippet=<
                    &unicode U0001F600  &uc_string smile  &kp A
                    &unicode U
[DEBUG] i=684, char='2', depth=1, snippet=<
                    &unicode U0001F600  &uc_string smile  &kp A
                    &unicode U2
[DEBUG] i=685, char='7', depth=1, snippet=<
                    &unicode U0001F600  &uc_string smile  &kp A
                    &unicode U27
[DEBUG] i=686, char='6', depth=1, snippet=<
                    &unicode U0001F600  &uc_string smile  &kp A
                    &unicode U276
[DEBUG] i=687, char='4', depth=1, snippet=<
                    &unicode U0001F600  &uc_string smile  &kp A
                    &unicode U2764
Added layer default_layer: Layer(name='default_layer', bindings=[Binding(behavior=Behavior(name='unicode', type='unicode'), params=[]), Binding(behavior=None, params=['U0001F600']), Binding(behavior=Behavior(name='uc_string', type='unicode_string'), params=[]), Binding(behavior=None, params=['smile']), Binding(behavior=None, params=['A']), Binding(behavior=Behavior(name='unicode', type='unicode'), params=[]), Binding(behavior=None, params=['U2764']), Binding(behavior=Behavior(name='uc_string', type='unicode_string'), params=[]), Binding(behavior=None, params=['heart']), Binding(behavior=None, params=['B'])], index=0)
_____________________________ test_error_handling ______________________________

    def test_error_handling():
        """Test error handling with malformed input."""
        # Test missing root node
        with pytest.raises(DtsParseError, match="DTS must start with root node"):
            parser = DtsParser()
            parser.parse("keymap { };")
    
        # Test invalid property assignment
        with pytest.raises(DtsParseError, match="Invalid property value: value"):
            parser = DtsParser()
            parser.parse(
                """
            / {
                keymap {
                    prop = value
                };
            };
            """
            )
    
        # Test invalid binding format
        parser = DtsParser()
        ast = parser.parse(
            """
        / {
            keymap {
                default_layer {
                    bindings = <&invalid_binding>;
                };
            };
        };
        """
        )
        extractor = KeymapExtractor()
        with pytest.raises(ValueError, match="Invalid binding format: invalid_binding"):
>           extractor.extract(ast)

tests/dts/test_end_to_end.py:247: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
converter/dts/extractor.py:77: in extract
    self._extract_layers(keymap_node)
converter/dts/extractor.py:300: in _extract_layers
    layer = self._create_layer(child, idx)
converter/dts/extractor.py:319: in _create_layer
    parsed_bindings = self._parse_bindings(bindings_prop.value)
converter/dts/extractor.py:362: in _parse_bindings
    bindings.append(self._create_binding([behavior_name] + params))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <converter.dts.extractor.KeymapExtractor object at 0x10643c5e0>
value = ['invalid_binding']

    def _create_binding(self, value: str | List[str]) -> Binding:
        """Create a binding instance from a value."""
        if isinstance(value, list):
            # Handle list format [behavior_name, param1, ...]
            if not value:
                raise ValueError("Empty binding list value")
            behavior_name = value[0]
            params = value[1:]
    
            if behavior_name == "kp":
                if len(params) != 1:
                    raise ValueError(
                        f"kp behavior expects 1 parameter, "
                        f"got {len(params)}: {params}"
                    )
                # Ensure params is always a list
                return Binding(behavior=None, params=[params[0]])  # Wrap param
    
            # Look up custom behavior - should exist now
            behavior = self.behaviors.get(behavior_name)
            if behavior:
                # TODO: Validate params against behavior definition if needed
                return Binding(behavior=behavior, params=params)
            else:
                # This shouldn't happen if pass logic is correct
>               raise ValueError(
                    f"Unknown behavior referenced during binding creation: "
                    f"{behavior_name}"
                )
E               ValueError: Unknown behavior referenced during binding creation: invalid_binding

converter/dts/extractor.py:395: ValueError

During handling of the above exception, another exception occurred:

    def test_error_handling():
        """Test error handling with malformed input."""
        # Test missing root node
        with pytest.raises(DtsParseError, match="DTS must start with root node"):
            parser = DtsParser()
            parser.parse("keymap { };")
    
        # Test invalid property assignment
        with pytest.raises(DtsParseError, match="Invalid property value: value"):
            parser = DtsParser()
            parser.parse(
                """
            / {
                keymap {
                    prop = value
                };
            };
            """
            )
    
        # Test invalid binding format
        parser = DtsParser()
        ast = parser.parse(
            """
        / {
            keymap {
                default_layer {
                    bindings = <&invalid_binding>;
                };
            };
        };
        """
        )
        extractor = KeymapExtractor()
>       with pytest.raises(ValueError, match="Invalid binding format: invalid_binding"):
E       AssertionError: Regex pattern did not match.
E        Regex: 'Invalid binding format: invalid_binding'
E        Input: 'Unknown behavior referenced during binding creation: invalid_binding'

tests/dts/test_end_to_end.py:246: AssertionError
----------------------------- Captured stdout call -----------------------------
[DEBUG] i=82, char='&', depth=1, snippet=<&
[DEBUG] i=83, char='i', depth=1, snippet=<&i
[DEBUG] i=84, char='n', depth=1, snippet=<&in
[DEBUG] i=85, char='v', depth=1, snippet=<&inv
[DEBUG] i=86, char='a', depth=1, snippet=<&inva
[DEBUG] i=87, char='l', depth=1, snippet=<&inval
[DEBUG] i=88, char='i', depth=1, snippet=<&invali
[DEBUG] i=89, char='d', depth=1, snippet=<&invalid
[DEBUG] i=90, char='_', depth=1, snippet=<&invalid_
[DEBUG] i=91, char='b', depth=1, snippet=<&invalid_b
[DEBUG] i=92, char='i', depth=1, snippet=<&invalid_bi
[DEBUG] i=93, char='n', depth=1, snippet=<&invalid_bin
[DEBUG] i=94, char='d', depth=1, snippet=<&invalid_bind
[DEBUG] i=95, char='i', depth=1, snippet=<&invalid_bindi
[DEBUG] i=96, char='n', depth=1, snippet=<&invalid_bindin
[DEBUG] i=97, char='g', depth=1, snippet=<&invalid_binding
[DEBUG] i=98, char='>', depth=1, snippet=<&invalid_binding>
_________________________ test_extract_invalid_content _________________________

    def test_extract_invalid_content():
        """Test extracting invalid content."""
        content = """
        / {
            keymap {
                invalid_layer {
                    # Missing bindings
                };
            };
        };
        """
    
        parser = DtsParser()
>       ast = parser.parse(content)

tests/dts/test_extractor.py:166: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
converter/dts/parser.py:76: in parse
    self._parse_node_body(parsed_root_node)
converter/dts/parser.py:545: in _parse_node_body
    self._parse_node_body(child)
converter/dts/parser.py:545: in _parse_node_body
    self._parse_node_body(child)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <converter.dts.parser.DtsParser object at 0x1064405e0>
node = DtsNode(name='invalid_layer', parent=None, children={}, properties={}, labels={})

    def _parse_node_body(self, node: DtsNode) -> None:
        """Parse the body of a DTS node.
    
        Args:
            node: DtsNode to parse body into
    
        Raises:
            DtsParseError: If node body format is invalid
        """
        while self.pos < len(self.tokens):
            token = self.tokens[self.pos]
    
            if token == "}":
                self.pos += 1
                return
            elif token == "{":
                line, col = self._get_pos_info(self.pos)
                raise DtsParseError(
                    "Unexpected '{' in node body",
                    line=line,
                    column=col,
                    context=format_error_context(self.content, line, col),
                    help_text="Node definitions must have a label or reference",
                )
    
            if token == ";":  # Handle empty statements
                self.pos += 1
                continue
    
            # Handle boolean properties (e.g., "prop_name;")
            if self.pos + 1 < len(self.tokens) and self.tokens[self.pos + 1] == ";":
                name = token
                # Basic check for valid property name (alphanumeric, _, -)
                # This helps distinguish from stray semicolons or other constructs.
                # The tokenizer should ideally guarantee 'token' is a potential identifier here.
                if (
                    name
                    and all(c.isalnum() or c in ("_", "-", "#") for c in name)
                    and (name[0].isalpha() or name[0] == "#" or name[0] == "_")
                ):
                    prop = DtsProperty(name=name, value=True, type="boolean")
                    node.add_property(prop)
                    self.pos += 2  # Consume name and ';'
                    continue
    
            # Handle properties with assignment (e.g. "prop_name = value;")
            if self.pos + 2 < len(self.tokens) and self.tokens[self.pos + 1] == "=":
                name = token
                value_token = self.tokens[self.pos + 2]
                try:
                    prop = self._parse_property_value(name, value_token)
                    node.add_property(prop)
                    self.pos += 3
    
                    # Check for additional comma-separated array cells
                    if prop.type == "array":
                        while (
                            self.pos < len(self.tokens) and self.tokens[self.pos] == ","
                        ):
                            self.pos += 1
                            if self.pos >= len(self.tokens):
                                line, col = self._get_pos_info(self.pos - 1)
                                raise DtsParseError(
                                    "Unexpected end of file after ',' in property value",
                                    line=line,
                                    column=col,
                                    context=format_error_context(
                                        self.content, line, col
                                    ),
                                )
                            next_value_token = self.tokens[self.pos]
                            # Parse the next array cell. We expect it to be an array itself.
                            # _parse_property_value will return a DtsProperty, we need its value.
                            additional_prop_part = self._parse_property_value(
                                "_{temp}", next_value_token
                            )
                            if additional_prop_part.type == "array":
                                if isinstance(prop.value, list) and isinstance(
                                    additional_prop_part.value, list
                                ):
                                    prop.value.extend(additional_prop_part.value)
                                else:
                                    # This case should ideally not happen if tokens are well-formed <...>
                                    line, col = self._get_pos_info(self.pos)
                                    raise DtsParseError(
                                        f"Expected array type for subsequent part of property '{name}'",
                                        line=line,
                                        column=col,
                                        context=format_error_context(
                                            self.content, line, col
                                        ),
                                    )
                            else:
                                line, col = self._get_pos_info(self.pos)
                                raise DtsParseError(
                                    f"Expected array for subsequent part of property '{name}', got {additional_prop_part.type}",
                                    line=line,
                                    column=col,
                                    context=format_error_context(
                                        self.content, line, col
                                    ),
                                )
                            self.pos += 1
                except DtsParseError as e:
                    if not e.help_text:
                        e.help_text = f"Invalid value for property '{name}'"
                    raise
                if self.pos >= len(self.tokens) or self.tokens[self.pos] != ";":
                    line, col = self._get_pos_info(self.pos)
                    raise DtsParseError(
                        "Expected ';' after property value",
                        line=line,
                        column=col,
                        context=format_error_context(self.content, line, col),
                        help_text="Property definitions must end with a semicolon",
                    )
                self.pos += 1
                continue
    
            # Handle child nodes. At this point, 'token' is either a node name or a label.
            current_labels_for_node: List[str] = []
            current_token = token  # Start with the first token we haven't processed as property/etc.
    
            # Loop to gather all labels: label1: label2: ... node_name
            while self.pos + 1 < len(self.tokens) and self.tokens[self.pos + 1] == ":":
                # Current token is a label
                current_labels_for_node.append(current_token)
                self.pos += 2  # Consume label and ':'
                if self.pos >= len(self.tokens):
                    line, col = self._get_pos_info(self.pos - 1)
                    raise DtsParseError(
                        "Unexpected end of file after label expecting node name or another label",
                        line=line,
                        column=col,
                        context=format_error_context(self.content, line, col),
                    )
                current_token = self.tokens[
                    self.pos
                ]  # This is the next potential label or the actual node name
    
            # After the loop, current_token is the actual node name
            actual_node_name = current_token
            self.pos += 1  # Consume the actual_node_name token
    
            child = DtsNode(name=actual_node_name)
            for lbl in current_labels_for_node:
                child.add_label(lbl)
    
            if self.pos >= len(self.tokens) or self.tokens[self.pos] != "{":
                line, col = self._get_pos_info(self.pos)
                # Provide more context in error: what token did we actually find?
                found_token_msg = (
                    f"Found '{self.tokens[self.pos]}' instead."
                    if self.pos < len(self.tokens)
                    else "Found end of input."
                )
>               raise DtsParseError(
                    f"Expected '{{ ' after node '{actual_node_name}'. {found_token_msg}",
                    line=line,
                    column=col,
                    context=format_error_context(self.content, line, col),
                    help_text="Node definitions must be enclosed in curly braces and start with '{'.",
                )
E               converter.dts.error_handler.DtsParseError: Expected '{ ' after node '#'. Found 'Missing' instead. at line 6, column -34
E               
E               4 |             invalid_layer {
E               5 |                 # Missing bindings
E               6 |             };
E                 | ^
E               7 |         };
E               8 |     };
E               
E               Help: Node definitions must be enclosed in curly braces and start with '{'.

converter/dts/parser.py:536: DtsParseError
______________________ test_full_pipeline_error_handling _______________________

    def test_full_pipeline_error_handling():
        """Test error handling in the full pipeline."""
        # Test missing root node
        content = "node1 { };"
        parser = DtsParser()
        with pytest.raises(ValueError, match="Expected root node"):
>           parser.parse(content)

tests/dts/test_integration.py:212: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <converter.dts.parser.DtsParser object at 0x10647dc90>
content = 'node1 { };', file = None

    def parse(self, content: str, file: Optional[str] = None) -> DtsRoot:
        """Parse DTS content into an AST.
    
        Args:
            content: DTS content string
            file: Optional file path for error reporting
    
        Returns:
            DtsRoot object representing the parsed AST
    
        Raises:
            DtsParseError: If the content is not valid DTS
        """
        # Remove preprocessor line markers (lines starting with '# <digit>')
        content = "\n".join(
            line
            for line in content.splitlines()
            if not (
                line.lstrip().startswith("#")
                and line.lstrip()[1:2] == " "
                and line.lstrip()[2:3].isdigit()
            )
        )
        self.content = content
        self.tokens = []
        self.line_map = []
        self._tokenize(content)
        self.pos = 0
    
        # Check for root node token '/'
        if not self.tokens or self.tokens[0] != "/":
>           raise DtsParseError(
                "DTS must start with root node '/'",
                file=file,
                line=1,
                column=1,
                context=format_error_context(content, 1, 1),
            )
E           converter.dts.error_handler.DtsParseError: DTS must start with root node '/' at line 1, column 1
E           
E           1 | node1 { };
E             | ^
E           
E           Help: Check the DTS syntax and ensure it follows the specification.

converter/dts/parser.py:49: DtsParseError
________________________ test_preprocessor_performance _________________________

self = <converter.dts.preprocessor.DtsPreprocessor object at 0x1064c4e50>
input_path = PosixPath('/Volumes/FlashGordon/Dropbox/code/nicktokatana/tests/fixtures/dts/complex_keymap.zmk')
matrix_size = None

    def preprocess(
        self,
        input_path: str,
        matrix_size: Optional[Tuple[int, int]] = None,
    ) -> str:
        """Preprocess a DTS file.
    
        Args:
            input_path: Path to the input file
            matrix_size: Optional tuple of (rows, cols) for matrix transform
    
        Returns:
            The preprocessed content as a string
    
        Raises:
            PreprocessorError: If preprocessing fails
        """
        input_path = Path(input_path)
        if not input_path.exists():
            raise PreprocessorError(
                f"Input file does not exist: {input_path}",
                help_text=(
                    "Ensure the input file exists and has proper " "read permissions"
                ),
            )
    
        try:
            with open(input_path, "r") as f:
                content_for_cpp = f.read()
        except Exception as e:
            raise PreprocessorError(
                f"Failed to read input file: {str(e)}",
                file=str(input_path),
                help_text=("Ensure the file exists and has proper " "read permissions"),
            )
    
        # Create a temporary file for the preprocessor input
        tmp_input = tempfile.NamedTemporaryFile(
            mode="w",
            delete=False,
            suffix=".dts",
            dir=None,  # Use system default temp dir (usually /tmp)
        )
        tmp_input.write(content_for_cpp)
        tmp_input.close()
        tmp_input_file = Path(tmp_input.name)
    
        # Debug: print environment and temp file contents
        print("[DtsPreprocessor] ENVIRONMENT:")
        for k, v in os.environ.items():
            if len(v) > 40:
                print(f"  {k}={v[:20]}...{v[-20:]}")
            else:
                print(f"  {k}={v}")
        if len(str(tmp_input_file)) > 70:
            print(f"[DtsPreprocessor] Temp file: " f"{str(tmp_input_file)[:70]}...")
        else:
            print(f"[DtsPreprocessor] Temp file: {tmp_input_file}")
        with open(tmp_input_file, "r") as f:
            print("[DtsPreprocessor] Temp file contents:")
            print(f.read())
    
        try:
            # Build preprocessor command as a list for shell=False
            if os.uname().sysname == "Darwin":
                # Use clang with assembler-with-cpp for .dts files on macOS
                clang_path = "/usr/bin/clang"
                cpp_cmd = [
                    clang_path,
                    "-E",
                    "-nostdinc",
                    "-undef",
                    "-x",
                    "assembler-with-cpp",
                ]
                for path in self.include_paths:
                    cpp_cmd.extend(["-I", str(path)])
                cpp_cmd.append(str(tmp_input_file))
            else:
                cpp_cmd = [
                    str(self.cpp_path),
                    "-E",
                ]
                for path in self.include_paths:
                    cpp_cmd.extend(["-I", str(path)])
                cpp_cmd.extend(["-x", "c", str(tmp_input_file)])
    
            # Debug: print the constructed command list
            print("[DtsPreprocessor] cpp command:", cpp_cmd)
    
            # Run preprocessor with shell=False
            try:
>               result = subprocess.run(
                    cpp_cmd,
                    capture_output=True,
                    text=True,
                    check=True,
                    shell=False,
                )

converter/dts/preprocessor.py:214: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = None, capture_output = True, timeout = None, check = True
popenargs = (['/usr/bin/clang', '-E', '-nostdinc', '-undef', '-x', 'assembler-with-cpp', ...],)
kwargs = {'shell': False, 'stderr': -1, 'stdout': -1, 'text': True}
process = <Popen: returncode: 1 args: ['/usr/bin/clang', '-E', '-nostdinc', '-undef', ...>
stdout = '# 1 "/var/folders/0s/42v7yl697hn0l1cdnx0vrvyr0000gn/T/tmprc5biy15.dts"\n# 1 "<built-in>" 1\n# 1 "<built-in>" 3\n\n\n\...yers";\n\n        tri_layer {\n            if-layers = <1 2>;\n            then-layer = <3>;\n        };\n    };\n};\n'
stderr = "/var/folders/0s/42v7yl697hn0l1cdnx0vrvyr0000gn/T/tmprc5biy15.dts:1:10: fatal error: 'dt-bindings/zmk/matrix_transform...lude <dt-bindings/zmk/matrix_transform.h>\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n1 error generated.\n"
retcode = 1

    def run(*popenargs,
            input=None, capture_output=False, timeout=None, check=False, **kwargs):
        """Run command with arguments and return a CompletedProcess instance.
    
        The returned instance will have attributes args, returncode, stdout and
        stderr. By default, stdout and stderr are not captured, and those attributes
        will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them,
        or pass capture_output=True to capture both.
    
        If check is True and the exit code was non-zero, it raises a
        CalledProcessError. The CalledProcessError object will have the return code
        in the returncode attribute, and output & stderr attributes if those streams
        were captured.
    
        If timeout is given, and the process takes too long, a TimeoutExpired
        exception will be raised.
    
        There is an optional argument "input", allowing you to
        pass bytes or a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it will be used internally.
    
        By default, all communication is in bytes, and therefore any "input" should
        be bytes, and the stdout and stderr will be bytes. If in text mode, any
        "input" should be a string, and stdout and stderr will be strings decoded
        according to locale encoding, or by "encoding" if set. Text mode is
        triggered by setting any of text, encoding, errors or universal_newlines.
    
        The other arguments are the same as for the Popen constructor.
        """
        if input is not None:
            if kwargs.get('stdin') is not None:
                raise ValueError('stdin and input arguments may not both be used.')
            kwargs['stdin'] = PIPE
    
        if capture_output:
            if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:
                raise ValueError('stdout and stderr arguments may not be used '
                                 'with capture_output.')
            kwargs['stdout'] = PIPE
            kwargs['stderr'] = PIPE
    
        with Popen(*popenargs, **kwargs) as process:
            try:
                stdout, stderr = process.communicate(input, timeout=timeout)
            except TimeoutExpired as exc:
                process.kill()
                if _mswindows:
                    # Windows accumulates the output in a single blocking
                    # read() call run on child threads, with the timeout
                    # being done in a join() on those threads.  communicate()
                    # _after_ kill() is required to collect that and add it
                    # to the exception.
                    exc.stdout, exc.stderr = process.communicate()
                else:
                    # POSIX _communicate already populated the output so
                    # far into the TimeoutExpired exception.
                    process.wait()
                raise
            except:  # Including KeyboardInterrupt, communicate handled that.
                process.kill()
                # We don't call process.wait() as .__exit__ does that for us.
                raise
            retcode = process.poll()
            if check and retcode:
>               raise CalledProcessError(retcode, process.args,
                                         output=stdout, stderr=stderr)
E               subprocess.CalledProcessError: Command '['/usr/bin/clang', '-E', '-nostdinc', '-undef', '-x', 'assembler-with-cpp', '/var/folders/0s/42v7yl697hn0l1cdnx0vrvyr0000gn/T/tmprc5biy15.dts']' returned non-zero exit status 1.

/Users/malpern/.pyenv/versions/3.10.16/lib/python3.10/subprocess.py:526: CalledProcessError

During handling of the above exception, another exception occurred:

sample_keymap_path = '/Volumes/FlashGordon/Dropbox/code/nicktokatana/tests/fixtures/dts/complex_keymap.zmk'

    def test_preprocessor_performance(sample_keymap_path):
        """Test the performance of the preprocessor."""
        preprocessor = DtsPreprocessor()
    
        # Run multiple times to get stable measurements
        times = []
        for _ in range(10):
>           _, duration = measure_time(preprocessor.preprocess, sample_keymap_path)

tests/dts/test_performance.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/dts/test_performance.py:16: in measure_time
    result = func(*args, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <converter.dts.preprocessor.DtsPreprocessor object at 0x1064c4e50>
input_path = PosixPath('/Volumes/FlashGordon/Dropbox/code/nicktokatana/tests/fixtures/dts/complex_keymap.zmk')
matrix_size = None

    def preprocess(
        self,
        input_path: str,
        matrix_size: Optional[Tuple[int, int]] = None,
    ) -> str:
        """Preprocess a DTS file.
    
        Args:
            input_path: Path to the input file
            matrix_size: Optional tuple of (rows, cols) for matrix transform
    
        Returns:
            The preprocessed content as a string
    
        Raises:
            PreprocessorError: If preprocessing fails
        """
        input_path = Path(input_path)
        if not input_path.exists():
            raise PreprocessorError(
                f"Input file does not exist: {input_path}",
                help_text=(
                    "Ensure the input file exists and has proper " "read permissions"
                ),
            )
    
        try:
            with open(input_path, "r") as f:
                content_for_cpp = f.read()
        except Exception as e:
            raise PreprocessorError(
                f"Failed to read input file: {str(e)}",
                file=str(input_path),
                help_text=("Ensure the file exists and has proper " "read permissions"),
            )
    
        # Create a temporary file for the preprocessor input
        tmp_input = tempfile.NamedTemporaryFile(
            mode="w",
            delete=False,
            suffix=".dts",
            dir=None,  # Use system default temp dir (usually /tmp)
        )
        tmp_input.write(content_for_cpp)
        tmp_input.close()
        tmp_input_file = Path(tmp_input.name)
    
        # Debug: print environment and temp file contents
        print("[DtsPreprocessor] ENVIRONMENT:")
        for k, v in os.environ.items():
            if len(v) > 40:
                print(f"  {k}={v[:20]}...{v[-20:]}")
            else:
                print(f"  {k}={v}")
        if len(str(tmp_input_file)) > 70:
            print(f"[DtsPreprocessor] Temp file: " f"{str(tmp_input_file)[:70]}...")
        else:
            print(f"[DtsPreprocessor] Temp file: {tmp_input_file}")
        with open(tmp_input_file, "r") as f:
            print("[DtsPreprocessor] Temp file contents:")
            print(f.read())
    
        try:
            # Build preprocessor command as a list for shell=False
            if os.uname().sysname == "Darwin":
                # Use clang with assembler-with-cpp for .dts files on macOS
                clang_path = "/usr/bin/clang"
                cpp_cmd = [
                    clang_path,
                    "-E",
                    "-nostdinc",
                    "-undef",
                    "-x",
                    "assembler-with-cpp",
                ]
                for path in self.include_paths:
                    cpp_cmd.extend(["-I", str(path)])
                cpp_cmd.append(str(tmp_input_file))
            else:
                cpp_cmd = [
                    str(self.cpp_path),
                    "-E",
                ]
                for path in self.include_paths:
                    cpp_cmd.extend(["-I", str(path)])
                cpp_cmd.extend(["-x", "c", str(tmp_input_file)])
    
            # Debug: print the constructed command list
            print("[DtsPreprocessor] cpp command:", cpp_cmd)
    
            # Run preprocessor with shell=False
            try:
                result = subprocess.run(
                    cpp_cmd,
                    capture_output=True,
                    text=True,
                    check=True,
                    shell=False,
                )
            except subprocess.CalledProcessError as e:
>               raise PreprocessorError(
                    "Failed to process DTS directives",
                    file=str(input_path),
                    context=str(e),
                    help_text=("Check for malformed DTS directives in " "input file"),
                )
E               converter.dts.preprocessor.PreprocessorError: Failed to process DTS directives

converter/dts/preprocessor.py:222: PreprocessorError
----------------------------- Captured stdout call -----------------------------
[DtsPreprocessor] ENVIRONMENT:
  MallocNanoZone=0
  USER=malpern
  SECURITYSESSIONID=186a3
  COMMAND_MODE=unix2003
  __CFBundleIdentifier=com.todesktop.230313mzl4w4u92
  PATH=/Users/malpern/.curs....cache/lm-studio/bin
  LOGNAME=malpern
  SSH_AUTH_SOCK=/private/tmp/com.app...x1qskoux7b/Listeners
  HOME=/Users/malpern
  SHELL=/bin/zsh
  TMPDIR=/var/folders/0s/42v7...1cdnx0vrvyr0000gn/T/
  LaunchInstanceID=BFD4BF06-15BD-4F76-8D8A-1AEC50E6795A
  __CF_USER_TEXT_ENCODING=0x1F5:0x0:0x0
  XPC_SERVICE_NAME=0
  XPC_FLAGS=0x0
  ORIGINAL_XDG_CURRENT_DESKTOP=undefined
  CURSOR_TRACE_ID=f5e099fd466543c5a0d391e03a641e89
  SHLVL=1
  PWD=/Volumes/FlashGordon...ox/code/nicktokatana
  OLDPWD=/Volumes/FlashGordon...ox/code/nicktokatana
  HOMEBREW_PREFIX=/opt/homebrew
  HOMEBREW_CELLAR=/opt/homebrew/Cellar
  HOMEBREW_REPOSITORY=/opt/homebrew
  INFOPATH=/opt/homebrew/share/...homebrew/share/info:
  YOUR_CONSUMER_KEY=ah6HAffNJRCv4xNrV4OZcVIrQ
  YOUR_CONSUMER_SECRET=EXM9IzH9IEdE2yJf0t5F...DPuFXLk55DwB8pLRswR5
  YOUR_ACCESS_TOKEN=1483-5UbadNrxZUkJpAp...JSXPVSxtsPwJyrUrZvcO
  YOUR_ACCESS_TOKEN_SECRET=jeyyEWPHAgoS0ebKus4t...0jH2T3gRCIz3dsYXQwqS
  YOUR_BEARER_TOKEN=AAAAAAAAAAAAAAAAAAAA...8YVAWCOQu6Pyu4yhuY0a
  OPENAI_API_KEY=sk-qVQDNdwpfPhrAvFr9...ob362AQbhWVa3p95yD28
  ANTHROPIC_API_KEY=sk-ant-api03-Tq7nYRm...SCuUoAfwIQg-NWFWuAAA
  TAVILY_API_KEY=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
  BING_SUBSCRIPTION_KEY=bec8ded0f34a421ba60cc3bd4626825e
  EDITOR=vi
  ZSH=/Users/malpern/.oh-my-zsh
  PAGER=head -n 10000 | cat
  LESS=-R
  LSCOLORS=Gxfxcxdxbxegedabagacad
  LS_COLORS=di=1;36:ln=35:so=32:...46:tw=30;42:ow=30;43
  PYENV_ROOT=/Users/malpern/.pyenv
  PYENV_SHELL=zsh
  DISABLE_AUTO_UPDATE=true
  TERM_PROGRAM=vscode
  TERM_PROGRAM_VERSION=0.50.1
  LANG=en_US.UTF-8
  COLORTERM=truecolor
  GIT_ASKPASS=/Applications/Cursor.../git/dist/askpass.sh
  VSCODE_GIT_ASKPASS_NODE=/Applications/Cursor...rsor Helper (Plugin)
  VSCODE_GIT_ASKPASS_EXTRA_ARGS=
  VSCODE_GIT_ASKPASS_MAIN=/Applications/Cursor...dist/askpass-main.js
  VSCODE_GIT_IPC_HANDLE=/var/folders/0s/42v7...-git-14a5ce3e7f.sock
  PYENV_VERSION=3.10.16
  PYENV_DIR=/
  VIRTUAL_ENV=/Volumes/Flash Gordo...e/nicktokatana/.venv
  PYENV_HOOK_PATH=/Users/malpern/.pyen.../usr/lib/pyenv/hooks
  VIRTUAL_ENV_PROMPT=.venv
  VSCODE_INJECTION=1
  ZDOTDIR=/Users/malpern
  USER_ZDOTDIR=/Users/malpern
  TERM=xterm-256color
  PS1=.venv%(?:%{[01;32m%...} $(git_prompt_info)
  PYTHONPATH=.
  _=/Users/malpern/.pyen...s/3.10.16/bin/pytest
  PYTEST_VERSION=8.3.4
  PYTEST_CURRENT_TEST=tests/dts/test_perfo...r_performance (call)
[DtsPreprocessor] Temp file: /var/folders/0s/42v7yl697hn0l1cdnx0vrvyr0000gn/T/tmprc5biy15.dts
[DtsPreprocessor] Temp file contents:
#include <dt-bindings/zmk/matrix_transform.h>

/ {
    chosen {
        zmk,matrix_transform = &default_transform;
    };

    default_transform: matrix_transform {
        compatible = "zmk,matrix-transform";
        rows = <4>;
        columns = <12>;
        map = <
            RC(0,0)  RC(0,1)  RC(0,2)  RC(0,3)  RC(0,4)  RC(0,5)  RC(0,6)  RC(0,7)  RC(0,8)  RC(0,9)  RC(0,10) RC(0,11)
            RC(1,0)  RC(1,1)  RC(1,2)  RC(1,3)  RC(1,4)  RC(1,5)  RC(1,6)  RC(1,7)  RC(1,8)  RC(1,9)  RC(1,10) RC(1,11)
            RC(2,0)  RC(2,1)  RC(2,2)  RC(2,3)  RC(2,4)  RC(2,5)  RC(2,6)  RC(2,7)  RC(2,8)  RC(2,9)  RC(2,10) RC(2,11)
            RC(3,0)  RC(3,1)  RC(3,2)  RC(3,3)  RC(3,4)  RC(3,5)  RC(3,6)  RC(3,7)  RC(3,8)  RC(3,9)  RC(3,10) RC(3,11)
        >;
    };

    behaviors {
        mt: mod_tap {
            compatible = "zmk,behavior-hold-tap";
            tapping-term-ms = <200>;
            #binding-cells = <2>;
        };
        
        lt: layer_tap {
            compatible = "zmk,behavior-hold-tap";
            tapping-term-ms = <200>;
            #binding-cells = <2>;
        };
        
        macro_a: macro_a {
            compatible = "zmk,behavior-macro";
            #binding-cells = <0>;
            bindings = <&kp A &kp B>;
        };
        
        macro_b: macro_b {
            compatible = "zmk,behavior-macro";
            #binding-cells = <0>;
            bindings = <&kp C &kp D>;
        };
        
        unicode: unicode {
            compatible = "zmk,behavior-unicode";
            #binding-cells = <1>;
        };
        
        uc_string: unicode_string {
            compatible = "zmk,behavior-unicode-string";
            #binding-cells = <1>;
            strings = <
                "smile" "ðŸ˜Š"
                "heart" "â¤ï¸"
            >;
        };
    };

    keymap {
        compatible = "zmk,keymap";
        
        default_layer {
            bindings = <
                &mt LSHIFT A  &kp B        &macro_a     &kp D         &lt 1 E      &kp F
                &kp G         &kp H        &kp I        &kp J         &kp K        &kp L
                &kp M         &kp N        &kp O        &kp P         &kp Q        &kp R
                &kp S         &kp T        &kp U        &kp V         &kp W        &kp X
            >;
        };
        
        lower_layer {
            bindings = <
                &kp N1        &kp N2       &kp N3       &kp N4        &kp N5       &kp N6
                &kp N7        &kp N8       &kp N9       &kp N0        &kp MINUS    &kp EQUAL
                &kp F1        &kp F2       &kp F3       &kp F4        &kp F5       &kp F6
                &kp F7        &kp F8       &kp F9       &kp F10       &kp F11      &kp F12
            >;
        };
        
        raise_layer {
            bindings = <
                &kp EXCLAMATION &kp AT     &kp HASH     &kp DOLLAR    &kp PERCENT  &kp CARET
                &kp AMPERSAND   &kp STAR   &kp LPAR     &kp RPAR      &kp UNDER    &kp PLUS
                &kp F1          &kp F2     &kp F3       &kp F4        &kp F5       &kp F6
                &kp F7          &kp F8     &kp F9       &kp F10       &kp F11      &kp F12
            >;
        };
        
        adjust_layer {
            bindings = <
                &kp RESET      &kp BOOTLOADER &kp NONE  &kp NONE      &kp NONE     &kp NONE
                &kp NONE       &kp NONE       &kp NONE  &kp NONE      &kp NONE     &kp NONE
                &kp NONE       &kp NONE       &kp NONE  &kp NONE      &kp NONE     &kp NONE
                &kp NONE       &kp NONE       &kp NONE  &kp NONE      &kp NONE     &kp NONE
            >;
        };
    };

    combos {
        compatible = "zmk,combos";
        
        combo_esc {
            timeout-ms = <50>;
            key-positions = <0 1>;
            bindings = <&kp ESC>;
        };
        
        combo_tab {
            timeout-ms = <50>;
            key-positions = <1 2>;
            bindings = <&kp TAB>;
        };
        
        combo_enter {
            timeout-ms = <50>;
            key-positions = <2 3>;
            bindings = <&kp ENTER>;
        };
    };

    conditional_layers {
        compatible = "zmk,conditional-layers";
        
        tri_layer {
            if-layers = <1 2>;
            then-layer = <3>;
        };
    };
}; 
[DtsPreprocessor] cpp command: ['/usr/bin/clang', '-E', '-nostdinc', '-undef', '-x', 'assembler-with-cpp', '/var/folders/0s/42v7yl697hn0l1cdnx0vrvyr0000gn/T/tmprc5biy15.dts']
___________________________ test_parser_performance ____________________________

self = <converter.dts.preprocessor.DtsPreprocessor object at 0x1064c48e0>
input_path = PosixPath('/Volumes/FlashGordon/Dropbox/code/nicktokatana/tests/fixtures/dts/complex_keymap.zmk')
matrix_size = None

    def preprocess(
        self,
        input_path: str,
        matrix_size: Optional[Tuple[int, int]] = None,
    ) -> str:
        """Preprocess a DTS file.
    
        Args:
            input_path: Path to the input file
            matrix_size: Optional tuple of (rows, cols) for matrix transform
    
        Returns:
            The preprocessed content as a string
    
        Raises:
            PreprocessorError: If preprocessing fails
        """
        input_path = Path(input_path)
        if not input_path.exists():
            raise PreprocessorError(
                f"Input file does not exist: {input_path}",
                help_text=(
                    "Ensure the input file exists and has proper " "read permissions"
                ),
            )
    
        try:
            with open(input_path, "r") as f:
                content_for_cpp = f.read()
        except Exception as e:
            raise PreprocessorError(
                f"Failed to read input file: {str(e)}",
                file=str(input_path),
                help_text=("Ensure the file exists and has proper " "read permissions"),
            )
    
        # Create a temporary file for the preprocessor input
        tmp_input = tempfile.NamedTemporaryFile(
            mode="w",
            delete=False,
            suffix=".dts",
            dir=None,  # Use system default temp dir (usually /tmp)
        )
        tmp_input.write(content_for_cpp)
        tmp_input.close()
        tmp_input_file = Path(tmp_input.name)
    
        # Debug: print environment and temp file contents
        print("[DtsPreprocessor] ENVIRONMENT:")
        for k, v in os.environ.items():
            if len(v) > 40:
                print(f"  {k}={v[:20]}...{v[-20:]}")
            else:
                print(f"  {k}={v}")
        if len(str(tmp_input_file)) > 70:
            print(f"[DtsPreprocessor] Temp file: " f"{str(tmp_input_file)[:70]}...")
        else:
            print(f"[DtsPreprocessor] Temp file: {tmp_input_file}")
        with open(tmp_input_file, "r") as f:
            print("[DtsPreprocessor] Temp file contents:")
            print(f.read())
    
        try:
            # Build preprocessor command as a list for shell=False
            if os.uname().sysname == "Darwin":
                # Use clang with assembler-with-cpp for .dts files on macOS
                clang_path = "/usr/bin/clang"
                cpp_cmd = [
                    clang_path,
                    "-E",
                    "-nostdinc",
                    "-undef",
                    "-x",
                    "assembler-with-cpp",
                ]
                for path in self.include_paths:
                    cpp_cmd.extend(["-I", str(path)])
                cpp_cmd.append(str(tmp_input_file))
            else:
                cpp_cmd = [
                    str(self.cpp_path),
                    "-E",
                ]
                for path in self.include_paths:
                    cpp_cmd.extend(["-I", str(path)])
                cpp_cmd.extend(["-x", "c", str(tmp_input_file)])
    
            # Debug: print the constructed command list
            print("[DtsPreprocessor] cpp command:", cpp_cmd)
    
            # Run preprocessor with shell=False
            try:
>               result = subprocess.run(
                    cpp_cmd,
                    capture_output=True,
                    text=True,
                    check=True,
                    shell=False,
                )

converter/dts/preprocessor.py:214: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = None, capture_output = True, timeout = None, check = True
popenargs = (['/usr/bin/clang', '-E', '-nostdinc', '-undef', '-x', 'assembler-with-cpp', ...],)
kwargs = {'shell': False, 'stderr': -1, 'stdout': -1, 'text': True}
process = <Popen: returncode: 1 args: ['/usr/bin/clang', '-E', '-nostdinc', '-undef', ...>
stdout = '# 1 "/var/folders/0s/42v7yl697hn0l1cdnx0vrvyr0000gn/T/tmpz2uz1u2_.dts"\n# 1 "<built-in>" 1\n# 1 "<built-in>" 3\n\n\n\...yers";\n\n        tri_layer {\n            if-layers = <1 2>;\n            then-layer = <3>;\n        };\n    };\n};\n'
stderr = "/var/folders/0s/42v7yl697hn0l1cdnx0vrvyr0000gn/T/tmpz2uz1u2_.dts:1:10: fatal error: 'dt-bindings/zmk/matrix_transform...lude <dt-bindings/zmk/matrix_transform.h>\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n1 error generated.\n"
retcode = 1

    def run(*popenargs,
            input=None, capture_output=False, timeout=None, check=False, **kwargs):
        """Run command with arguments and return a CompletedProcess instance.
    
        The returned instance will have attributes args, returncode, stdout and
        stderr. By default, stdout and stderr are not captured, and those attributes
        will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them,
        or pass capture_output=True to capture both.
    
        If check is True and the exit code was non-zero, it raises a
        CalledProcessError. The CalledProcessError object will have the return code
        in the returncode attribute, and output & stderr attributes if those streams
        were captured.
    
        If timeout is given, and the process takes too long, a TimeoutExpired
        exception will be raised.
    
        There is an optional argument "input", allowing you to
        pass bytes or a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it will be used internally.
    
        By default, all communication is in bytes, and therefore any "input" should
        be bytes, and the stdout and stderr will be bytes. If in text mode, any
        "input" should be a string, and stdout and stderr will be strings decoded
        according to locale encoding, or by "encoding" if set. Text mode is
        triggered by setting any of text, encoding, errors or universal_newlines.
    
        The other arguments are the same as for the Popen constructor.
        """
        if input is not None:
            if kwargs.get('stdin') is not None:
                raise ValueError('stdin and input arguments may not both be used.')
            kwargs['stdin'] = PIPE
    
        if capture_output:
            if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:
                raise ValueError('stdout and stderr arguments may not be used '
                                 'with capture_output.')
            kwargs['stdout'] = PIPE
            kwargs['stderr'] = PIPE
    
        with Popen(*popenargs, **kwargs) as process:
            try:
                stdout, stderr = process.communicate(input, timeout=timeout)
            except TimeoutExpired as exc:
                process.kill()
                if _mswindows:
                    # Windows accumulates the output in a single blocking
                    # read() call run on child threads, with the timeout
                    # being done in a join() on those threads.  communicate()
                    # _after_ kill() is required to collect that and add it
                    # to the exception.
                    exc.stdout, exc.stderr = process.communicate()
                else:
                    # POSIX _communicate already populated the output so
                    # far into the TimeoutExpired exception.
                    process.wait()
                raise
            except:  # Including KeyboardInterrupt, communicate handled that.
                process.kill()
                # We don't call process.wait() as .__exit__ does that for us.
                raise
            retcode = process.poll()
            if check and retcode:
>               raise CalledProcessError(retcode, process.args,
                                         output=stdout, stderr=stderr)
E               subprocess.CalledProcessError: Command '['/usr/bin/clang', '-E', '-nostdinc', '-undef', '-x', 'assembler-with-cpp', '/var/folders/0s/42v7yl697hn0l1cdnx0vrvyr0000gn/T/tmpz2uz1u2_.dts']' returned non-zero exit status 1.

/Users/malpern/.pyenv/versions/3.10.16/lib/python3.10/subprocess.py:526: CalledProcessError

During handling of the above exception, another exception occurred:

sample_keymap_path = '/Volumes/FlashGordon/Dropbox/code/nicktokatana/tests/fixtures/dts/complex_keymap.zmk'

    def test_parser_performance(sample_keymap_path):
        """Test the performance of the parser."""
        preprocessor = DtsPreprocessor()
        parser = DtsParser()
    
        # Preprocess once
>       content = preprocessor.preprocess(sample_keymap_path)

tests/dts/test_performance.py:56: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <converter.dts.preprocessor.DtsPreprocessor object at 0x1064c48e0>
input_path = PosixPath('/Volumes/FlashGordon/Dropbox/code/nicktokatana/tests/fixtures/dts/complex_keymap.zmk')
matrix_size = None

    def preprocess(
        self,
        input_path: str,
        matrix_size: Optional[Tuple[int, int]] = None,
    ) -> str:
        """Preprocess a DTS file.
    
        Args:
            input_path: Path to the input file
            matrix_size: Optional tuple of (rows, cols) for matrix transform
    
        Returns:
            The preprocessed content as a string
    
        Raises:
            PreprocessorError: If preprocessing fails
        """
        input_path = Path(input_path)
        if not input_path.exists():
            raise PreprocessorError(
                f"Input file does not exist: {input_path}",
                help_text=(
                    "Ensure the input file exists and has proper " "read permissions"
                ),
            )
    
        try:
            with open(input_path, "r") as f:
                content_for_cpp = f.read()
        except Exception as e:
            raise PreprocessorError(
                f"Failed to read input file: {str(e)}",
                file=str(input_path),
                help_text=("Ensure the file exists and has proper " "read permissions"),
            )
    
        # Create a temporary file for the preprocessor input
        tmp_input = tempfile.NamedTemporaryFile(
            mode="w",
            delete=False,
            suffix=".dts",
            dir=None,  # Use system default temp dir (usually /tmp)
        )
        tmp_input.write(content_for_cpp)
        tmp_input.close()
        tmp_input_file = Path(tmp_input.name)
    
        # Debug: print environment and temp file contents
        print("[DtsPreprocessor] ENVIRONMENT:")
        for k, v in os.environ.items():
            if len(v) > 40:
                print(f"  {k}={v[:20]}...{v[-20:]}")
            else:
                print(f"  {k}={v}")
        if len(str(tmp_input_file)) > 70:
            print(f"[DtsPreprocessor] Temp file: " f"{str(tmp_input_file)[:70]}...")
        else:
            print(f"[DtsPreprocessor] Temp file: {tmp_input_file}")
        with open(tmp_input_file, "r") as f:
            print("[DtsPreprocessor] Temp file contents:")
            print(f.read())
    
        try:
            # Build preprocessor command as a list for shell=False
            if os.uname().sysname == "Darwin":
                # Use clang with assembler-with-cpp for .dts files on macOS
                clang_path = "/usr/bin/clang"
                cpp_cmd = [
                    clang_path,
                    "-E",
                    "-nostdinc",
                    "-undef",
                    "-x",
                    "assembler-with-cpp",
                ]
                for path in self.include_paths:
                    cpp_cmd.extend(["-I", str(path)])
                cpp_cmd.append(str(tmp_input_file))
            else:
                cpp_cmd = [
                    str(self.cpp_path),
                    "-E",
                ]
                for path in self.include_paths:
                    cpp_cmd.extend(["-I", str(path)])
                cpp_cmd.extend(["-x", "c", str(tmp_input_file)])
    
            # Debug: print the constructed command list
            print("[DtsPreprocessor] cpp command:", cpp_cmd)
    
            # Run preprocessor with shell=False
            try:
                result = subprocess.run(
                    cpp_cmd,
                    capture_output=True,
                    text=True,
                    check=True,
                    shell=False,
                )
            except subprocess.CalledProcessError as e:
>               raise PreprocessorError(
                    "Failed to process DTS directives",
                    file=str(input_path),
                    context=str(e),
                    help_text=("Check for malformed DTS directives in " "input file"),
                )
E               converter.dts.preprocessor.PreprocessorError: Failed to process DTS directives

converter/dts/preprocessor.py:222: PreprocessorError
----------------------------- Captured stdout call -----------------------------
[DtsPreprocessor] ENVIRONMENT:
  MallocNanoZone=0
  USER=malpern
  SECURITYSESSIONID=186a3
  COMMAND_MODE=unix2003
  __CFBundleIdentifier=com.todesktop.230313mzl4w4u92
  PATH=/Users/malpern/.curs....cache/lm-studio/bin
  LOGNAME=malpern
  SSH_AUTH_SOCK=/private/tmp/com.app...x1qskoux7b/Listeners
  HOME=/Users/malpern
  SHELL=/bin/zsh
  TMPDIR=/var/folders/0s/42v7...1cdnx0vrvyr0000gn/T/
  LaunchInstanceID=BFD4BF06-15BD-4F76-8D8A-1AEC50E6795A
  __CF_USER_TEXT_ENCODING=0x1F5:0x0:0x0
  XPC_SERVICE_NAME=0
  XPC_FLAGS=0x0
  ORIGINAL_XDG_CURRENT_DESKTOP=undefined
  CURSOR_TRACE_ID=f5e099fd466543c5a0d391e03a641e89
  SHLVL=1
  PWD=/Volumes/FlashGordon...ox/code/nicktokatana
  OLDPWD=/Volumes/FlashGordon...ox/code/nicktokatana
  HOMEBREW_PREFIX=/opt/homebrew
  HOMEBREW_CELLAR=/opt/homebrew/Cellar
  HOMEBREW_REPOSITORY=/opt/homebrew
  INFOPATH=/opt/homebrew/share/...homebrew/share/info:
  YOUR_CONSUMER_KEY=ah6HAffNJRCv4xNrV4OZcVIrQ
  YOUR_CONSUMER_SECRET=EXM9IzH9IEdE2yJf0t5F...DPuFXLk55DwB8pLRswR5
  YOUR_ACCESS_TOKEN=1483-5UbadNrxZUkJpAp...JSXPVSxtsPwJyrUrZvcO
  YOUR_ACCESS_TOKEN_SECRET=jeyyEWPHAgoS0ebKus4t...0jH2T3gRCIz3dsYXQwqS
  YOUR_BEARER_TOKEN=AAAAAAAAAAAAAAAAAAAA...8YVAWCOQu6Pyu4yhuY0a
  OPENAI_API_KEY=sk-qVQDNdwpfPhrAvFr9...ob362AQbhWVa3p95yD28
  ANTHROPIC_API_KEY=sk-ant-api03-Tq7nYRm...SCuUoAfwIQg-NWFWuAAA
  TAVILY_API_KEY=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
  BING_SUBSCRIPTION_KEY=bec8ded0f34a421ba60cc3bd4626825e
  EDITOR=vi
  ZSH=/Users/malpern/.oh-my-zsh
  PAGER=head -n 10000 | cat
  LESS=-R
  LSCOLORS=Gxfxcxdxbxegedabagacad
  LS_COLORS=di=1;36:ln=35:so=32:...46:tw=30;42:ow=30;43
  PYENV_ROOT=/Users/malpern/.pyenv
  PYENV_SHELL=zsh
  DISABLE_AUTO_UPDATE=true
  TERM_PROGRAM=vscode
  TERM_PROGRAM_VERSION=0.50.1
  LANG=en_US.UTF-8
  COLORTERM=truecolor
  GIT_ASKPASS=/Applications/Cursor.../git/dist/askpass.sh
  VSCODE_GIT_ASKPASS_NODE=/Applications/Cursor...rsor Helper (Plugin)
  VSCODE_GIT_ASKPASS_EXTRA_ARGS=
  VSCODE_GIT_ASKPASS_MAIN=/Applications/Cursor...dist/askpass-main.js
  VSCODE_GIT_IPC_HANDLE=/var/folders/0s/42v7...-git-14a5ce3e7f.sock
  PYENV_VERSION=3.10.16
  PYENV_DIR=/
  VIRTUAL_ENV=/Volumes/Flash Gordo...e/nicktokatana/.venv
  PYENV_HOOK_PATH=/Users/malpern/.pyen.../usr/lib/pyenv/hooks
  VIRTUAL_ENV_PROMPT=.venv
  VSCODE_INJECTION=1
  ZDOTDIR=/Users/malpern
  USER_ZDOTDIR=/Users/malpern
  TERM=xterm-256color
  PS1=.venv%(?:%{[01;32m%...} $(git_prompt_info)
  PYTHONPATH=.
  _=/Users/malpern/.pyen...s/3.10.16/bin/pytest
  PYTEST_VERSION=8.3.4
  PYTEST_CURRENT_TEST=tests/dts/test_perfo...r_performance (call)
[DtsPreprocessor] Temp file: /var/folders/0s/42v7yl697hn0l1cdnx0vrvyr0000gn/T/tmpz2uz1u2_.dts
[DtsPreprocessor] Temp file contents:
#include <dt-bindings/zmk/matrix_transform.h>

/ {
    chosen {
        zmk,matrix_transform = &default_transform;
    };

    default_transform: matrix_transform {
        compatible = "zmk,matrix-transform";
        rows = <4>;
        columns = <12>;
        map = <
            RC(0,0)  RC(0,1)  RC(0,2)  RC(0,3)  RC(0,4)  RC(0,5)  RC(0,6)  RC(0,7)  RC(0,8)  RC(0,9)  RC(0,10) RC(0,11)
            RC(1,0)  RC(1,1)  RC(1,2)  RC(1,3)  RC(1,4)  RC(1,5)  RC(1,6)  RC(1,7)  RC(1,8)  RC(1,9)  RC(1,10) RC(1,11)
            RC(2,0)  RC(2,1)  RC(2,2)  RC(2,3)  RC(2,4)  RC(2,5)  RC(2,6)  RC(2,7)  RC(2,8)  RC(2,9)  RC(2,10) RC(2,11)
            RC(3,0)  RC(3,1)  RC(3,2)  RC(3,3)  RC(3,4)  RC(3,5)  RC(3,6)  RC(3,7)  RC(3,8)  RC(3,9)  RC(3,10) RC(3,11)
        >;
    };

    behaviors {
        mt: mod_tap {
            compatible = "zmk,behavior-hold-tap";
            tapping-term-ms = <200>;
            #binding-cells = <2>;
        };
        
        lt: layer_tap {
            compatible = "zmk,behavior-hold-tap";
            tapping-term-ms = <200>;
            #binding-cells = <2>;
        };
        
        macro_a: macro_a {
            compatible = "zmk,behavior-macro";
            #binding-cells = <0>;
            bindings = <&kp A &kp B>;
        };
        
        macro_b: macro_b {
            compatible = "zmk,behavior-macro";
            #binding-cells = <0>;
            bindings = <&kp C &kp D>;
        };
        
        unicode: unicode {
            compatible = "zmk,behavior-unicode";
            #binding-cells = <1>;
        };
        
        uc_string: unicode_string {
            compatible = "zmk,behavior-unicode-string";
            #binding-cells = <1>;
            strings = <
                "smile" "ðŸ˜Š"
                "heart" "â¤ï¸"
            >;
        };
    };

    keymap {
        compatible = "zmk,keymap";
        
        default_layer {
            bindings = <
                &mt LSHIFT A  &kp B        &macro_a     &kp D         &lt 1 E      &kp F
                &kp G         &kp H        &kp I        &kp J         &kp K        &kp L
                &kp M         &kp N        &kp O        &kp P         &kp Q        &kp R
                &kp S         &kp T        &kp U        &kp V         &kp W        &kp X
            >;
        };
        
        lower_layer {
            bindings = <
                &kp N1        &kp N2       &kp N3       &kp N4        &kp N5       &kp N6
                &kp N7        &kp N8       &kp N9       &kp N0        &kp MINUS    &kp EQUAL
                &kp F1        &kp F2       &kp F3       &kp F4        &kp F5       &kp F6
                &kp F7        &kp F8       &kp F9       &kp F10       &kp F11      &kp F12
            >;
        };
        
        raise_layer {
            bindings = <
                &kp EXCLAMATION &kp AT     &kp HASH     &kp DOLLAR    &kp PERCENT  &kp CARET
                &kp AMPERSAND   &kp STAR   &kp LPAR     &kp RPAR      &kp UNDER    &kp PLUS
                &kp F1          &kp F2     &kp F3       &kp F4        &kp F5       &kp F6
                &kp F7          &kp F8     &kp F9       &kp F10       &kp F11      &kp F12
            >;
        };
        
        adjust_layer {
            bindings = <
                &kp RESET      &kp BOOTLOADER &kp NONE  &kp NONE      &kp NONE     &kp NONE
                &kp NONE       &kp NONE       &kp NONE  &kp NONE      &kp NONE     &kp NONE
                &kp NONE       &kp NONE       &kp NONE  &kp NONE      &kp NONE     &kp NONE
                &kp NONE       &kp NONE       &kp NONE  &kp NONE      &kp NONE     &kp NONE
            >;
        };
    };

    combos {
        compatible = "zmk,combos";
        
        combo_esc {
            timeout-ms = <50>;
            key-positions = <0 1>;
            bindings = <&kp ESC>;
        };
        
        combo_tab {
            timeout-ms = <50>;
            key-positions = <1 2>;
            bindings = <&kp TAB>;
        };
        
        combo_enter {
            timeout-ms = <50>;
            key-positions = <2 3>;
            bindings = <&kp ENTER>;
        };
    };

    conditional_layers {
        compatible = "zmk,conditional-layers";
        
        tri_layer {
            if-layers = <1 2>;
            then-layer = <3>;
        };
    };
}; 
[DtsPreprocessor] cpp command: ['/usr/bin/clang', '-E', '-nostdinc', '-undef', '-x', 'assembler-with-cpp', '/var/folders/0s/42v7yl697hn0l1cdnx0vrvyr0000gn/T/tmpz2uz1u2_.dts']
__________________________ test_extractor_performance __________________________

self = <converter.dts.preprocessor.DtsPreprocessor object at 0x1064c5cf0>
input_path = PosixPath('/Volumes/FlashGordon/Dropbox/code/nicktokatana/tests/fixtures/dts/complex_keymap.zmk')
matrix_size = None

    def preprocess(
        self,
        input_path: str,
        matrix_size: Optional[Tuple[int, int]] = None,
    ) -> str:
        """Preprocess a DTS file.
    
        Args:
            input_path: Path to the input file
            matrix_size: Optional tuple of (rows, cols) for matrix transform
    
        Returns:
            The preprocessed content as a string
    
        Raises:
            PreprocessorError: If preprocessing fails
        """
        input_path = Path(input_path)
        if not input_path.exists():
            raise PreprocessorError(
                f"Input file does not exist: {input_path}",
                help_text=(
                    "Ensure the input file exists and has proper " "read permissions"
                ),
            )
    
        try:
            with open(input_path, "r") as f:
                content_for_cpp = f.read()
        except Exception as e:
            raise PreprocessorError(
                f"Failed to read input file: {str(e)}",
                file=str(input_path),
                help_text=("Ensure the file exists and has proper " "read permissions"),
            )
    
        # Create a temporary file for the preprocessor input
        tmp_input = tempfile.NamedTemporaryFile(
            mode="w",
            delete=False,
            suffix=".dts",
            dir=None,  # Use system default temp dir (usually /tmp)
        )
        tmp_input.write(content_for_cpp)
        tmp_input.close()
        tmp_input_file = Path(tmp_input.name)
    
        # Debug: print environment and temp file contents
        print("[DtsPreprocessor] ENVIRONMENT:")
        for k, v in os.environ.items():
            if len(v) > 40:
                print(f"  {k}={v[:20]}...{v[-20:]}")
            else:
                print(f"  {k}={v}")
        if len(str(tmp_input_file)) > 70:
            print(f"[DtsPreprocessor] Temp file: " f"{str(tmp_input_file)[:70]}...")
        else:
            print(f"[DtsPreprocessor] Temp file: {tmp_input_file}")
        with open(tmp_input_file, "r") as f:
            print("[DtsPreprocessor] Temp file contents:")
            print(f.read())
    
        try:
            # Build preprocessor command as a list for shell=False
            if os.uname().sysname == "Darwin":
                # Use clang with assembler-with-cpp for .dts files on macOS
                clang_path = "/usr/bin/clang"
                cpp_cmd = [
                    clang_path,
                    "-E",
                    "-nostdinc",
                    "-undef",
                    "-x",
                    "assembler-with-cpp",
                ]
                for path in self.include_paths:
                    cpp_cmd.extend(["-I", str(path)])
                cpp_cmd.append(str(tmp_input_file))
            else:
                cpp_cmd = [
                    str(self.cpp_path),
                    "-E",
                ]
                for path in self.include_paths:
                    cpp_cmd.extend(["-I", str(path)])
                cpp_cmd.extend(["-x", "c", str(tmp_input_file)])
    
            # Debug: print the constructed command list
            print("[DtsPreprocessor] cpp command:", cpp_cmd)
    
            # Run preprocessor with shell=False
            try:
>               result = subprocess.run(
                    cpp_cmd,
                    capture_output=True,
                    text=True,
                    check=True,
                    shell=False,
                )

converter/dts/preprocessor.py:214: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = None, capture_output = True, timeout = None, check = True
popenargs = (['/usr/bin/clang', '-E', '-nostdinc', '-undef', '-x', 'assembler-with-cpp', ...],)
kwargs = {'shell': False, 'stderr': -1, 'stdout': -1, 'text': True}
process = <Popen: returncode: 1 args: ['/usr/bin/clang', '-E', '-nostdinc', '-undef', ...>
stdout = '# 1 "/var/folders/0s/42v7yl697hn0l1cdnx0vrvyr0000gn/T/tmpy1og0pu8.dts"\n# 1 "<built-in>" 1\n# 1 "<built-in>" 3\n\n\n\...yers";\n\n        tri_layer {\n            if-layers = <1 2>;\n            then-layer = <3>;\n        };\n    };\n};\n'
stderr = "/var/folders/0s/42v7yl697hn0l1cdnx0vrvyr0000gn/T/tmpy1og0pu8.dts:1:10: fatal error: 'dt-bindings/zmk/matrix_transform...lude <dt-bindings/zmk/matrix_transform.h>\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n1 error generated.\n"
retcode = 1

    def run(*popenargs,
            input=None, capture_output=False, timeout=None, check=False, **kwargs):
        """Run command with arguments and return a CompletedProcess instance.
    
        The returned instance will have attributes args, returncode, stdout and
        stderr. By default, stdout and stderr are not captured, and those attributes
        will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them,
        or pass capture_output=True to capture both.
    
        If check is True and the exit code was non-zero, it raises a
        CalledProcessError. The CalledProcessError object will have the return code
        in the returncode attribute, and output & stderr attributes if those streams
        were captured.
    
        If timeout is given, and the process takes too long, a TimeoutExpired
        exception will be raised.
    
        There is an optional argument "input", allowing you to
        pass bytes or a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it will be used internally.
    
        By default, all communication is in bytes, and therefore any "input" should
        be bytes, and the stdout and stderr will be bytes. If in text mode, any
        "input" should be a string, and stdout and stderr will be strings decoded
        according to locale encoding, or by "encoding" if set. Text mode is
        triggered by setting any of text, encoding, errors or universal_newlines.
    
        The other arguments are the same as for the Popen constructor.
        """
        if input is not None:
            if kwargs.get('stdin') is not None:
                raise ValueError('stdin and input arguments may not both be used.')
            kwargs['stdin'] = PIPE
    
        if capture_output:
            if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:
                raise ValueError('stdout and stderr arguments may not be used '
                                 'with capture_output.')
            kwargs['stdout'] = PIPE
            kwargs['stderr'] = PIPE
    
        with Popen(*popenargs, **kwargs) as process:
            try:
                stdout, stderr = process.communicate(input, timeout=timeout)
            except TimeoutExpired as exc:
                process.kill()
                if _mswindows:
                    # Windows accumulates the output in a single blocking
                    # read() call run on child threads, with the timeout
                    # being done in a join() on those threads.  communicate()
                    # _after_ kill() is required to collect that and add it
                    # to the exception.
                    exc.stdout, exc.stderr = process.communicate()
                else:
                    # POSIX _communicate already populated the output so
                    # far into the TimeoutExpired exception.
                    process.wait()
                raise
            except:  # Including KeyboardInterrupt, communicate handled that.
                process.kill()
                # We don't call process.wait() as .__exit__ does that for us.
                raise
            retcode = process.poll()
            if check and retcode:
>               raise CalledProcessError(retcode, process.args,
                                         output=stdout, stderr=stderr)
E               subprocess.CalledProcessError: Command '['/usr/bin/clang', '-E', '-nostdinc', '-undef', '-x', 'assembler-with-cpp', '/var/folders/0s/42v7yl697hn0l1cdnx0vrvyr0000gn/T/tmpy1og0pu8.dts']' returned non-zero exit status 1.

/Users/malpern/.pyenv/versions/3.10.16/lib/python3.10/subprocess.py:526: CalledProcessError

During handling of the above exception, another exception occurred:

sample_keymap_path = '/Volumes/FlashGordon/Dropbox/code/nicktokatana/tests/fixtures/dts/complex_keymap.zmk'

    def test_extractor_performance(sample_keymap_path):
        """Test the performance of the extractor."""
        preprocessor = DtsPreprocessor()
        parser = DtsParser()
        extractor = KeymapExtractor()
    
        # Preprocess and parse once
>       content = preprocessor.preprocess(sample_keymap_path)

tests/dts/test_performance.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <converter.dts.preprocessor.DtsPreprocessor object at 0x1064c5cf0>
input_path = PosixPath('/Volumes/FlashGordon/Dropbox/code/nicktokatana/tests/fixtures/dts/complex_keymap.zmk')
matrix_size = None

    def preprocess(
        self,
        input_path: str,
        matrix_size: Optional[Tuple[int, int]] = None,
    ) -> str:
        """Preprocess a DTS file.
    
        Args:
            input_path: Path to the input file
            matrix_size: Optional tuple of (rows, cols) for matrix transform
    
        Returns:
            The preprocessed content as a string
    
        Raises:
            PreprocessorError: If preprocessing fails
        """
        input_path = Path(input_path)
        if not input_path.exists():
            raise PreprocessorError(
                f"Input file does not exist: {input_path}",
                help_text=(
                    "Ensure the input file exists and has proper " "read permissions"
                ),
            )
    
        try:
            with open(input_path, "r") as f:
                content_for_cpp = f.read()
        except Exception as e:
            raise PreprocessorError(
                f"Failed to read input file: {str(e)}",
                file=str(input_path),
                help_text=("Ensure the file exists and has proper " "read permissions"),
            )
    
        # Create a temporary file for the preprocessor input
        tmp_input = tempfile.NamedTemporaryFile(
            mode="w",
            delete=False,
            suffix=".dts",
            dir=None,  # Use system default temp dir (usually /tmp)
        )
        tmp_input.write(content_for_cpp)
        tmp_input.close()
        tmp_input_file = Path(tmp_input.name)
    
        # Debug: print environment and temp file contents
        print("[DtsPreprocessor] ENVIRONMENT:")
        for k, v in os.environ.items():
            if len(v) > 40:
                print(f"  {k}={v[:20]}...{v[-20:]}")
            else:
                print(f"  {k}={v}")
        if len(str(tmp_input_file)) > 70:
            print(f"[DtsPreprocessor] Temp file: " f"{str(tmp_input_file)[:70]}...")
        else:
            print(f"[DtsPreprocessor] Temp file: {tmp_input_file}")
        with open(tmp_input_file, "r") as f:
            print("[DtsPreprocessor] Temp file contents:")
            print(f.read())
    
        try:
            # Build preprocessor command as a list for shell=False
            if os.uname().sysname == "Darwin":
                # Use clang with assembler-with-cpp for .dts files on macOS
                clang_path = "/usr/bin/clang"
                cpp_cmd = [
                    clang_path,
                    "-E",
                    "-nostdinc",
                    "-undef",
                    "-x",
                    "assembler-with-cpp",
                ]
                for path in self.include_paths:
                    cpp_cmd.extend(["-I", str(path)])
                cpp_cmd.append(str(tmp_input_file))
            else:
                cpp_cmd = [
                    str(self.cpp_path),
                    "-E",
                ]
                for path in self.include_paths:
                    cpp_cmd.extend(["-I", str(path)])
                cpp_cmd.extend(["-x", "c", str(tmp_input_file)])
    
            # Debug: print the constructed command list
            print("[DtsPreprocessor] cpp command:", cpp_cmd)
    
            # Run preprocessor with shell=False
            try:
                result = subprocess.run(
                    cpp_cmd,
                    capture_output=True,
                    text=True,
                    check=True,
                    shell=False,
                )
            except subprocess.CalledProcessError as e:
>               raise PreprocessorError(
                    "Failed to process DTS directives",
                    file=str(input_path),
                    context=str(e),
                    help_text=("Check for malformed DTS directives in " "input file"),
                )
E               converter.dts.preprocessor.PreprocessorError: Failed to process DTS directives

converter/dts/preprocessor.py:222: PreprocessorError
----------------------------- Captured stdout call -----------------------------
[DtsPreprocessor] ENVIRONMENT:
  MallocNanoZone=0
  USER=malpern
  SECURITYSESSIONID=186a3
  COMMAND_MODE=unix2003
  __CFBundleIdentifier=com.todesktop.230313mzl4w4u92
  PATH=/Users/malpern/.curs....cache/lm-studio/bin
  LOGNAME=malpern
  SSH_AUTH_SOCK=/private/tmp/com.app...x1qskoux7b/Listeners
  HOME=/Users/malpern
  SHELL=/bin/zsh
  TMPDIR=/var/folders/0s/42v7...1cdnx0vrvyr0000gn/T/
  LaunchInstanceID=BFD4BF06-15BD-4F76-8D8A-1AEC50E6795A
  __CF_USER_TEXT_ENCODING=0x1F5:0x0:0x0
  XPC_SERVICE_NAME=0
  XPC_FLAGS=0x0
  ORIGINAL_XDG_CURRENT_DESKTOP=undefined
  CURSOR_TRACE_ID=f5e099fd466543c5a0d391e03a641e89
  SHLVL=1
  PWD=/Volumes/FlashGordon...ox/code/nicktokatana
  OLDPWD=/Volumes/FlashGordon...ox/code/nicktokatana
  HOMEBREW_PREFIX=/opt/homebrew
  HOMEBREW_CELLAR=/opt/homebrew/Cellar
  HOMEBREW_REPOSITORY=/opt/homebrew
  INFOPATH=/opt/homebrew/share/...homebrew/share/info:
  YOUR_CONSUMER_KEY=ah6HAffNJRCv4xNrV4OZcVIrQ
  YOUR_CONSUMER_SECRET=EXM9IzH9IEdE2yJf0t5F...DPuFXLk55DwB8pLRswR5
  YOUR_ACCESS_TOKEN=1483-5UbadNrxZUkJpAp...JSXPVSxtsPwJyrUrZvcO
  YOUR_ACCESS_TOKEN_SECRET=jeyyEWPHAgoS0ebKus4t...0jH2T3gRCIz3dsYXQwqS
  YOUR_BEARER_TOKEN=AAAAAAAAAAAAAAAAAAAA...8YVAWCOQu6Pyu4yhuY0a
  OPENAI_API_KEY=sk-qVQDNdwpfPhrAvFr9...ob362AQbhWVa3p95yD28
  ANTHROPIC_API_KEY=sk-ant-api03-Tq7nYRm...SCuUoAfwIQg-NWFWuAAA
  TAVILY_API_KEY=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
  BING_SUBSCRIPTION_KEY=bec8ded0f34a421ba60cc3bd4626825e
  EDITOR=vi
  ZSH=/Users/malpern/.oh-my-zsh
  PAGER=head -n 10000 | cat
  LESS=-R
  LSCOLORS=Gxfxcxdxbxegedabagacad
  LS_COLORS=di=1;36:ln=35:so=32:...46:tw=30;42:ow=30;43
  PYENV_ROOT=/Users/malpern/.pyenv
  PYENV_SHELL=zsh
  DISABLE_AUTO_UPDATE=true
  TERM_PROGRAM=vscode
  TERM_PROGRAM_VERSION=0.50.1
  LANG=en_US.UTF-8
  COLORTERM=truecolor
  GIT_ASKPASS=/Applications/Cursor.../git/dist/askpass.sh
  VSCODE_GIT_ASKPASS_NODE=/Applications/Cursor...rsor Helper (Plugin)
  VSCODE_GIT_ASKPASS_EXTRA_ARGS=
  VSCODE_GIT_ASKPASS_MAIN=/Applications/Cursor...dist/askpass-main.js
  VSCODE_GIT_IPC_HANDLE=/var/folders/0s/42v7...-git-14a5ce3e7f.sock
  PYENV_VERSION=3.10.16
  PYENV_DIR=/
  VIRTUAL_ENV=/Volumes/Flash Gordo...e/nicktokatana/.venv
  PYENV_HOOK_PATH=/Users/malpern/.pyen.../usr/lib/pyenv/hooks
  VIRTUAL_ENV_PROMPT=.venv
  VSCODE_INJECTION=1
  ZDOTDIR=/Users/malpern
  USER_ZDOTDIR=/Users/malpern
  TERM=xterm-256color
  PS1=.venv%(?:%{[01;32m%...} $(git_prompt_info)
  PYTHONPATH=.
  _=/Users/malpern/.pyen...s/3.10.16/bin/pytest
  PYTEST_VERSION=8.3.4
  PYTEST_CURRENT_TEST=tests/dts/test_perfo...r_performance (call)
[DtsPreprocessor] Temp file: /var/folders/0s/42v7yl697hn0l1cdnx0vrvyr0000gn/T/tmpy1og0pu8.dts
[DtsPreprocessor] Temp file contents:
#include <dt-bindings/zmk/matrix_transform.h>

/ {
    chosen {
        zmk,matrix_transform = &default_transform;
    };

    default_transform: matrix_transform {
        compatible = "zmk,matrix-transform";
        rows = <4>;
        columns = <12>;
        map = <
            RC(0,0)  RC(0,1)  RC(0,2)  RC(0,3)  RC(0,4)  RC(0,5)  RC(0,6)  RC(0,7)  RC(0,8)  RC(0,9)  RC(0,10) RC(0,11)
            RC(1,0)  RC(1,1)  RC(1,2)  RC(1,3)  RC(1,4)  RC(1,5)  RC(1,6)  RC(1,7)  RC(1,8)  RC(1,9)  RC(1,10) RC(1,11)
            RC(2,0)  RC(2,1)  RC(2,2)  RC(2,3)  RC(2,4)  RC(2,5)  RC(2,6)  RC(2,7)  RC(2,8)  RC(2,9)  RC(2,10) RC(2,11)
            RC(3,0)  RC(3,1)  RC(3,2)  RC(3,3)  RC(3,4)  RC(3,5)  RC(3,6)  RC(3,7)  RC(3,8)  RC(3,9)  RC(3,10) RC(3,11)
        >;
    };

    behaviors {
        mt: mod_tap {
            compatible = "zmk,behavior-hold-tap";
            tapping-term-ms = <200>;
            #binding-cells = <2>;
        };
        
        lt: layer_tap {
            compatible = "zmk,behavior-hold-tap";
            tapping-term-ms = <200>;
            #binding-cells = <2>;
        };
        
        macro_a: macro_a {
            compatible = "zmk,behavior-macro";
            #binding-cells = <0>;
            bindings = <&kp A &kp B>;
        };
        
        macro_b: macro_b {
            compatible = "zmk,behavior-macro";
            #binding-cells = <0>;
            bindings = <&kp C &kp D>;
        };
        
        unicode: unicode {
            compatible = "zmk,behavior-unicode";
            #binding-cells = <1>;
        };
        
        uc_string: unicode_string {
            compatible = "zmk,behavior-unicode-string";
            #binding-cells = <1>;
            strings = <
                "smile" "ðŸ˜Š"
                "heart" "â¤ï¸"
            >;
        };
    };

    keymap {
        compatible = "zmk,keymap";
        
        default_layer {
            bindings = <
                &mt LSHIFT A  &kp B        &macro_a     &kp D         &lt 1 E      &kp F
                &kp G         &kp H        &kp I        &kp J         &kp K        &kp L
                &kp M         &kp N        &kp O        &kp P         &kp Q        &kp R
                &kp S         &kp T        &kp U        &kp V         &kp W        &kp X
            >;
        };
        
        lower_layer {
            bindings = <
                &kp N1        &kp N2       &kp N3       &kp N4        &kp N5       &kp N6
                &kp N7        &kp N8       &kp N9       &kp N0        &kp MINUS    &kp EQUAL
                &kp F1        &kp F2       &kp F3       &kp F4        &kp F5       &kp F6
                &kp F7        &kp F8       &kp F9       &kp F10       &kp F11      &kp F12
            >;
        };
        
        raise_layer {
            bindings = <
                &kp EXCLAMATION &kp AT     &kp HASH     &kp DOLLAR    &kp PERCENT  &kp CARET
                &kp AMPERSAND   &kp STAR   &kp LPAR     &kp RPAR      &kp UNDER    &kp PLUS
                &kp F1          &kp F2     &kp F3       &kp F4        &kp F5       &kp F6
                &kp F7          &kp F8     &kp F9       &kp F10       &kp F11      &kp F12
            >;
        };
        
        adjust_layer {
            bindings = <
                &kp RESET      &kp BOOTLOADER &kp NONE  &kp NONE      &kp NONE     &kp NONE
                &kp NONE       &kp NONE       &kp NONE  &kp NONE      &kp NONE     &kp NONE
                &kp NONE       &kp NONE       &kp NONE  &kp NONE      &kp NONE     &kp NONE
                &kp NONE       &kp NONE       &kp NONE  &kp NONE      &kp NONE     &kp NONE
            >;
        };
    };

    combos {
        compatible = "zmk,combos";
        
        combo_esc {
            timeout-ms = <50>;
            key-positions = <0 1>;
            bindings = <&kp ESC>;
        };
        
        combo_tab {
            timeout-ms = <50>;
            key-positions = <1 2>;
            bindings = <&kp TAB>;
        };
        
        combo_enter {
            timeout-ms = <50>;
            key-positions = <2 3>;
            bindings = <&kp ENTER>;
        };
    };

    conditional_layers {
        compatible = "zmk,conditional-layers";
        
        tri_layer {
            if-layers = <1 2>;
            then-layer = <3>;
        };
    };
}; 
[DtsPreprocessor] cpp command: ['/usr/bin/clang', '-E', '-nostdinc', '-undef', '-x', 'assembler-with-cpp', '/var/folders/0s/42v7yl697hn0l1cdnx0vrvyr0000gn/T/tmpy1og0pu8.dts']
________________________ test_full_pipeline_performance ________________________

self = <converter.dts.preprocessor.DtsPreprocessor object at 0x106406350>
input_path = PosixPath('/Volumes/FlashGordon/Dropbox/code/nicktokatana/tests/fixtures/dts/complex_keymap.zmk')
matrix_size = None

    def preprocess(
        self,
        input_path: str,
        matrix_size: Optional[Tuple[int, int]] = None,
    ) -> str:
        """Preprocess a DTS file.
    
        Args:
            input_path: Path to the input file
            matrix_size: Optional tuple of (rows, cols) for matrix transform
    
        Returns:
            The preprocessed content as a string
    
        Raises:
            PreprocessorError: If preprocessing fails
        """
        input_path = Path(input_path)
        if not input_path.exists():
            raise PreprocessorError(
                f"Input file does not exist: {input_path}",
                help_text=(
                    "Ensure the input file exists and has proper " "read permissions"
                ),
            )
    
        try:
            with open(input_path, "r") as f:
                content_for_cpp = f.read()
        except Exception as e:
            raise PreprocessorError(
                f"Failed to read input file: {str(e)}",
                file=str(input_path),
                help_text=("Ensure the file exists and has proper " "read permissions"),
            )
    
        # Create a temporary file for the preprocessor input
        tmp_input = tempfile.NamedTemporaryFile(
            mode="w",
            delete=False,
            suffix=".dts",
            dir=None,  # Use system default temp dir (usually /tmp)
        )
        tmp_input.write(content_for_cpp)
        tmp_input.close()
        tmp_input_file = Path(tmp_input.name)
    
        # Debug: print environment and temp file contents
        print("[DtsPreprocessor] ENVIRONMENT:")
        for k, v in os.environ.items():
            if len(v) > 40:
                print(f"  {k}={v[:20]}...{v[-20:]}")
            else:
                print(f"  {k}={v}")
        if len(str(tmp_input_file)) > 70:
            print(f"[DtsPreprocessor] Temp file: " f"{str(tmp_input_file)[:70]}...")
        else:
            print(f"[DtsPreprocessor] Temp file: {tmp_input_file}")
        with open(tmp_input_file, "r") as f:
            print("[DtsPreprocessor] Temp file contents:")
            print(f.read())
    
        try:
            # Build preprocessor command as a list for shell=False
            if os.uname().sysname == "Darwin":
                # Use clang with assembler-with-cpp for .dts files on macOS
                clang_path = "/usr/bin/clang"
                cpp_cmd = [
                    clang_path,
                    "-E",
                    "-nostdinc",
                    "-undef",
                    "-x",
                    "assembler-with-cpp",
                ]
                for path in self.include_paths:
                    cpp_cmd.extend(["-I", str(path)])
                cpp_cmd.append(str(tmp_input_file))
            else:
                cpp_cmd = [
                    str(self.cpp_path),
                    "-E",
                ]
                for path in self.include_paths:
                    cpp_cmd.extend(["-I", str(path)])
                cpp_cmd.extend(["-x", "c", str(tmp_input_file)])
    
            # Debug: print the constructed command list
            print("[DtsPreprocessor] cpp command:", cpp_cmd)
    
            # Run preprocessor with shell=False
            try:
>               result = subprocess.run(
                    cpp_cmd,
                    capture_output=True,
                    text=True,
                    check=True,
                    shell=False,
                )

converter/dts/preprocessor.py:214: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = None, capture_output = True, timeout = None, check = True
popenargs = (['/usr/bin/clang', '-E', '-nostdinc', '-undef', '-x', 'assembler-with-cpp', ...],)
kwargs = {'shell': False, 'stderr': -1, 'stdout': -1, 'text': True}
process = <Popen: returncode: 1 args: ['/usr/bin/clang', '-E', '-nostdinc', '-undef', ...>
stdout = '# 1 "/var/folders/0s/42v7yl697hn0l1cdnx0vrvyr0000gn/T/tmpt2bok5jl.dts"\n# 1 "<built-in>" 1\n# 1 "<built-in>" 3\n\n\n\...yers";\n\n        tri_layer {\n            if-layers = <1 2>;\n            then-layer = <3>;\n        };\n    };\n};\n'
stderr = "/var/folders/0s/42v7yl697hn0l1cdnx0vrvyr0000gn/T/tmpt2bok5jl.dts:1:10: fatal error: 'dt-bindings/zmk/matrix_transform...lude <dt-bindings/zmk/matrix_transform.h>\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n1 error generated.\n"
retcode = 1

    def run(*popenargs,
            input=None, capture_output=False, timeout=None, check=False, **kwargs):
        """Run command with arguments and return a CompletedProcess instance.
    
        The returned instance will have attributes args, returncode, stdout and
        stderr. By default, stdout and stderr are not captured, and those attributes
        will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them,
        or pass capture_output=True to capture both.
    
        If check is True and the exit code was non-zero, it raises a
        CalledProcessError. The CalledProcessError object will have the return code
        in the returncode attribute, and output & stderr attributes if those streams
        were captured.
    
        If timeout is given, and the process takes too long, a TimeoutExpired
        exception will be raised.
    
        There is an optional argument "input", allowing you to
        pass bytes or a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it will be used internally.
    
        By default, all communication is in bytes, and therefore any "input" should
        be bytes, and the stdout and stderr will be bytes. If in text mode, any
        "input" should be a string, and stdout and stderr will be strings decoded
        according to locale encoding, or by "encoding" if set. Text mode is
        triggered by setting any of text, encoding, errors or universal_newlines.
    
        The other arguments are the same as for the Popen constructor.
        """
        if input is not None:
            if kwargs.get('stdin') is not None:
                raise ValueError('stdin and input arguments may not both be used.')
            kwargs['stdin'] = PIPE
    
        if capture_output:
            if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:
                raise ValueError('stdout and stderr arguments may not be used '
                                 'with capture_output.')
            kwargs['stdout'] = PIPE
            kwargs['stderr'] = PIPE
    
        with Popen(*popenargs, **kwargs) as process:
            try:
                stdout, stderr = process.communicate(input, timeout=timeout)
            except TimeoutExpired as exc:
                process.kill()
                if _mswindows:
                    # Windows accumulates the output in a single blocking
                    # read() call run on child threads, with the timeout
                    # being done in a join() on those threads.  communicate()
                    # _after_ kill() is required to collect that and add it
                    # to the exception.
                    exc.stdout, exc.stderr = process.communicate()
                else:
                    # POSIX _communicate already populated the output so
                    # far into the TimeoutExpired exception.
                    process.wait()
                raise
            except:  # Including KeyboardInterrupt, communicate handled that.
                process.kill()
                # We don't call process.wait() as .__exit__ does that for us.
                raise
            retcode = process.poll()
            if check and retcode:
>               raise CalledProcessError(retcode, process.args,
                                         output=stdout, stderr=stderr)
E               subprocess.CalledProcessError: Command '['/usr/bin/clang', '-E', '-nostdinc', '-undef', '-x', 'assembler-with-cpp', '/var/folders/0s/42v7yl697hn0l1cdnx0vrvyr0000gn/T/tmpt2bok5jl.dts']' returned non-zero exit status 1.

/Users/malpern/.pyenv/versions/3.10.16/lib/python3.10/subprocess.py:526: CalledProcessError

During handling of the above exception, another exception occurred:

sample_keymap_path = '/Volumes/FlashGordon/Dropbox/code/nicktokatana/tests/fixtures/dts/complex_keymap.zmk'

    def test_full_pipeline_performance(sample_keymap_path):
        """Test the performance of the full conversion pipeline."""
        preprocessor = DtsPreprocessor()
        parser = DtsParser()
        extractor = KeymapExtractor()
        transformer = KanataTransformer()
    
        def run_pipeline():
            content = preprocessor.preprocess(sample_keymap_path)
            ast = parser.parse(content)
            config = extractor.extract(ast)
            return transformer.transform(config)
    
        # Run multiple times to get stable measurements
        times = []
        for _ in range(10):
>           _, duration = measure_time(run_pipeline)

tests/dts/test_performance.py:122: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/dts/test_performance.py:16: in measure_time
    result = func(*args, **kwargs)
tests/dts/test_performance.py:114: in run_pipeline
    content = preprocessor.preprocess(sample_keymap_path)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <converter.dts.preprocessor.DtsPreprocessor object at 0x106406350>
input_path = PosixPath('/Volumes/FlashGordon/Dropbox/code/nicktokatana/tests/fixtures/dts/complex_keymap.zmk')
matrix_size = None

    def preprocess(
        self,
        input_path: str,
        matrix_size: Optional[Tuple[int, int]] = None,
    ) -> str:
        """Preprocess a DTS file.
    
        Args:
            input_path: Path to the input file
            matrix_size: Optional tuple of (rows, cols) for matrix transform
    
        Returns:
            The preprocessed content as a string
    
        Raises:
            PreprocessorError: If preprocessing fails
        """
        input_path = Path(input_path)
        if not input_path.exists():
            raise PreprocessorError(
                f"Input file does not exist: {input_path}",
                help_text=(
                    "Ensure the input file exists and has proper " "read permissions"
                ),
            )
    
        try:
            with open(input_path, "r") as f:
                content_for_cpp = f.read()
        except Exception as e:
            raise PreprocessorError(
                f"Failed to read input file: {str(e)}",
                file=str(input_path),
                help_text=("Ensure the file exists and has proper " "read permissions"),
            )
    
        # Create a temporary file for the preprocessor input
        tmp_input = tempfile.NamedTemporaryFile(
            mode="w",
            delete=False,
            suffix=".dts",
            dir=None,  # Use system default temp dir (usually /tmp)
        )
        tmp_input.write(content_for_cpp)
        tmp_input.close()
        tmp_input_file = Path(tmp_input.name)
    
        # Debug: print environment and temp file contents
        print("[DtsPreprocessor] ENVIRONMENT:")
        for k, v in os.environ.items():
            if len(v) > 40:
                print(f"  {k}={v[:20]}...{v[-20:]}")
            else:
                print(f"  {k}={v}")
        if len(str(tmp_input_file)) > 70:
            print(f"[DtsPreprocessor] Temp file: " f"{str(tmp_input_file)[:70]}...")
        else:
            print(f"[DtsPreprocessor] Temp file: {tmp_input_file}")
        with open(tmp_input_file, "r") as f:
            print("[DtsPreprocessor] Temp file contents:")
            print(f.read())
    
        try:
            # Build preprocessor command as a list for shell=False
            if os.uname().sysname == "Darwin":
                # Use clang with assembler-with-cpp for .dts files on macOS
                clang_path = "/usr/bin/clang"
                cpp_cmd = [
                    clang_path,
                    "-E",
                    "-nostdinc",
                    "-undef",
                    "-x",
                    "assembler-with-cpp",
                ]
                for path in self.include_paths:
                    cpp_cmd.extend(["-I", str(path)])
                cpp_cmd.append(str(tmp_input_file))
            else:
                cpp_cmd = [
                    str(self.cpp_path),
                    "-E",
                ]
                for path in self.include_paths:
                    cpp_cmd.extend(["-I", str(path)])
                cpp_cmd.extend(["-x", "c", str(tmp_input_file)])
    
            # Debug: print the constructed command list
            print("[DtsPreprocessor] cpp command:", cpp_cmd)
    
            # Run preprocessor with shell=False
            try:
                result = subprocess.run(
                    cpp_cmd,
                    capture_output=True,
                    text=True,
                    check=True,
                    shell=False,
                )
            except subprocess.CalledProcessError as e:
>               raise PreprocessorError(
                    "Failed to process DTS directives",
                    file=str(input_path),
                    context=str(e),
                    help_text=("Check for malformed DTS directives in " "input file"),
                )
E               converter.dts.preprocessor.PreprocessorError: Failed to process DTS directives

converter/dts/preprocessor.py:222: PreprocessorError
----------------------------- Captured stdout call -----------------------------
[DtsPreprocessor] ENVIRONMENT:
  MallocNanoZone=0
  USER=malpern
  SECURITYSESSIONID=186a3
  COMMAND_MODE=unix2003
  __CFBundleIdentifier=com.todesktop.230313mzl4w4u92
  PATH=/Users/malpern/.curs....cache/lm-studio/bin
  LOGNAME=malpern
  SSH_AUTH_SOCK=/private/tmp/com.app...x1qskoux7b/Listeners
  HOME=/Users/malpern
  SHELL=/bin/zsh
  TMPDIR=/var/folders/0s/42v7...1cdnx0vrvyr0000gn/T/
  LaunchInstanceID=BFD4BF06-15BD-4F76-8D8A-1AEC50E6795A
  __CF_USER_TEXT_ENCODING=0x1F5:0x0:0x0
  XPC_SERVICE_NAME=0
  XPC_FLAGS=0x0
  ORIGINAL_XDG_CURRENT_DESKTOP=undefined
  CURSOR_TRACE_ID=f5e099fd466543c5a0d391e03a641e89
  SHLVL=1
  PWD=/Volumes/FlashGordon...ox/code/nicktokatana
  OLDPWD=/Volumes/FlashGordon...ox/code/nicktokatana
  HOMEBREW_PREFIX=/opt/homebrew
  HOMEBREW_CELLAR=/opt/homebrew/Cellar
  HOMEBREW_REPOSITORY=/opt/homebrew
  INFOPATH=/opt/homebrew/share/...homebrew/share/info:
  YOUR_CONSUMER_KEY=ah6HAffNJRCv4xNrV4OZcVIrQ
  YOUR_CONSUMER_SECRET=EXM9IzH9IEdE2yJf0t5F...DPuFXLk55DwB8pLRswR5
  YOUR_ACCESS_TOKEN=1483-5UbadNrxZUkJpAp...JSXPVSxtsPwJyrUrZvcO
  YOUR_ACCESS_TOKEN_SECRET=jeyyEWPHAgoS0ebKus4t...0jH2T3gRCIz3dsYXQwqS
  YOUR_BEARER_TOKEN=AAAAAAAAAAAAAAAAAAAA...8YVAWCOQu6Pyu4yhuY0a
  OPENAI_API_KEY=sk-qVQDNdwpfPhrAvFr9...ob362AQbhWVa3p95yD28
  ANTHROPIC_API_KEY=sk-ant-api03-Tq7nYRm...SCuUoAfwIQg-NWFWuAAA
  TAVILY_API_KEY=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
  BING_SUBSCRIPTION_KEY=bec8ded0f34a421ba60cc3bd4626825e
  EDITOR=vi
  ZSH=/Users/malpern/.oh-my-zsh
  PAGER=head -n 10000 | cat
  LESS=-R
  LSCOLORS=Gxfxcxdxbxegedabagacad
  LS_COLORS=di=1;36:ln=35:so=32:...46:tw=30;42:ow=30;43
  PYENV_ROOT=/Users/malpern/.pyenv
  PYENV_SHELL=zsh
  DISABLE_AUTO_UPDATE=true
  TERM_PROGRAM=vscode
  TERM_PROGRAM_VERSION=0.50.1
  LANG=en_US.UTF-8
  COLORTERM=truecolor
  GIT_ASKPASS=/Applications/Cursor.../git/dist/askpass.sh
  VSCODE_GIT_ASKPASS_NODE=/Applications/Cursor...rsor Helper (Plugin)
  VSCODE_GIT_ASKPASS_EXTRA_ARGS=
  VSCODE_GIT_ASKPASS_MAIN=/Applications/Cursor...dist/askpass-main.js
  VSCODE_GIT_IPC_HANDLE=/var/folders/0s/42v7...-git-14a5ce3e7f.sock
  PYENV_VERSION=3.10.16
  PYENV_DIR=/
  VIRTUAL_ENV=/Volumes/Flash Gordo...e/nicktokatana/.venv
  PYENV_HOOK_PATH=/Users/malpern/.pyen.../usr/lib/pyenv/hooks
  VIRTUAL_ENV_PROMPT=.venv
  VSCODE_INJECTION=1
  ZDOTDIR=/Users/malpern
  USER_ZDOTDIR=/Users/malpern
  TERM=xterm-256color
  PS1=.venv%(?:%{[01;32m%...} $(git_prompt_info)
  PYTHONPATH=.
  _=/Users/malpern/.pyen...s/3.10.16/bin/pytest
  PYTEST_VERSION=8.3.4
  PYTEST_CURRENT_TEST=tests/dts/test_perfo...e_performance (call)
[DtsPreprocessor] Temp file: /var/folders/0s/42v7yl697hn0l1cdnx0vrvyr0000gn/T/tmpt2bok5jl.dts
[DtsPreprocessor] Temp file contents:
#include <dt-bindings/zmk/matrix_transform.h>

/ {
    chosen {
        zmk,matrix_transform = &default_transform;
    };

    default_transform: matrix_transform {
        compatible = "zmk,matrix-transform";
        rows = <4>;
        columns = <12>;
        map = <
            RC(0,0)  RC(0,1)  RC(0,2)  RC(0,3)  RC(0,4)  RC(0,5)  RC(0,6)  RC(0,7)  RC(0,8)  RC(0,9)  RC(0,10) RC(0,11)
            RC(1,0)  RC(1,1)  RC(1,2)  RC(1,3)  RC(1,4)  RC(1,5)  RC(1,6)  RC(1,7)  RC(1,8)  RC(1,9)  RC(1,10) RC(1,11)
            RC(2,0)  RC(2,1)  RC(2,2)  RC(2,3)  RC(2,4)  RC(2,5)  RC(2,6)  RC(2,7)  RC(2,8)  RC(2,9)  RC(2,10) RC(2,11)
            RC(3,0)  RC(3,1)  RC(3,2)  RC(3,3)  RC(3,4)  RC(3,5)  RC(3,6)  RC(3,7)  RC(3,8)  RC(3,9)  RC(3,10) RC(3,11)
        >;
    };

    behaviors {
        mt: mod_tap {
            compatible = "zmk,behavior-hold-tap";
            tapping-term-ms = <200>;
            #binding-cells = <2>;
        };
        
        lt: layer_tap {
            compatible = "zmk,behavior-hold-tap";
            tapping-term-ms = <200>;
            #binding-cells = <2>;
        };
        
        macro_a: macro_a {
            compatible = "zmk,behavior-macro";
            #binding-cells = <0>;
            bindings = <&kp A &kp B>;
        };
        
        macro_b: macro_b {
            compatible = "zmk,behavior-macro";
            #binding-cells = <0>;
            bindings = <&kp C &kp D>;
        };
        
        unicode: unicode {
            compatible = "zmk,behavior-unicode";
            #binding-cells = <1>;
        };
        
        uc_string: unicode_string {
            compatible = "zmk,behavior-unicode-string";
            #binding-cells = <1>;
            strings = <
                "smile" "ðŸ˜Š"
                "heart" "â¤ï¸"
            >;
        };
    };

    keymap {
        compatible = "zmk,keymap";
        
        default_layer {
            bindings = <
                &mt LSHIFT A  &kp B        &macro_a     &kp D         &lt 1 E      &kp F
                &kp G         &kp H        &kp I        &kp J         &kp K        &kp L
                &kp M         &kp N        &kp O        &kp P         &kp Q        &kp R
                &kp S         &kp T        &kp U        &kp V         &kp W        &kp X
            >;
        };
        
        lower_layer {
            bindings = <
                &kp N1        &kp N2       &kp N3       &kp N4        &kp N5       &kp N6
                &kp N7        &kp N8       &kp N9       &kp N0        &kp MINUS    &kp EQUAL
                &kp F1        &kp F2       &kp F3       &kp F4        &kp F5       &kp F6
                &kp F7        &kp F8       &kp F9       &kp F10       &kp F11      &kp F12
            >;
        };
        
        raise_layer {
            bindings = <
                &kp EXCLAMATION &kp AT     &kp HASH     &kp DOLLAR    &kp PERCENT  &kp CARET
                &kp AMPERSAND   &kp STAR   &kp LPAR     &kp RPAR      &kp UNDER    &kp PLUS
                &kp F1          &kp F2     &kp F3       &kp F4        &kp F5       &kp F6
                &kp F7          &kp F8     &kp F9       &kp F10       &kp F11      &kp F12
            >;
        };
        
        adjust_layer {
            bindings = <
                &kp RESET      &kp BOOTLOADER &kp NONE  &kp NONE      &kp NONE     &kp NONE
                &kp NONE       &kp NONE       &kp NONE  &kp NONE      &kp NONE     &kp NONE
                &kp NONE       &kp NONE       &kp NONE  &kp NONE      &kp NONE     &kp NONE
                &kp NONE       &kp NONE       &kp NONE  &kp NONE      &kp NONE     &kp NONE
            >;
        };
    };

    combos {
        compatible = "zmk,combos";
        
        combo_esc {
            timeout-ms = <50>;
            key-positions = <0 1>;
            bindings = <&kp ESC>;
        };
        
        combo_tab {
            timeout-ms = <50>;
            key-positions = <1 2>;
            bindings = <&kp TAB>;
        };
        
        combo_enter {
            timeout-ms = <50>;
            key-positions = <2 3>;
            bindings = <&kp ENTER>;
        };
    };

    conditional_layers {
        compatible = "zmk,conditional-layers";
        
        tri_layer {
            if-layers = <1 2>;
            then-layer = <3>;
        };
    };
}; 
[DtsPreprocessor] cpp command: ['/usr/bin/clang', '-E', '-nostdinc', '-undef', '-x', 'assembler-with-cpp', '/var/folders/0s/42v7yl697hn0l1cdnx0vrvyr0000gn/T/tmpt2bok5jl.dts']
=========================== short test summary info ============================
FAILED tests/dts/test_end_to_end.py::test_keymap_with_unicode - AssertionErro...
FAILED tests/dts/test_end_to_end.py::test_error_handling - AssertionError: Re...
FAILED tests/dts/test_extractor.py::test_extract_invalid_content - converter....
FAILED tests/dts/test_integration.py::test_full_pipeline_error_handling - con...
FAILED tests/dts/test_performance.py::test_preprocessor_performance - convert...
FAILED tests/dts/test_performance.py::test_parser_performance - converter.dts...
FAILED tests/dts/test_performance.py::test_extractor_performance - converter....
FAILED tests/dts/test_performance.py::test_full_pipeline_performance - conver...
========================= 8 failed, 64 passed in 0.76s =========================
