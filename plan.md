# ZMK-to-Kanata Converter Project

## Project Overview

This project converts a ZMK keymap file (generated by Nick's Keymap Editor) into a Kanata configuration file. This allows you to visually design keymaps using Nick's tool and then use those configurations with Kanata on your Mac (or other platforms). The converter will initially support:

- **Basic key remapping:** One-to-one keycode conversion.
- **Layer support:** Multiple, simple layers.
- **Simple tap-hold / tap-hold-press behaviors:** Standard timing-based actions.
- **Straightforward macros:** Sequential keycode lists.

> **Note:** Advanced features such as hierarchical conditionals, hardware-specific flags, rotary encoder mappings, and context-sensitive behaviors are **not** supported. These limitations are documented below.

---

## Implementation Approach

The converter is divided into three main modules:
1. **Parser Module:** Reads and parses the ZMK keymap file into an Intermediate Representation (IR).
2. **Transformer Module:** Converts the IR into Kanata's DSL (domain-specific language).
3. **Output Module:** Writes the Kanata configuration to an output file.

A Test Driven Development (TDD) approach is used. For each module, unit tests are written first to define expected behavior before implementation.

---

## Key Concerns Addressed

### 1. Ambiguity in Input Formats

**Specification:**  
- **Expected Format:**  
  The input file is assumed to be a ZMK keymap file in a devicetree-style format. A basic ZMK configuration might include:
  - **Global Settings:** Timing values like tap-time and hold-time.
  - **Layer Definitions:** One or more layers listing key bindings.
  - **Key Behaviors:** Simple definitions for tap-hold or tap-hold-press actions.

- **Example Snippet:**
~~~~dts
/ {
    global {
        tap-time = <200>;
        hold-time = <250>;
    };
    layer@0 {
        bindings = <
            &kp A &kp B &kp C
        >;
    };
};
~~~~

- **Resources:**  
  - ZMK Firmware Documentation  
  - Nick Coutsos Keymap Editor

*Developer Note:* Only the basic elements (global settings, layer definitions, and simple key behaviors) will be parsed. Advanced nested or conditional properties are not supported in this version.

---

### 2. Error Handling and Edge Cases

**Error Handling Strategy:**  
- **Malformed Input:**  
  - The parser must detect missing required fields (e.g., missing global timing values or layer definitions) and raise descriptive exceptions.
- **Unsupported Features:**  
  - If advanced constructs (e.g., nested conditionals) are encountered, log a warning and skip those sections.
- **Test Coverage:**  
  - Unit tests should simulate malformed input and ensure the converter either fails gracefully with an error message or ignores unsupported elements.

**Tasks:**  
- Write tests in `tests/test_error_handling.py` for cases such as missing fields or unexpected syntax.
- Implement custom exception classes (e.g., `ZMKParseError`) in the parser module.

---

### 5. Documentation of Internal Conventions

**Internal Conventions:**  
- **Intermediate Representation (IR):**  
  Define classes (in `model/keymap_model.py`) with clear field names:
  - `GlobalSettings` with attributes like `tap_time` and `hold_time`.
  - `Layer` with attributes `name` and `keys` (a list of key mappings).
  - `KeyBehavior` with attributes such as `base_key`, `tap_action`, and `hold_action`.

- **Mapping Rules:**  
  Create a mapping table for translating ZMK elements to Kanata DSL constructs:

  | ZMK Element                 | Kanata DSL Equivalent                                        |
  |-----------------------------|--------------------------------------------------------------|
  | Global tap-time            | `(defvar tap-time <value>)`                                  |
  | Global hold-time           | `(defvar hold-time <value>)`                                 |
  | Single layer with bindings | `(deflayer <layer-name> <key1> <key2> ...)`                  |
  | Tap-hold behavior          | `(defalias <key> (tap-hold $tap-time $hold-time <tap> <hold>))` |

- **Documentation:**  
  Create a `CONVENTIONS.md` file in the repository that explains these internal rules and naming conventions. Include docstrings in the IR classes within `model/keymap_model.py`.

---

## Environment Setup (Using uv)

We will use **uv** to manage the Python virtual environment.

- [✅] **Task 1: Install uv and Create a Virtual Environment**
  - Install uv globally:
    ```
    pip install uv
    ```
  - Create a new environment:
    ```
    uv new zmk-kanata-env
    ```
  - Activate the environment:
    - On macOS/Linux:
      ```
      source zmk-kanata-env/bin/activate
      ```
    - On Windows:
      ```
      zmk-kanata-env\Scripts\activate
      ```
  - **Reference:** uv on PyPI

- [✅] **Task 2: Initialize Git Repository and Create .gitignore**
  - Run:
    ```
    git init
    ```
  - Create a `.gitignore` that excludes the virtual environment folder and common Python artifacts.

- [✅] **Task 3: Create GitHub Repository**
  - Create repository
  - Push initial project structure
  - Set up basic documentation

---

## Project Folder Structure ✅

```
converter/
├── parser/
│   ├── __init__.py
│   └── zmk_parser.py
├── transformer/
│   ├── __init__.py
│   └── kanata_transformer.py
├── output/
│   ├── __init__.py
│   └── file_writer.py
├── model/
│   ├── __init__.py
│   └── keymap_model.py
├── tests/
│   ├── test_basic_remap.py
│   ├── test_layer_support.py
│   ├── test_taphold.py
│   ├── test_error_handling.py
│   └── test_conventions.py
├── CONVENTIONS.md
└── main.py
```

---

## End-to-End Feature Implementation Checklist

### Phase 1: Basic Key Remapping

- [✅] **Task 3:** Create a basic ZMK sample file (`sample_basic.zmk`) with one layer and simple key-to-key assignments.
- [✅] **Task 4:** Write unit tests in `tests/test_basic_remap.py` to verify that the parser produces the correct IR from `sample_basic.zmk`.
- [✅] **Task 5:** Implement basic parser functionality in `parser/zmk_parser.py` for simple remappings.
- [✅] **Task 6:** Write tests in `tests/test_basic_remap.py` for transforming the IR into a Kanata DSL string (ensure valid `(deflayer ...)` block).
- [✅] **Task 7:** Implement the basic transformer in `transformer/kanata_transformer.py`.
- [✅] **Task 8:** Write tests for the output module (file writing) in `tests/test_basic_remap.py`.
- [✅] **Task 9:** Implement the output module in `output/file_writer.py`.
- [ ] **Task 10:** Create an end-to-end integration test in `tests/integration_tests.py` that processes `sample_basic.zmk` and validates the final output.

---

### Phase 2: Layer Support

- [✅] **Task 11:** Create a ZMK sample file with multiple layers (`sample_layers.zmk`).
- [✅] **Task 12:** Write unit tests in `tests/test_layer_support.py` to verify multiple layer parsing.
  - Created `test_layer_parsing.py` with tests for layer name extraction, bindings section extraction, and multiple layer handling
  - All tests passing with proper regex patterns for layer structure
- [✅] **Task 13:** Extend the parser in `parser/zmk_parser.py` to support multiple layers.
  - Implemented `LayerParser` class in `layer_parser.py`
  - Successfully extracts keymap sections and individual layers
  - Handles whitespace and nested structures correctly
- [✅] **Task 14:** Write tests in `tests/test_layer_support.py` for transforming multiple layers.
  - Created `test_layer_transformer.py` with comprehensive tests
  - Tests cover individual binding transformation, matrix parsing, and multi-layer handling
  - Implemented `LayerTransformer` class with key mapping and layer transformation logic
- [✅] **Task 15:** Update integration tests to include `sample_layers.zmk` and validate output.
  - Created `test_layer_integration.py` for end-to-end testing
  - Updated parser to handle includes and global section
  - Successfully converts multi-layer ZMK files to Kanata format

---

### Phase 3: Simple Tap-Hold / Tap-Hold-Press Behavior

- [ ] **Task 16:** Create a ZMK sample file with tap-hold actions (`sample_taphold.zmk`).
- [ ] **Task 17:** Write unit tests in `tests/test_taphold.py` to verify tap-hold behavior extraction.
- [ ] **Task 18:** Extend the parser to support tap-hold behaviors.
- [ ] **Task 19:** Write tests in `tests/test_taphold.py` for transforming tap-hold behaviors into `(defalias ...)` lines.
- [ ] **Task 20:** Update the transformer to handle tap-hold behavior conversions.
- [ ] **Task 21:** Update integration tests to process `sample_taphold.zmk` and validate output.

---

### Phase 4: Documentation and Final Integration

- [ ] **Task 22:** Document supported features and list limitations in the README and in `CONVENTIONS.md`.
- [ ] **Task 23:** Write unit tests in `tests/test_error_handling.py` to simulate malformed inputs and ensure proper error reporting.
- [ ] **Task 24:** Write unit tests in `tests/test_conventions.py` to ensure IR consistency.
- [ ] **Task 25:** Refactor and run the full test suite.
- [ ] **Task 26:** Update `main.py` to provide a CLI for the converter.
- [ ] **Task 27:** Finalize the project README with usage instructions and resource links.
- [ ] **Task 28:** Package and push the final version to Git.

---

## Resources and References

- **ZMK and Nick's Keymap Editor:**
  - ZMK Firmware Documentation
  - Nick Coutsos Keymap Editor

- **Kanata Configuration:**
  - Kanata GitHub Repository

- **Test Driven Development:**
  - TDD Tutorial by Agile Alliance
  - pytest Documentation

- **Python Parsing:**
  - Python re Module Documentation

- **uv for Virtual Environments:**
  - uv on PyPI

- **Python Classes:**
  - Python Classes Tutorial

---

This document outlines an end-to-end, feature-by-feature TDD implementation approach for the converter project, addressing ambiguities in the input format, robust error handling, and detailed internal conventions. Happy coding!