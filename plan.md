# ZMK-to-Kanata Converter Project

## Project Overview

This project converts a ZMK keymap file (generated by Nick's Keymap Editor) into a Kanata configuration file. This allows you to visually design keymaps using Nick's tool and then use those configurations with Kanata on your Mac (or other platforms). The converter will initially support:

- **Basic key remapping:** One-to-one keycode conversion.
- **Layer support:** Multiple, simple layers.
- **Simple tap-hold / tap-hold-press behaviors:** Standard timing-based actions.
- **Straightforward macros:** Sequential keycode lists.

> **Note:** Advanced features such as hierarchical conditionals, hardware-specific flags, rotary encoder mappings, and context-sensitive behaviors are **not** supported. These limitations are documented below.

---

## Implementation Approach

The converter is divided into three main modules:
1. **Parser Module:** Reads and parses the ZMK keymap file into an Intermediate Representation (IR).
2. **Transformer Module:** Converts the IR into Kanata's DSL (domain-specific language).
3. **Output Module:** Writes the Kanata configuration to an output file.

A Test Driven Development (TDD) approach is used. For each module, unit tests are written first to define expected behavior before implementation.

---

## Key Concerns Addressed

### 1. Ambiguity in Input Formats

**Specification:**  
- **Expected Format:**  
  The input file is assumed to be a ZMK keymap file in a devicetree-style format. A basic ZMK configuration might include:
  - **Global Settings:** Timing values like tap-time and hold-time.
  - **Layer Definitions:** One or more layers listing key bindings.
  - **Key Behaviors:** Simple definitions for tap-hold or tap-hold-press actions.

- **Example Snippet:**
~~~~dts
/ {
    global {
        tap-time = <200>;
        hold-time = <250>;
    };
    layer@0 {
        bindings = <
            &kp A &kp B &kp C
        >;
    };
};
~~~~

- **Resources:**  
  - ZMK Firmware Documentation  
  - Nick Coutsos Keymap Editor

*Developer Note:* Only the basic elements (global settings, layer definitions, and simple key behaviors) will be parsed. Advanced nested or conditional properties are not supported in this version.

---

### 2. Error Handling and Edge Cases

**Error Handling Strategy:**  
- **Malformed Input:**  
  - The parser must detect missing required fields (e.g., missing global timing values or layer definitions) and raise descriptive exceptions.
- **Unsupported Features:**  
  - If advanced constructs (e.g., nested conditionals) are encountered, log a warning and skip those sections.
- **Test Coverage:**  
  - Unit tests should simulate malformed input and ensure the converter either fails gracefully with an error message or ignores unsupported elements.

**Tasks:**  
- Write tests in `tests/test_error_handling.py` for cases such as missing fields or unexpected syntax.
- Implement custom exception classes (e.g., `ZMKParseError`) in the parser module.

---

### 5. Documentation of Internal Conventions

**Internal Conventions:**  
- **Intermediate Representation (IR):**  
  Define classes (in `model/keymap_model.py`) with clear field names:
  - `GlobalSettings` with attributes like `tap_time` and `hold_time`.
  - `Layer` with attributes `name` and `keys` (a list of key mappings).
  - `KeyBehavior` with attributes such as `base_key`, `tap_action`, and `hold_action`.

- **Mapping Rules:**  
  Create a mapping table for translating ZMK elements to Kanata DSL constructs:

  | ZMK Element                 | Kanata DSL Equivalent                                        |
  |-----------------------------|--------------------------------------------------------------|
  | Global tap-time            | `(defvar tap-time <value>)`                                  |
  | Global hold-time           | `(defvar hold-time <value>)`                                 |
  | Single layer with bindings | `(deflayer <layer-name> <key1> <key2> ...)`                  |
  | Tap-hold behavior          | `(defalias <key> (tap-hold $tap-time $hold-time <tap> <hold>))` |

- **Documentation:**  
  Create a `CONVENTIONS.md` file in the repository that explains these internal rules and naming conventions. Include docstrings in the IR classes within `model/keymap_model.py`.

---

## Environment Setup (Using uv)

We will use **uv** to manage the Python virtual environment.

- [✅] **Task 1: Install uv and Create a Virtual Environment**
  - Install uv globally:
    ```
    pip install uv
    ```
  - Create a new environment:
    ```
    uv new zmk-kanata-env
    ```
  - Activate the environment:
    - On macOS/Linux:
      ```
      source zmk-kanata-env/bin/activate
      ```
    - On Windows:
      ```
      zmk-kanata-env\Scripts\activate
      ```
  - **Reference:** uv on PyPI

- [✅] **Task 2: Initialize Git Repository and Create .gitignore**
  - Run:
    ```
    git init
    ```
  - Create a `.gitignore` that excludes the virtual environment folder and common Python artifacts.

- [✅] **Task 3: Create GitHub Repository**
  - Create repository
  - Push initial project structure
  - Set up basic documentation

---

## Project Folder Structure ✅

```
converter/
├── parser/
│   ├── __init__.py
│   └── zmk_parser.py
├── transformer/
│   ├── __init__.py
│   └── kanata_transformer.py
├── output/
│   ├── __init__.py
│   └── file_writer.py
├── model/
│   ├── __init__.py
│   └── keymap_model.py
├── tests/
│   ├── test_basic_remap.py
│   ├── test_layer_support.py
│   ├── test_taphold.py
│   ├── test_error_handling.py
│   └── test_conventions.py
├── CONVENTIONS.md
└── main.py
```

---

## End-to-End Feature Implementation Checklist

### Phase 1: Basic Key Remapping

- [✅] **Task 3:** Create a basic ZMK sample file (`sample_basic.zmk`) with one layer and simple key-to-key assignments.
- [✅] **Task 4:** Write unit tests in `tests/test_basic_remap.py` to verify that the parser produces the correct IR from `sample_basic.zmk`.
- [✅] **Task 5:** Implement basic parser functionality in `parser/zmk_parser.py` for simple remappings.
- [✅] **Task 6:** Write tests in `tests/test_basic_remap.py` for transforming the IR into a Kanata DSL string (ensure valid `(deflayer ...)` block).
- [✅] **Task 7:** Implement the basic transformer in `transformer/kanata_transformer.py`.
- [✅] **Task 8:** Write tests for the output module (file writing) in `tests/test_basic_remap.py`.
- [✅] **Task 9:** Implement the output module in `output/file_writer.py`.
- [ ] **Task 10:** Create an end-to-end integration test in `tests/integration_tests.py` that processes `sample_basic.zmk` and validates the final output.

### Phase 2: Layer Support

- [✅] **Task 11:** Create a ZMK sample file with multiple layers (`sample_layers.zmk`).
- [✅] **Task 12:** Write unit tests in `tests/test_layer_support.py` to verify multiple layer parsing.
  - Created `test_layer_parsing.py` with tests for layer name extraction, bindings section extraction, and multiple layer handling
  - All tests passing with proper regex patterns for layer structure
- [✅] **Task 13:** Extend the parser in `parser/zmk_parser.py` to support multiple layers.
  - Implemented `LayerParser` class in `layer_parser.py`
  - Successfully extracts keymap sections and individual layers
  - Handles whitespace and nested structures correctly
- [✅] **Task 14:** Write tests in `tests/test_layer_support.py` for transforming multiple layers.
  - Created `test_layer_transformer.py` with comprehensive tests
  - Tests cover individual binding transformation, matrix parsing, and multi-layer handling
  - Implemented `LayerTransformer` class with key mapping and layer transformation logic
- [✅] **Task 15:** Update integration tests to include `sample_layers.zmk` and validate output.
  - Created `test_layer_integration.py` for end-to-end testing
  - Updated parser to handle includes and global section
  - Successfully converts multi-layer ZMK files to Kanata format

### Phase 3: Tap-Hold / Hold-Tap Behaviors

#### 3.1 Basic Hold-Tap Parsing
- [✅] Task 16: Create parser for basic hold-tap behavior definitions
  - Parse behavior name and label
  - Parse basic properties (compatible, binding-cells)
  - Unit tests for basic property extraction

#### 3.2 Hold-Tap Configuration Parsing
- [✅] Task 17: Extend parser to handle hold-tap configuration
  - Add configuration fields to HoldTapBehavior class
  - Update parser to extract timing parameters
  - Add validation for flavor values
  - Unit tests for configuration parsing
  - Test with real-world examples from sample file

#### 3.3 Advanced Hold-Tap Features
- [✅] Task 18: Support advanced hold-tap features
  - Add fields to HoldTapBehavior:
    - hold_trigger_key_positions: List[int]
    - hold_trigger_on_release: bool
    - retro_tap: bool
  - Update parser to handle array-style parameters
  - Add support for boolean flags
  - Add validation for key position indices
  - Test with Mac-style home row mods example
  - Test error cases (invalid positions, malformed arrays)

#### 3.4 Keymap Integration
- [✅] Task 19: Integrate hold-tap behaviors with keymap parsing
  - Add HoldTapBinding class to model hold-tap parameters
  - Update KeyMapping to support hold-tap bindings
  - Add hold-tap binding parsing to LayerParser
  - Add parse_bindings_matrix method for cleaner binding parsing
  - Test with mixed bindings and home row mods
  - Successfully parse Mac-style home row mods configuration

#### 3.5 Kanata Translation
- [ ] Task 20: Implement translation to Kanata tap-hold syntax
  - Create mapping between ZMK and Kanata tap-hold configurations
  - Handle different flavors and timing parameters
  - Unit tests for translation accuracy

#### 3.6 Integration and Testing
- [ ] Task 21: Create comprehensive integration tests
  - Test complete hold-tap configurations
  - Verify correct translation of Mac-style home row mods
  - End-to-end tests with sample files

### Phase 4: Combos
...

## Resources and References

- **ZMK and Nick's Keymap Editor:**
  - ZMK Firmware Documentation
  - Nick Coutsos Keymap Editor

- **Kanata Configuration:**
  - Kanata GitHub Repository

- **Test Driven Development:**
  - TDD Tutorial by Agile Alliance
  - pytest Documentation

- **Python Parsing:**
  - Python re Module Documentation

- **uv for Virtual Environments:**
  - uv on PyPI

- **Python Classes:**
  - Python Classes Tutorial

---

This document outlines an end-to-end, feature-by-feature TDD implementation approach for the converter project, addressing ambiguities in the input format, robust error handling, and detailed internal conventions. Happy coding!