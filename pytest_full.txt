============================= test session starts ==============================
platform darwin -- Python 3.10.16, pytest-8.3.4, pluggy-1.5.0
rootdir: /Volumes/FlashGordon/Dropbox/code/nicktokatana
configfile: pyproject.toml
testpaths: tests
plugins: anyio-4.7.0
collected 72 items

tests/dts/test_ast.py .....                                              [  6%]
tests/dts/test_end_to_end.py FFFFFF                                      [ 15%]
tests/dts/test_extractor.py FFFFF                                        [ 22%]
tests/dts/test_integration.py FFFFF                                      [ 29%]
tests/dts/test_parser.py ...F.......F.                                   [ 47%]
tests/dts/test_performance.py FFFF                                       [ 52%]
tests/dts/test_preprocessor.py FFFFFF.F...                               [ 68%]
tests/test_dts_parser.py FF......                                        [ 79%]
tests/test_dts_preprocessor.py FFF                                       [ 83%]
tests/test_kanata_converter.py .....                                     [ 90%]
tests/test_main.py FFFFF..                                               [100%]

=================================== FAILURES ===================================
______________________________ test_simple_keymap ______________________________

    def test_simple_keymap():
        """Test parsing a simple keymap file."""
        content = """
        / {
            keymap {
                compatible = "zmk,keymap";
    
                default_layer {
                    bindings = <
                        &kp A &kp B &kp C
                        &kp D &kp E &kp F
                    >;
                };
            };
        };
        """
    
        # Parse and extract
        parser = DtsParser()
        ast = parser.parse(content)
    
        extractor = KeymapExtractor()
>       config = extractor.extract(ast)

tests/dts/test_end_to_end.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
converter/dts/extractor.py:77: in extract
    self._extract_layers(keymap_node)
converter/dts/extractor.py:300: in _extract_layers
    layer = self._create_layer(child)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <converter.dts.extractor.KeymapExtractor object at 0x103ea0eb0>
node = DtsNode(name='default_layer', parent=DtsNode(name='keymap', parent=DtsNode(name='/', parent=None, children={'keymap': ...='bindings', value=['&kp', 'A', '&kp', 'B', '&kp', 'C', '&kp', 'D', '&kp', 'E', '&kp', 'F'], type='array')}, labels={})

    def _create_layer(self, node: DtsNode) -> Optional[Layer]:
        """Create a layer instance from a node (called in Pass 3)."""
        bindings_prop = node.properties.get("bindings")
        if not bindings_prop or bindings_prop.type != "array":
            print(f"Warning: Layer '{node.name}' missing valid bindings property.")
            return None
    
        # Parse bindings now, all behaviors should be available
        parsed_bindings = self._parse_bindings(bindings_prop.value)
>       return Layer(name=node.name, bindings=parsed_bindings)
E       TypeError: Layer.__init__() missing 1 required positional argument: 'index'

converter/dts/extractor.py:320: TypeError
______________________ test_complex_keymap_with_behaviors ______________________

    def test_complex_keymap_with_behaviors():
        """Test parsing a complex keymap with behaviors."""
        content = """
        / {
            behaviors {
                mt: mod_tap {
                    compatible = "zmk,behavior-hold-tap";
                    tapping-term-ms = <200>;
                    #binding-cells = <2>;
                };
    
                macro_a: macro_a {
                    compatible = "zmk,behavior-macro";
                    #binding-cells = <0>;
                    bindings = <&kp A &kp B>;
                };
    
                lt: layer_tap {
                    compatible = "zmk,behavior-hold-tap";
                    tapping-term-ms = <200>;
                    #binding-cells = <2>;
                };
            };
    
            keymap {
                compatible = "zmk,keymap";
    
                default_layer {
                    bindings = <
                        &mt LSHIFT A  &kp B        &macro_a
                        &kp D         &lt 1 E      &kp F
                    >;
                };
    
                lower_layer {
                    bindings = <
                        &kp N1  &kp N2  &kp N3
                        &kp N4  &kp N5  &kp N6
                    >;
                };
            };
        };
        """
    
        # Parse and extract
        parser = DtsParser()
        ast = parser.parse(content)
    
        extractor = KeymapExtractor()
>       config = extractor.extract(ast)

tests/dts/test_end_to_end.py:102: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
converter/dts/extractor.py:77: in extract
    self._extract_layers(keymap_node)
converter/dts/extractor.py:300: in _extract_layers
    layer = self._create_layer(child)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <converter.dts.extractor.KeymapExtractor object at 0x103ea1db0>
node = DtsNode(name='default_layer', parent=DtsNode(name='keymap', parent=DtsNode(name='/', parent=None, children={'behaviors...value=['&mt', 'LSHIFT', 'A', '&kp', 'B', '&macro_a', '&kp', 'D', '&lt', 1, 'E', '&kp', 'F'], type='array')}, labels={})

    def _create_layer(self, node: DtsNode) -> Optional[Layer]:
        """Create a layer instance from a node (called in Pass 3)."""
        bindings_prop = node.properties.get("bindings")
        if not bindings_prop or bindings_prop.type != "array":
            print(f"Warning: Layer '{node.name}' missing valid bindings property.")
            return None
    
        # Parse bindings now, all behaviors should be available
        parsed_bindings = self._parse_bindings(bindings_prop.value)
>       return Layer(name=node.name, bindings=parsed_bindings)
E       TypeError: Layer.__init__() missing 1 required positional argument: 'index'

converter/dts/extractor.py:320: TypeError
___________________________ test_keymap_with_unicode ___________________________

    def test_keymap_with_unicode():
        """Test parsing a keymap with unicode behaviors."""
        content = """
        / {
            behaviors {
                unicode: unicode {
                    compatible = "zmk,behavior-unicode";
                    #binding-cells = <1>;
                };
    
                uc_string: unicode_string {
                    compatible = "zmk,behavior-unicode-string";
                    #binding-cells = <1>;
                    strings = <
                        "smile" "😊"
                        "heart" "❤️"
                    >;
                };
            };
    
            keymap {
                compatible = "zmk,keymap";
    
                default_layer {
                    bindings = <
                        &unicode U0001F600  &uc_string smile  &kp A
                        &unicode U2764      &uc_string heart  &kp B
                    >;
                };
            };
        };
        """
    
        # Parse and extract
        parser = DtsParser()
        ast = parser.parse(content)
    
        extractor = KeymapExtractor()
>       config = extractor.extract(ast)

tests/dts/test_end_to_end.py:189: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
converter/dts/extractor.py:77: in extract
    self._extract_layers(keymap_node)
converter/dts/extractor.py:300: in _extract_layers
    layer = self._create_layer(child)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <converter.dts.extractor.KeymapExtractor object at 0x103ea0eb0>
node = DtsNode(name='default_layer', parent=DtsNode(name='keymap', parent=DtsNode(name='/', parent=None, children={'behaviors... '&uc_string', 'smile', '&kp', 'A', '&unicode', 'U2764', '&uc_string', 'heart', '&kp', 'B'], type='array')}, labels={})

    def _create_layer(self, node: DtsNode) -> Optional[Layer]:
        """Create a layer instance from a node (called in Pass 3)."""
        bindings_prop = node.properties.get("bindings")
        if not bindings_prop or bindings_prop.type != "array":
            print(f"Warning: Layer '{node.name}' missing valid bindings property.")
            return None
    
        # Parse bindings now, all behaviors should be available
        parsed_bindings = self._parse_bindings(bindings_prop.value)
>       return Layer(name=node.name, bindings=parsed_bindings)
E       TypeError: Layer.__init__() missing 1 required positional argument: 'index'

converter/dts/extractor.py:320: TypeError
_____________________________ test_error_handling ______________________________

    def test_error_handling():
        """Test error handling with malformed input."""
        # Test missing root node
        with pytest.raises(ValueError, match="Expected root node"):
            parser = DtsParser()
>           parser.parse("keymap { };")

tests/dts/test_end_to_end.py:216: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <converter.dts.parser.DtsParser object at 0x103f10d90>
content = 'keymap { };', file = None

    def parse(self, content: str, file: Optional[str] = None) -> DtsRoot:
        """Parse DTS content into an AST.
    
        Args:
            content: DTS content string
            file: Optional file path for error reporting
    
        Returns:
            DtsRoot object representing the parsed AST
    
        Raises:
            DtsParseError: If the content is not valid DTS
        """
        self.content = content
        self.tokens = []
        self.line_map = []
        self._tokenize(content)
        self.pos = 0
    
        # Check for root node token '/'
        if not self.tokens or self.tokens[0] != "/":
>           raise DtsParseError(
                "DTS must start with root node '/'",
                file=file,
                line=1,
                column=1,
                context=format_error_context(content, 1, 1),
            )
E           converter.dts.error_handler.DtsParseError: DTS must start with root node '/' at line 1, column 1
E           
E           1 | keymap { };
E             | ^
E           
E           Help: Check the DTS syntax and ensure it follows the specification.

converter/dts/parser.py:39: DtsParseError
___________________________ test_keymap_with_combos ____________________________

    def test_keymap_with_combos():
        """Test parsing a keymap with combo behaviors."""
        content = """
        / {
            combos {
                compatible = "zmk,combos";
                combo_esc {
                    timeout-ms = <50>;
                    key-positions = <0 1>;
                    bindings = <&kp ESC>;
                };
                combo_tab {
                    timeout-ms = <50>;
                    key-positions = <1 2>;
                    bindings = <&kp TAB>;
                };
            };
    
            keymap {
                compatible = "zmk,keymap";
    
                default_layer {
                    bindings = <
                        &kp A &kp B &kp C
                        &kp D &kp E &kp F
                    >;
                };
            };
        };
        """
    
        # Parse and extract
        parser = DtsParser()
        ast = parser.parse(content)
    
        extractor = KeymapExtractor()
>       config = extractor.extract(ast)

tests/dts/test_end_to_end.py:285: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
converter/dts/extractor.py:77: in extract
    self._extract_layers(keymap_node)
converter/dts/extractor.py:300: in _extract_layers
    layer = self._create_layer(child)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <converter.dts.extractor.KeymapExtractor object at 0x103e876a0>
node = DtsNode(name='default_layer', parent=DtsNode(name='keymap', parent=DtsNode(name='/', parent=None, children={'combos': ...='bindings', value=['&kp', 'A', '&kp', 'B', '&kp', 'C', '&kp', 'D', '&kp', 'E', '&kp', 'F'], type='array')}, labels={})

    def _create_layer(self, node: DtsNode) -> Optional[Layer]:
        """Create a layer instance from a node (called in Pass 3)."""
        bindings_prop = node.properties.get("bindings")
        if not bindings_prop or bindings_prop.type != "array":
            print(f"Warning: Layer '{node.name}' missing valid bindings property.")
            return None
    
        # Parse bindings now, all behaviors should be available
        parsed_bindings = self._parse_bindings(bindings_prop.value)
>       return Layer(name=node.name, bindings=parsed_bindings)
E       TypeError: Layer.__init__() missing 1 required positional argument: 'index'

converter/dts/extractor.py:320: TypeError
----------------------------- Captured stdout call -----------------------------
Added combo combo_esc: Combo(name='combo_esc', timeout_ms=50, key_positions=[0, 1], binding=Binding(behavior=None, params=['ESC']))
Added combo combo_tab: Combo(name='combo_tab', timeout_ms=50, key_positions=[1, 2], binding=Binding(behavior=None, params=['TAB']))
_____________________ test_keymap_with_conditional_layers ______________________

    def test_keymap_with_conditional_layers():
        """Test parsing a keymap with conditional layers."""
        content = """
        / {
            conditional_layers {
                compatible = "zmk,conditional-layers";
                tri_layer {
                    if-layers = <1 2>;
                    then-layer = <3>;
                };
            };
    
            keymap {
                compatible = "zmk,keymap";
    
                default_layer {
                    bindings = <&kp A &kp B>;
                };
    
                lower_layer {
                    bindings = <&kp N1 &kp N2>;
                };
    
                raise_layer {
                    bindings = <&kp F1 &kp F2>;
                };
    
                adjust_layer {
                    bindings = <&reset &bootloader>;
                };
            };
        };
        """
    
        # Parse and extract
        parser = DtsParser()
        ast = parser.parse(content)
    
        extractor = KeymapExtractor()
>       config = extractor.extract(ast)

tests/dts/test_end_to_end.py:340: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
converter/dts/extractor.py:77: in extract
    self._extract_layers(keymap_node)
converter/dts/extractor.py:300: in _extract_layers
    layer = self._create_layer(child)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <converter.dts.extractor.KeymapExtractor object at 0x1039cfb80>
node = DtsNode(name='default_layer', parent=DtsNode(name='keymap', parent=DtsNode(name='/', parent=None, children={'condition...ren={}, properties={'bindings': DtsProperty(name='bindings', value=['&kp', 'A', '&kp', 'B'], type='array')}, labels={})

    def _create_layer(self, node: DtsNode) -> Optional[Layer]:
        """Create a layer instance from a node (called in Pass 3)."""
        bindings_prop = node.properties.get("bindings")
        if not bindings_prop or bindings_prop.type != "array":
            print(f"Warning: Layer '{node.name}' missing valid bindings property.")
            return None
    
        # Parse bindings now, all behaviors should be available
        parsed_bindings = self._parse_bindings(bindings_prop.value)
>       return Layer(name=node.name, bindings=parsed_bindings)
E       TypeError: Layer.__init__() missing 1 required positional argument: 'index'

converter/dts/extractor.py:320: TypeError
----------------------------- Captured stdout call -----------------------------
Added conditional layer tri_layer: ConditionalLayer(name='tri_layer', if_layers=[1, 2], then_layer=3)
__________________________ test_extract_simple_keymap __________________________

    def test_extract_simple_keymap():
        """Test extracting a simple keymap."""
        content = """
        / {
            keymap {
                compatible = "zmk,keymap";
                default_layer {
                    bindings = <&kp A &kp B &kp C>;
                };
            };
        };
        """
    
        parser = DtsParser()
        ast = parser.parse(content)
        extractor = KeymapExtractor()
>       config = extractor.extract(ast)

tests/dts/test_extractor.py:24: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
converter/dts/extractor.py:77: in extract
    self._extract_layers(keymap_node)
converter/dts/extractor.py:300: in _extract_layers
    layer = self._create_layer(child)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <converter.dts.extractor.KeymapExtractor object at 0x103ea3a30>
node = DtsNode(name='default_layer', parent=DtsNode(name='keymap', parent=DtsNode(name='/', parent=None, children={'keymap': ...erties={'bindings': DtsProperty(name='bindings', value=['&kp', 'A', '&kp', 'B', '&kp', 'C'], type='array')}, labels={})

    def _create_layer(self, node: DtsNode) -> Optional[Layer]:
        """Create a layer instance from a node (called in Pass 3)."""
        bindings_prop = node.properties.get("bindings")
        if not bindings_prop or bindings_prop.type != "array":
            print(f"Warning: Layer '{node.name}' missing valid bindings property.")
            return None
    
        # Parse bindings now, all behaviors should be available
        parsed_bindings = self._parse_bindings(bindings_prop.value)
>       return Layer(name=node.name, bindings=parsed_bindings)
E       TypeError: Layer.__init__() missing 1 required positional argument: 'index'

converter/dts/extractor.py:320: TypeError
_________________________ test_extract_with_behaviors __________________________

    def test_extract_with_behaviors():
        """Test extracting keymap with behaviors."""
        content = """
        / {
            behaviors {
                mt: mod_tap {
                    compatible = "zmk,behavior-hold-tap";
                    tapping-term-ms = <200>;
                };
                macro: macro {
                    compatible = "zmk,behavior-macro";
                    bindings = <&kp A &kp B>;
                };
            };
            keymap {
                default_layer {
                    bindings = <&mt LSHIFT A &macro>;
                };
            };
        };
        """
    
        parser = DtsParser()
        ast = parser.parse(content)
        extractor = KeymapExtractor()
>       config = extractor.extract(ast)

tests/dts/test_extractor.py:58: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
converter/dts/extractor.py:77: in extract
    self._extract_layers(keymap_node)
converter/dts/extractor.py:300: in _extract_layers
    layer = self._create_layer(child)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <converter.dts.extractor.KeymapExtractor object at 0x103f8dae0>
node = DtsNode(name='default_layer', parent=DtsNode(name='keymap', parent=DtsNode(name='/', parent=None, children={'behaviors...properties={'bindings': DtsProperty(name='bindings', value=['&mt', 'LSHIFT', 'A', '&macro'], type='array')}, labels={})

    def _create_layer(self, node: DtsNode) -> Optional[Layer]:
        """Create a layer instance from a node (called in Pass 3)."""
        bindings_prop = node.properties.get("bindings")
        if not bindings_prop or bindings_prop.type != "array":
            print(f"Warning: Layer '{node.name}' missing valid bindings property.")
            return None
    
        # Parse bindings now, all behaviors should be available
        parsed_bindings = self._parse_bindings(bindings_prop.value)
>       return Layer(name=node.name, bindings=parsed_bindings)
E       TypeError: Layer.__init__() missing 1 required positional argument: 'index'

converter/dts/extractor.py:320: TypeError
_________________________ test_extract_multiple_layers _________________________

    def test_extract_multiple_layers():
        """Test extracting keymap with multiple layers."""
        content = """
        / {
            keymap {
                default_layer {
                    bindings = <&kp A &kp B>;
                };
                lower_layer {
                    bindings = <&kp C &kp D>;
                };
                raise_layer {
                    bindings = <&kp E &kp F>;
                };
            };
        };
        """
    
        parser = DtsParser()
        ast = parser.parse(content)
        extractor = KeymapExtractor()
>       config = extractor.extract(ast)

tests/dts/test_extractor.py:92: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
converter/dts/extractor.py:77: in extract
    self._extract_layers(keymap_node)
converter/dts/extractor.py:300: in _extract_layers
    layer = self._create_layer(child)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <converter.dts.extractor.KeymapExtractor object at 0x103e858a0>
node = DtsNode(name='default_layer', parent=DtsNode(name='keymap', parent=DtsNode(name='/', parent=None, children={'keymap': ...ren={}, properties={'bindings': DtsProperty(name='bindings', value=['&kp', 'A', '&kp', 'B'], type='array')}, labels={})

    def _create_layer(self, node: DtsNode) -> Optional[Layer]:
        """Create a layer instance from a node (called in Pass 3)."""
        bindings_prop = node.properties.get("bindings")
        if not bindings_prop or bindings_prop.type != "array":
            print(f"Warning: Layer '{node.name}' missing valid bindings property.")
            return None
    
        # Parse bindings now, all behaviors should be available
        parsed_bindings = self._parse_bindings(bindings_prop.value)
>       return Layer(name=node.name, bindings=parsed_bindings)
E       TypeError: Layer.__init__() missing 1 required positional argument: 'index'

converter/dts/extractor.py:320: TypeError
________________________ test_extract_complex_bindings _________________________

    def test_extract_complex_bindings():
        """Test extracting complex bindings."""
        content = """
        / {
            behaviors {
                mt: mod_tap {
                    compatible = "zmk,behavior-hold-tap";
                    tapping-term-ms = <200>;
                };
                lt: layer_tap {
                    compatible = "zmk,behavior-hold-tap";
                    tapping-term-ms = <200>;
                };
            };
            keymap {
                default_layer {
                    bindings = <
                        &mt LSHIFT A
                        &lt 1 B
                        &kp C
                    >;
                };
            };
        };
        """
    
        parser = DtsParser()
        ast = parser.parse(content)
        extractor = KeymapExtractor()
>       config = extractor.extract(ast)

tests/dts/test_extractor.py:132: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
converter/dts/extractor.py:77: in extract
    self._extract_layers(keymap_node)
converter/dts/extractor.py:300: in _extract_layers
    layer = self._create_layer(child)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <converter.dts.extractor.KeymapExtractor object at 0x103e94370>
node = DtsNode(name='default_layer', parent=DtsNode(name='keymap', parent=DtsNode(name='/', parent=None, children={'behaviors...ings': DtsProperty(name='bindings', value=['&mt', 'LSHIFT', 'A', '&lt', 1, 'B', '&kp', 'C'], type='array')}, labels={})

    def _create_layer(self, node: DtsNode) -> Optional[Layer]:
        """Create a layer instance from a node (called in Pass 3)."""
        bindings_prop = node.properties.get("bindings")
        if not bindings_prop or bindings_prop.type != "array":
            print(f"Warning: Layer '{node.name}' missing valid bindings property.")
            return None
    
        # Parse bindings now, all behaviors should be available
        parsed_bindings = self._parse_bindings(bindings_prop.value)
>       return Layer(name=node.name, bindings=parsed_bindings)
E       TypeError: Layer.__init__() missing 1 required positional argument: 'index'

converter/dts/extractor.py:320: TypeError
_________________________ test_extract_invalid_content _________________________

    def test_extract_invalid_content():
        """Test extracting invalid content."""
        content = """
        / {
            keymap {
                invalid_layer {
                    # Missing bindings
                };
            };
        };
        """
    
        parser = DtsParser()
>       ast = parser.parse(content)

tests/dts/test_extractor.py:166: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
converter/dts/parser.py:66: in parse
    self._parse_node_body(parsed_root_node)
converter/dts/parser.py:567: in _parse_node_body
    self._parse_node_body(child)
converter/dts/parser.py:567: in _parse_node_body
    self._parse_node_body(child)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <converter.dts.parser.DtsParser object at 0x103f8f280>
node = DtsNode(name='invalid_layer', parent=None, children={}, properties={}, labels={})

    def _parse_node_body(self, node: DtsNode) -> None:
        """Parse the body of a DTS node.
    
        Args:
            node: DtsNode to parse body into
    
        Raises:
            DtsParseError: If node body format is invalid
        """
        while self.pos < len(self.tokens):
            token = self.tokens[self.pos]
    
            if token == "}":
                self.pos += 1
                return
            elif token == "{":
                line, col = self._get_pos_info(self.pos)
                raise DtsParseError(
                    "Unexpected '{' in node body",
                    line=line,
                    column=col,
                    context=format_error_context(self.content, line, col),
                    help_text="Node definitions must have a label or reference",
                )
    
            if token == ";":  # Handle empty statements
                self.pos += 1
                continue
    
            # Handle boolean properties (e.g., "prop_name;")
            if self.pos + 1 < len(self.tokens) and self.tokens[self.pos + 1] == ";":
                name = token
                # Basic check for valid property name (alphanumeric, _, -)
                # This helps distinguish from stray semicolons or other constructs.
                # The tokenizer should ideally guarantee 'token' is a potential identifier here.
                if (
                    name
                    and all(c.isalnum() or c in ("_", "-") for c in name)
                    and name[0] != "-"
                ):  # Ensure it's a valid C-style identifier
                    prop = DtsProperty(name=name, value=True, type="boolean")
                    node.add_property(prop)
                    self.pos += 2  # Consume name and ';'
                    continue
    
            # Handle properties with assignment (e.g. "prop_name = value;")
            if self.pos + 2 < len(self.tokens) and self.tokens[self.pos + 1] == "=":
                name = token
                value_token = self.tokens[self.pos + 2]
                try:
                    prop = self._parse_property_value(name, value_token)
                    node.add_property(prop)
                    self.pos += 3
    
                    # Check for additional comma-separated array cells
                    if prop.type == "array":
                        while (
                            self.pos < len(self.tokens) and self.tokens[self.pos] == ","
                        ):
                            self.pos += 1
                            if self.pos >= len(self.tokens):
                                line, col = self._get_pos_info(self.pos - 1)
                                raise DtsParseError(
                                    "Unexpected end of file after ',' in property value",
                                    line=line,
                                    column=col,
                                    context=format_error_context(
                                        self.content, line, col
                                    ),
                                )
                            next_value_token = self.tokens[self.pos]
                            # Parse the next array cell. We expect it to be an array itself.
                            # _parse_property_value will return a DtsProperty, we need its value.
                            additional_prop_part = self._parse_property_value(
                                "_{temp}", next_value_token
                            )
                            if additional_prop_part.type == "array":
                                if isinstance(prop.value, list) and isinstance(
                                    additional_prop_part.value, list
                                ):
                                    prop.value.extend(additional_prop_part.value)
                                else:
                                    # This case should ideally not happen if tokens are well-formed <...>
                                    line, col = self._get_pos_info(self.pos)
                                    raise DtsParseError(
                                        f"Expected array type for subsequent part of property '{name}'",
                                        line=line,
                                        column=col,
                                        context=format_error_context(
                                            self.content, line, col
                                        ),
                                    )
                            else:
                                line, col = self._get_pos_info(self.pos)
                                raise DtsParseError(
                                    f"Expected array for subsequent part of property '{name}', got {additional_prop_part.type}",
                                    line=line,
                                    column=col,
                                    context=format_error_context(
                                        self.content, line, col
                                    ),
                                )
                            self.pos += 1
                except DtsParseError as e:
                    if not e.help_text:
                        e.help_text = f"Invalid value for property '{name}'"
                    raise
                if self.pos >= len(self.tokens) or self.tokens[self.pos] != ";":
                    line, col = self._get_pos_info(self.pos)
                    raise DtsParseError(
                        "Expected ';' after property value",
                        line=line,
                        column=col,
                        context=format_error_context(self.content, line, col),
                        help_text="Property definitions must end with a semicolon",
                    )
                self.pos += 1
                continue
    
            # Handle child nodes. At this point, 'token' is either a node name or a label.
            current_labels_for_node: List[str] = []
            current_token = token  # Start with the first token we haven't processed as property/etc.
    
            # Loop to gather all labels: label1: label2: ... node_name
            while self.pos + 1 < len(self.tokens) and self.tokens[self.pos + 1] == ":":
                # Current token is a label
                current_labels_for_node.append(current_token)
                self.pos += 2  # Consume label and ':'
                if self.pos >= len(self.tokens):
                    line, col = self._get_pos_info(self.pos - 1)
                    raise DtsParseError(
                        "Unexpected end of file after label expecting node name or another label",
                        line=line,
                        column=col,
                        context=format_error_context(self.content, line, col),
                    )
                current_token = self.tokens[
                    self.pos
                ]  # This is the next potential label or the actual node name
    
            # After the loop, current_token is the actual node name
            actual_node_name = current_token
            self.pos += 1  # Consume the actual_node_name token
    
            child = DtsNode(name=actual_node_name)
            for lbl in current_labels_for_node:
                child.add_label(lbl)
    
            if self.pos >= len(self.tokens) or self.tokens[self.pos] != "{":
                line, col = self._get_pos_info(self.pos)
                # Provide more context in error: what token did we actually find?
                found_token_msg = (
                    f"Found '{self.tokens[self.pos]}' instead."
                    if self.pos < len(self.tokens)
                    else "Found end of input."
                )
>               raise DtsParseError(
                    f"Expected '{{ ' after node '{actual_node_name}'. {found_token_msg}",
                    line=line,
                    column=col,
                    context=format_error_context(self.content, line, col),
                    help_text="Node definitions must be enclosed in curly braces and start with '{'.",
                )
E               converter.dts.error_handler.DtsParseError: Expected '{ ' after node '#'. Found 'Missing' instead. at line 6, column -34
E               
E               4 |             invalid_layer {
E               5 |                 # Missing bindings
E               6 |             };
E                 | ^
E               7 |         };
E               8 |     };
E               
E               Help: Node definitions must be enclosed in curly braces and start with '{'.

converter/dts/parser.py:558: DtsParseError
_______________________ test_full_pipeline_simple_keymap _______________________

    def test_full_pipeline_simple_keymap():
        """Test the full pipeline with a simple keymap."""
        content = """
        / {
            keymap {
                compatible = "zmk,keymap";
                default_layer {
                    bindings = <&kp A &kp B &kp C>;
                };
            };
        };
        """
    
        # Parse DTS
        parser = DtsParser()
        ast = parser.parse(content)
    
        # Extract keymap
        extractor = KeymapExtractor()
>       config = extractor.extract(ast)

tests/dts/test_integration.py:28: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
converter/dts/extractor.py:77: in extract
    self._extract_layers(keymap_node)
converter/dts/extractor.py:300: in _extract_layers
    layer = self._create_layer(child)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <converter.dts.extractor.KeymapExtractor object at 0x103f10820>
node = DtsNode(name='default_layer', parent=DtsNode(name='keymap', parent=DtsNode(name='/', parent=None, children={'keymap': ...erties={'bindings': DtsProperty(name='bindings', value=['&kp', 'A', '&kp', 'B', '&kp', 'C'], type='array')}, labels={})

    def _create_layer(self, node: DtsNode) -> Optional[Layer]:
        """Create a layer instance from a node (called in Pass 3)."""
        bindings_prop = node.properties.get("bindings")
        if not bindings_prop or bindings_prop.type != "array":
            print(f"Warning: Layer '{node.name}' missing valid bindings property.")
            return None
    
        # Parse bindings now, all behaviors should be available
        parsed_bindings = self._parse_bindings(bindings_prop.value)
>       return Layer(name=node.name, bindings=parsed_bindings)
E       TypeError: Layer.__init__() missing 1 required positional argument: 'index'

converter/dts/extractor.py:320: TypeError
______________________ test_full_pipeline_with_behaviors _______________________

    def test_full_pipeline_with_behaviors():
        """Test the full pipeline with behaviors."""
        content = """
        / {
            behaviors {
                mt: mod_tap {
                    compatible = "zmk,behavior-hold-tap";
                    tapping-term-ms = <200>;
                };
                macro: macro {
                    compatible = "zmk,behavior-macro";
                    bindings = <&kp A &kp B>;
                };
            };
            keymap {
                default_layer {
                    bindings = <&mt LSHIFT A &macro>;
                };
            };
        };
        """
    
        # Parse DTS
        parser = DtsParser()
        ast = parser.parse(content)
    
        # Extract keymap
        extractor = KeymapExtractor()
>       config = extractor.extract(ast)

tests/dts/test_integration.py:72: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
converter/dts/extractor.py:77: in extract
    self._extract_layers(keymap_node)
converter/dts/extractor.py:300: in _extract_layers
    layer = self._create_layer(child)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <converter.dts.extractor.KeymapExtractor object at 0x103e9ac80>
node = DtsNode(name='default_layer', parent=DtsNode(name='keymap', parent=DtsNode(name='/', parent=None, children={'behaviors...properties={'bindings': DtsProperty(name='bindings', value=['&mt', 'LSHIFT', 'A', '&macro'], type='array')}, labels={})

    def _create_layer(self, node: DtsNode) -> Optional[Layer]:
        """Create a layer instance from a node (called in Pass 3)."""
        bindings_prop = node.properties.get("bindings")
        if not bindings_prop or bindings_prop.type != "array":
            print(f"Warning: Layer '{node.name}' missing valid bindings property.")
            return None
    
        # Parse bindings now, all behaviors should be available
        parsed_bindings = self._parse_bindings(bindings_prop.value)
>       return Layer(name=node.name, bindings=parsed_bindings)
E       TypeError: Layer.__init__() missing 1 required positional argument: 'index'

converter/dts/extractor.py:320: TypeError
______________________ test_full_pipeline_multiple_layers ______________________

    def test_full_pipeline_multiple_layers():
        """Test the full pipeline with multiple layers."""
        content = """
        / {
            keymap {
                default_layer {
                    bindings = <&kp A &kp B>;
                };
                lower_layer {
                    bindings = <&kp C &kp D>;
                };
                raise_layer {
                    bindings = <&kp E &kp F>;
                };
            };
        };
        """
    
        # Parse DTS
        parser = DtsParser()
        ast = parser.parse(content)
    
        # Extract keymap
        extractor = KeymapExtractor()
>       config = extractor.extract(ast)

tests/dts/test_integration.py:125: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
converter/dts/extractor.py:77: in extract
    self._extract_layers(keymap_node)
converter/dts/extractor.py:300: in _extract_layers
    layer = self._create_layer(child)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <converter.dts.extractor.KeymapExtractor object at 0x103e97730>
node = DtsNode(name='default_layer', parent=DtsNode(name='keymap', parent=DtsNode(name='/', parent=None, children={'keymap': ...ren={}, properties={'bindings': DtsProperty(name='bindings', value=['&kp', 'A', '&kp', 'B'], type='array')}, labels={})

    def _create_layer(self, node: DtsNode) -> Optional[Layer]:
        """Create a layer instance from a node (called in Pass 3)."""
        bindings_prop = node.properties.get("bindings")
        if not bindings_prop or bindings_prop.type != "array":
            print(f"Warning: Layer '{node.name}' missing valid bindings property.")
            return None
    
        # Parse bindings now, all behaviors should be available
        parsed_bindings = self._parse_bindings(bindings_prop.value)
>       return Layer(name=node.name, bindings=parsed_bindings)
E       TypeError: Layer.__init__() missing 1 required positional argument: 'index'

converter/dts/extractor.py:320: TypeError
_____________________ test_full_pipeline_complex_bindings ______________________

    def test_full_pipeline_complex_bindings():
        """Test the full pipeline with complex bindings."""
        content = """
        / {
            behaviors {
                mt: mod_tap {
                    compatible = "zmk,behavior-hold-tap";
                    tapping-term-ms = <200>;
                };
                lt: layer_tap {
                    compatible = "zmk,behavior-hold-tap";
                    tapping-term-ms = <200>;
                };
            };
            keymap {
                default_layer {
                    bindings = <
                        &mt LSHIFT A
                        &lt 1 B
                        &kp C
                    >;
                };
            };
        };
        """
    
        # Parse DTS
        parser = DtsParser()
        ast = parser.parse(content)
    
        # Extract keymap
        extractor = KeymapExtractor()
>       config = extractor.extract(ast)

tests/dts/test_integration.py:176: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
converter/dts/extractor.py:77: in extract
    self._extract_layers(keymap_node)
converter/dts/extractor.py:300: in _extract_layers
    layer = self._create_layer(child)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <converter.dts.extractor.KeymapExtractor object at 0x103e86500>
node = DtsNode(name='default_layer', parent=DtsNode(name='keymap', parent=DtsNode(name='/', parent=None, children={'behaviors...ings': DtsProperty(name='bindings', value=['&mt', 'LSHIFT', 'A', '&lt', 1, 'B', '&kp', 'C'], type='array')}, labels={})

    def _create_layer(self, node: DtsNode) -> Optional[Layer]:
        """Create a layer instance from a node (called in Pass 3)."""
        bindings_prop = node.properties.get("bindings")
        if not bindings_prop or bindings_prop.type != "array":
            print(f"Warning: Layer '{node.name}' missing valid bindings property.")
            return None
    
        # Parse bindings now, all behaviors should be available
        parsed_bindings = self._parse_bindings(bindings_prop.value)
>       return Layer(name=node.name, bindings=parsed_bindings)
E       TypeError: Layer.__init__() missing 1 required positional argument: 'index'

converter/dts/extractor.py:320: TypeError
______________________ test_full_pipeline_error_handling _______________________

    def test_full_pipeline_error_handling():
        """Test error handling in the full pipeline."""
        # Test missing root node
        content = "node1 { };"
        parser = DtsParser()
        with pytest.raises(ValueError, match="Expected root node"):
>           parser.parse(content)

tests/dts/test_integration.py:213: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <converter.dts.parser.DtsParser object at 0x103f13e80>
content = 'node1 { };', file = None

    def parse(self, content: str, file: Optional[str] = None) -> DtsRoot:
        """Parse DTS content into an AST.
    
        Args:
            content: DTS content string
            file: Optional file path for error reporting
    
        Returns:
            DtsRoot object representing the parsed AST
    
        Raises:
            DtsParseError: If the content is not valid DTS
        """
        self.content = content
        self.tokens = []
        self.line_map = []
        self._tokenize(content)
        self.pos = 0
    
        # Check for root node token '/'
        if not self.tokens or self.tokens[0] != "/":
>           raise DtsParseError(
                "DTS must start with root node '/'",
                file=file,
                line=1,
                column=1,
                context=format_error_context(content, 1, 1),
            )
E           converter.dts.error_handler.DtsParseError: DTS must start with root node '/' at line 1, column 1
E           
E           1 | node1 { };
E             | ^
E           
E           Help: Check the DTS syntax and ensure it follows the specification.

converter/dts/parser.py:39: DtsParseError
__________________________ test_parse_error_handling ___________________________

    def test_parse_error_handling():
        """Test error handling in DTS parsing."""
        parser = DtsParser()
    
        with pytest.raises(DtsParseError, match="DTS must start with root node '/'"):
            parser.parse("node1 { };")
    
        with pytest.raises(DtsParseError, match="Unterminated string"):
            parser.parse('/ { prop1 = "value1; };')
    
        with pytest.raises(DtsParseError, match="Unterminated array"):
            parser.parse("/ { prop1 = <1 2 3; };")
    
        # This error message comes from _parse_property_value
        with pytest.raises(DtsParseError, match="Invalid property value: value1"):
            parser.parse("/ { prop1 = value1 };")
    
        # Check that 'node1;' is correctly parsed as a boolean property
        # and does not raise an error expecting '{'
        parsed_node1_boolean = parser.parse("/ { node1; };")
>       assert "node1" in parsed_node1_boolean.children
E       AssertionError: assert 'node1' in {}
E        +  where {} = DtsRoot(name='/', parent=None, children={}, properties={'node1': DtsProperty(name='node1', value=True, type='boolean')}, labels={}, label_to_node={}).children

tests/dts/test_parser.py:143: AssertionError
______________________ test_parse_zmk_specific_constructs ______________________

    def test_parse_zmk_specific_constructs():
        """Test parsing ZMK-specific DTS constructs."""
        content = """
        / {
            layer_0 { // Node names can have underscores
                bindings = <&kp A &mt LEFT_SHIFT A &lt 1 B>;
            };
            keymap {
                 compatible = "zmk,keymap";
                 layer-1 { // Node names can have hyphens
                     bindings = <&kp C>;
                     sensor-bindings = <&scroll_up &scroll_down>;
                 };
            };
            behaviors {
                hm: hold_mod {
                    compatible = "zmk,behavior-hold-tap";
                    #binding-cells = <2>; // Special property
                    tapping-term-ms = <200>;
                    bindings = <&kp>, <&kp>; // Array of cells
                };
                tap_dance_0: td0 {
                     compatible = "zmk,behavior-tap-dance";
                     #binding-cells = <0>;
                     tapping-term-ms = <200>;
                     bindings = <&kp A>, <&kp B>, <&kp C>;
                };
            };
        };
        """
        parser = DtsParser()
        ast = parser.parse(content)
    
        # Check layer_0
        layer_0 = ast.children["layer_0"]
>       assert layer_0.properties["bindings"].value == [
            "&kp",
            "A",
            "&mt",
            "LEFT_SHIFT",
            "A",
            "&lt",
            "1",
            "B",
        ]
E       AssertionError: assert ['&kp', 'A', ...', '&lt', ...] == ['&kp', 'A', ...', '&lt', ...]
E         
E         At index 6 diff: 1 != '1'
E         Use -v to get more diff

tests/dts/test_parser.py:377: AssertionError
________________________ test_preprocessor_performance _________________________

self = <converter.dts.preprocessor.DtsPreprocessor object at 0x103eb9e40>
input_path = PosixPath('/Volumes/FlashGordon/Dropbox/code/nicktokatana/tests/fixtures/dts/complex_keymap.zmk')
matrix_size = None

    def preprocess(
        self,
        input_path: str,
        matrix_size: Optional[Tuple[int, int]] = None,
    ) -> str:
        """Preprocess a DTS file.
    
        Args:
            input_path: Path to the input file
            matrix_size: Optional tuple of (rows, cols) for matrix transform
    
        Returns:
            The preprocessed content as a string
    
        Raises:
            PreprocessorError: If preprocessing fails
        """
        input_path = Path(input_path)
        if not input_path.exists():
            raise PreprocessorError(
                f"Input file does not exist: {input_path}",
                help_text=(
                    "Ensure the input file exists and has proper "
                    "read permissions"
                )
            )
    
        try:
            with open(input_path, "r") as f:
                content_for_cpp = f.read()
        except Exception as e:
            raise PreprocessorError(
                f"Failed to read input file: {str(e)}",
                file=str(input_path),
                help_text=(
                    "Ensure the file exists and has proper "
                    "read permissions"
                )
            )
    
        # Create a temporary file for the preprocessor input
        tmp_input = tempfile.NamedTemporaryFile(
            mode="w",
            delete=False,
            suffix=".dts",
            dir=None,  # Use system default temp dir (usually /tmp)
        )
        tmp_input.write(content_for_cpp)
        tmp_input.close()
        tmp_input_file = Path(tmp_input.name)
    
        try:
            # Build cpp command as a list for shell=False
            cpp_cmd = [
                str(self.cpp_path),
                "-E",
                "-x", "c",
            ]
            for path in self.include_paths:
                cpp_cmd.extend(["-I", str(path)])
            cpp_cmd.append(str(tmp_input_file))
    
            # Debug: print the constructed command list
            print("[DtsPreprocessor] cpp command:", cpp_cmd)
    
            # Run preprocessor with shell=False
            try:
>               result = subprocess.run(
                    cpp_cmd,
                    capture_output=True,
                    text=True,
                    check=True,
                    shell=False,
                )

converter/dts/preprocessor.py:194: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = None, capture_output = True, timeout = None, check = True
popenargs = (['/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/cpp', '-E', '-x', 'c', '/var/folders/0s/42v7yl697hn0l1cdnx0vrvyr0000gn/T/tmpkoor7foq.dts'],)
kwargs = {'shell': False, 'stderr': -1, 'stdout': -1, 'text': True}
process = <Popen: returncode: 1 args: ['/Applications/Xcode.app/Contents/Developer/Too...>
stdout = '', stderr = 'cc: error: no input files\n', retcode = 1

    def run(*popenargs,
            input=None, capture_output=False, timeout=None, check=False, **kwargs):
        """Run command with arguments and return a CompletedProcess instance.
    
        The returned instance will have attributes args, returncode, stdout and
        stderr. By default, stdout and stderr are not captured, and those attributes
        will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them,
        or pass capture_output=True to capture both.
    
        If check is True and the exit code was non-zero, it raises a
        CalledProcessError. The CalledProcessError object will have the return code
        in the returncode attribute, and output & stderr attributes if those streams
        were captured.
    
        If timeout is given, and the process takes too long, a TimeoutExpired
        exception will be raised.
    
        There is an optional argument "input", allowing you to
        pass bytes or a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it will be used internally.
    
        By default, all communication is in bytes, and therefore any "input" should
        be bytes, and the stdout and stderr will be bytes. If in text mode, any
        "input" should be a string, and stdout and stderr will be strings decoded
        according to locale encoding, or by "encoding" if set. Text mode is
        triggered by setting any of text, encoding, errors or universal_newlines.
    
        The other arguments are the same as for the Popen constructor.
        """
        if input is not None:
            if kwargs.get('stdin') is not None:
                raise ValueError('stdin and input arguments may not both be used.')
            kwargs['stdin'] = PIPE
    
        if capture_output:
            if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:
                raise ValueError('stdout and stderr arguments may not be used '
                                 'with capture_output.')
            kwargs['stdout'] = PIPE
            kwargs['stderr'] = PIPE
    
        with Popen(*popenargs, **kwargs) as process:
            try:
                stdout, stderr = process.communicate(input, timeout=timeout)
            except TimeoutExpired as exc:
                process.kill()
                if _mswindows:
                    # Windows accumulates the output in a single blocking
                    # read() call run on child threads, with the timeout
                    # being done in a join() on those threads.  communicate()
                    # _after_ kill() is required to collect that and add it
                    # to the exception.
                    exc.stdout, exc.stderr = process.communicate()
                else:
                    # POSIX _communicate already populated the output so
                    # far into the TimeoutExpired exception.
                    process.wait()
                raise
            except:  # Including KeyboardInterrupt, communicate handled that.
                process.kill()
                # We don't call process.wait() as .__exit__ does that for us.
                raise
            retcode = process.poll()
            if check and retcode:
>               raise CalledProcessError(retcode, process.args,
                                         output=stdout, stderr=stderr)
E               subprocess.CalledProcessError: Command '['/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/cpp', '-E', '-x', 'c', '/var/folders/0s/42v7yl697hn0l1cdnx0vrvyr0000gn/T/tmpkoor7foq.dts']' returned non-zero exit status 1.

/Users/malpern/.pyenv/versions/3.10.16/lib/python3.10/subprocess.py:526: CalledProcessError

During handling of the above exception, another exception occurred:

sample_keymap_path = '/Volumes/FlashGordon/Dropbox/code/nicktokatana/tests/fixtures/dts/complex_keymap.zmk'

    def test_preprocessor_performance(sample_keymap_path):
        """Test the performance of the preprocessor."""
        preprocessor = DtsPreprocessor()
    
        # Run multiple times to get stable measurements
        times = []
        for _ in range(10):
>           _, duration = measure_time(preprocessor.preprocess, sample_keymap_path)

tests/dts/test_performance.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/dts/test_performance.py:16: in measure_time
    result = func(*args, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <converter.dts.preprocessor.DtsPreprocessor object at 0x103eb9e40>
input_path = PosixPath('/Volumes/FlashGordon/Dropbox/code/nicktokatana/tests/fixtures/dts/complex_keymap.zmk')
matrix_size = None

    def preprocess(
        self,
        input_path: str,
        matrix_size: Optional[Tuple[int, int]] = None,
    ) -> str:
        """Preprocess a DTS file.
    
        Args:
            input_path: Path to the input file
            matrix_size: Optional tuple of (rows, cols) for matrix transform
    
        Returns:
            The preprocessed content as a string
    
        Raises:
            PreprocessorError: If preprocessing fails
        """
        input_path = Path(input_path)
        if not input_path.exists():
            raise PreprocessorError(
                f"Input file does not exist: {input_path}",
                help_text=(
                    "Ensure the input file exists and has proper "
                    "read permissions"
                )
            )
    
        try:
            with open(input_path, "r") as f:
                content_for_cpp = f.read()
        except Exception as e:
            raise PreprocessorError(
                f"Failed to read input file: {str(e)}",
                file=str(input_path),
                help_text=(
                    "Ensure the file exists and has proper "
                    "read permissions"
                )
            )
    
        # Create a temporary file for the preprocessor input
        tmp_input = tempfile.NamedTemporaryFile(
            mode="w",
            delete=False,
            suffix=".dts",
            dir=None,  # Use system default temp dir (usually /tmp)
        )
        tmp_input.write(content_for_cpp)
        tmp_input.close()
        tmp_input_file = Path(tmp_input.name)
    
        try:
            # Build cpp command as a list for shell=False
            cpp_cmd = [
                str(self.cpp_path),
                "-E",
                "-x", "c",
            ]
            for path in self.include_paths:
                cpp_cmd.extend(["-I", str(path)])
            cpp_cmd.append(str(tmp_input_file))
    
            # Debug: print the constructed command list
            print("[DtsPreprocessor] cpp command:", cpp_cmd)
    
            # Run preprocessor with shell=False
            try:
                result = subprocess.run(
                    cpp_cmd,
                    capture_output=True,
                    text=True,
                    check=True,
                    shell=False,
                )
            except subprocess.CalledProcessError as e:
>               raise PreprocessorError(
                    "Failed to process DTS directives",
                    file=str(input_path),
                    context=str(e),
                    help_text=(
                        "Check for malformed DTS directives in "
                        "input file"
                    )
                )
E               converter.dts.preprocessor.PreprocessorError: Failed to process DTS directives

converter/dts/preprocessor.py:202: PreprocessorError
----------------------------- Captured stdout call -----------------------------
[DtsPreprocessor] cpp command: ['/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/cpp', '-E', '-x', 'c', '/var/folders/0s/42v7yl697hn0l1cdnx0vrvyr0000gn/T/tmpkoor7foq.dts']
___________________________ test_parser_performance ____________________________

self = <converter.dts.preprocessor.DtsPreprocessor object at 0x103f12d10>
input_path = PosixPath('/Volumes/FlashGordon/Dropbox/code/nicktokatana/tests/fixtures/dts/complex_keymap.zmk')
matrix_size = None

    def preprocess(
        self,
        input_path: str,
        matrix_size: Optional[Tuple[int, int]] = None,
    ) -> str:
        """Preprocess a DTS file.
    
        Args:
            input_path: Path to the input file
            matrix_size: Optional tuple of (rows, cols) for matrix transform
    
        Returns:
            The preprocessed content as a string
    
        Raises:
            PreprocessorError: If preprocessing fails
        """
        input_path = Path(input_path)
        if not input_path.exists():
            raise PreprocessorError(
                f"Input file does not exist: {input_path}",
                help_text=(
                    "Ensure the input file exists and has proper "
                    "read permissions"
                )
            )
    
        try:
            with open(input_path, "r") as f:
                content_for_cpp = f.read()
        except Exception as e:
            raise PreprocessorError(
                f"Failed to read input file: {str(e)}",
                file=str(input_path),
                help_text=(
                    "Ensure the file exists and has proper "
                    "read permissions"
                )
            )
    
        # Create a temporary file for the preprocessor input
        tmp_input = tempfile.NamedTemporaryFile(
            mode="w",
            delete=False,
            suffix=".dts",
            dir=None,  # Use system default temp dir (usually /tmp)
        )
        tmp_input.write(content_for_cpp)
        tmp_input.close()
        tmp_input_file = Path(tmp_input.name)
    
        try:
            # Build cpp command as a list for shell=False
            cpp_cmd = [
                str(self.cpp_path),
                "-E",
                "-x", "c",
            ]
            for path in self.include_paths:
                cpp_cmd.extend(["-I", str(path)])
            cpp_cmd.append(str(tmp_input_file))
    
            # Debug: print the constructed command list
            print("[DtsPreprocessor] cpp command:", cpp_cmd)
    
            # Run preprocessor with shell=False
            try:
>               result = subprocess.run(
                    cpp_cmd,
                    capture_output=True,
                    text=True,
                    check=True,
                    shell=False,
                )

converter/dts/preprocessor.py:194: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = None, capture_output = True, timeout = None, check = True
popenargs = (['/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/cpp', '-E', '-x', 'c', '/var/folders/0s/42v7yl697hn0l1cdnx0vrvyr0000gn/T/tmpw3xn4d2a.dts'],)
kwargs = {'shell': False, 'stderr': -1, 'stdout': -1, 'text': True}
process = <Popen: returncode: 1 args: ['/Applications/Xcode.app/Contents/Developer/Too...>
stdout = '', stderr = 'cc: error: no input files\n', retcode = 1

    def run(*popenargs,
            input=None, capture_output=False, timeout=None, check=False, **kwargs):
        """Run command with arguments and return a CompletedProcess instance.
    
        The returned instance will have attributes args, returncode, stdout and
        stderr. By default, stdout and stderr are not captured, and those attributes
        will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them,
        or pass capture_output=True to capture both.
    
        If check is True and the exit code was non-zero, it raises a
        CalledProcessError. The CalledProcessError object will have the return code
        in the returncode attribute, and output & stderr attributes if those streams
        were captured.
    
        If timeout is given, and the process takes too long, a TimeoutExpired
        exception will be raised.
    
        There is an optional argument "input", allowing you to
        pass bytes or a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it will be used internally.
    
        By default, all communication is in bytes, and therefore any "input" should
        be bytes, and the stdout and stderr will be bytes. If in text mode, any
        "input" should be a string, and stdout and stderr will be strings decoded
        according to locale encoding, or by "encoding" if set. Text mode is
        triggered by setting any of text, encoding, errors or universal_newlines.
    
        The other arguments are the same as for the Popen constructor.
        """
        if input is not None:
            if kwargs.get('stdin') is not None:
                raise ValueError('stdin and input arguments may not both be used.')
            kwargs['stdin'] = PIPE
    
        if capture_output:
            if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:
                raise ValueError('stdout and stderr arguments may not be used '
                                 'with capture_output.')
            kwargs['stdout'] = PIPE
            kwargs['stderr'] = PIPE
    
        with Popen(*popenargs, **kwargs) as process:
            try:
                stdout, stderr = process.communicate(input, timeout=timeout)
            except TimeoutExpired as exc:
                process.kill()
                if _mswindows:
                    # Windows accumulates the output in a single blocking
                    # read() call run on child threads, with the timeout
                    # being done in a join() on those threads.  communicate()
                    # _after_ kill() is required to collect that and add it
                    # to the exception.
                    exc.stdout, exc.stderr = process.communicate()
                else:
                    # POSIX _communicate already populated the output so
                    # far into the TimeoutExpired exception.
                    process.wait()
                raise
            except:  # Including KeyboardInterrupt, communicate handled that.
                process.kill()
                # We don't call process.wait() as .__exit__ does that for us.
                raise
            retcode = process.poll()
            if check and retcode:
>               raise CalledProcessError(retcode, process.args,
                                         output=stdout, stderr=stderr)
E               subprocess.CalledProcessError: Command '['/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/cpp', '-E', '-x', 'c', '/var/folders/0s/42v7yl697hn0l1cdnx0vrvyr0000gn/T/tmpw3xn4d2a.dts']' returned non-zero exit status 1.

/Users/malpern/.pyenv/versions/3.10.16/lib/python3.10/subprocess.py:526: CalledProcessError

During handling of the above exception, another exception occurred:

sample_keymap_path = '/Volumes/FlashGordon/Dropbox/code/nicktokatana/tests/fixtures/dts/complex_keymap.zmk'

    def test_parser_performance(sample_keymap_path):
        """Test the performance of the parser."""
        preprocessor = DtsPreprocessor()
        parser = DtsParser()
    
        # Preprocess once
>       content = preprocessor.preprocess(sample_keymap_path)

tests/dts/test_performance.py:56: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <converter.dts.preprocessor.DtsPreprocessor object at 0x103f12d10>
input_path = PosixPath('/Volumes/FlashGordon/Dropbox/code/nicktokatana/tests/fixtures/dts/complex_keymap.zmk')
matrix_size = None

    def preprocess(
        self,
        input_path: str,
        matrix_size: Optional[Tuple[int, int]] = None,
    ) -> str:
        """Preprocess a DTS file.
    
        Args:
            input_path: Path to the input file
            matrix_size: Optional tuple of (rows, cols) for matrix transform
    
        Returns:
            The preprocessed content as a string
    
        Raises:
            PreprocessorError: If preprocessing fails
        """
        input_path = Path(input_path)
        if not input_path.exists():
            raise PreprocessorError(
                f"Input file does not exist: {input_path}",
                help_text=(
                    "Ensure the input file exists and has proper "
                    "read permissions"
                )
            )
    
        try:
            with open(input_path, "r") as f:
                content_for_cpp = f.read()
        except Exception as e:
            raise PreprocessorError(
                f"Failed to read input file: {str(e)}",
                file=str(input_path),
                help_text=(
                    "Ensure the file exists and has proper "
                    "read permissions"
                )
            )
    
        # Create a temporary file for the preprocessor input
        tmp_input = tempfile.NamedTemporaryFile(
            mode="w",
            delete=False,
            suffix=".dts",
            dir=None,  # Use system default temp dir (usually /tmp)
        )
        tmp_input.write(content_for_cpp)
        tmp_input.close()
        tmp_input_file = Path(tmp_input.name)
    
        try:
            # Build cpp command as a list for shell=False
            cpp_cmd = [
                str(self.cpp_path),
                "-E",
                "-x", "c",
            ]
            for path in self.include_paths:
                cpp_cmd.extend(["-I", str(path)])
            cpp_cmd.append(str(tmp_input_file))
    
            # Debug: print the constructed command list
            print("[DtsPreprocessor] cpp command:", cpp_cmd)
    
            # Run preprocessor with shell=False
            try:
                result = subprocess.run(
                    cpp_cmd,
                    capture_output=True,
                    text=True,
                    check=True,
                    shell=False,
                )
            except subprocess.CalledProcessError as e:
>               raise PreprocessorError(
                    "Failed to process DTS directives",
                    file=str(input_path),
                    context=str(e),
                    help_text=(
                        "Check for malformed DTS directives in "
                        "input file"
                    )
                )
E               converter.dts.preprocessor.PreprocessorError: Failed to process DTS directives

converter/dts/preprocessor.py:202: PreprocessorError
----------------------------- Captured stdout call -----------------------------
[DtsPreprocessor] cpp command: ['/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/cpp', '-E', '-x', 'c', '/var/folders/0s/42v7yl697hn0l1cdnx0vrvyr0000gn/T/tmpw3xn4d2a.dts']
__________________________ test_extractor_performance __________________________

self = <converter.dts.preprocessor.DtsPreprocessor object at 0x104143730>
input_path = PosixPath('/Volumes/FlashGordon/Dropbox/code/nicktokatana/tests/fixtures/dts/complex_keymap.zmk')
matrix_size = None

    def preprocess(
        self,
        input_path: str,
        matrix_size: Optional[Tuple[int, int]] = None,
    ) -> str:
        """Preprocess a DTS file.
    
        Args:
            input_path: Path to the input file
            matrix_size: Optional tuple of (rows, cols) for matrix transform
    
        Returns:
            The preprocessed content as a string
    
        Raises:
            PreprocessorError: If preprocessing fails
        """
        input_path = Path(input_path)
        if not input_path.exists():
            raise PreprocessorError(
                f"Input file does not exist: {input_path}",
                help_text=(
                    "Ensure the input file exists and has proper "
                    "read permissions"
                )
            )
    
        try:
            with open(input_path, "r") as f:
                content_for_cpp = f.read()
        except Exception as e:
            raise PreprocessorError(
                f"Failed to read input file: {str(e)}",
                file=str(input_path),
                help_text=(
                    "Ensure the file exists and has proper "
                    "read permissions"
                )
            )
    
        # Create a temporary file for the preprocessor input
        tmp_input = tempfile.NamedTemporaryFile(
            mode="w",
            delete=False,
            suffix=".dts",
            dir=None,  # Use system default temp dir (usually /tmp)
        )
        tmp_input.write(content_for_cpp)
        tmp_input.close()
        tmp_input_file = Path(tmp_input.name)
    
        try:
            # Build cpp command as a list for shell=False
            cpp_cmd = [
                str(self.cpp_path),
                "-E",
                "-x", "c",
            ]
            for path in self.include_paths:
                cpp_cmd.extend(["-I", str(path)])
            cpp_cmd.append(str(tmp_input_file))
    
            # Debug: print the constructed command list
            print("[DtsPreprocessor] cpp command:", cpp_cmd)
    
            # Run preprocessor with shell=False
            try:
>               result = subprocess.run(
                    cpp_cmd,
                    capture_output=True,
                    text=True,
                    check=True,
                    shell=False,
                )

converter/dts/preprocessor.py:194: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = None, capture_output = True, timeout = None, check = True
popenargs = (['/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/cpp', '-E', '-x', 'c', '/var/folders/0s/42v7yl697hn0l1cdnx0vrvyr0000gn/T/tmpho1wfruf.dts'],)
kwargs = {'shell': False, 'stderr': -1, 'stdout': -1, 'text': True}
process = <Popen: returncode: 1 args: ['/Applications/Xcode.app/Contents/Developer/Too...>
stdout = '', stderr = 'cc: error: no input files\n', retcode = 1

    def run(*popenargs,
            input=None, capture_output=False, timeout=None, check=False, **kwargs):
        """Run command with arguments and return a CompletedProcess instance.
    
        The returned instance will have attributes args, returncode, stdout and
        stderr. By default, stdout and stderr are not captured, and those attributes
        will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them,
        or pass capture_output=True to capture both.
    
        If check is True and the exit code was non-zero, it raises a
        CalledProcessError. The CalledProcessError object will have the return code
        in the returncode attribute, and output & stderr attributes if those streams
        were captured.
    
        If timeout is given, and the process takes too long, a TimeoutExpired
        exception will be raised.
    
        There is an optional argument "input", allowing you to
        pass bytes or a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it will be used internally.
    
        By default, all communication is in bytes, and therefore any "input" should
        be bytes, and the stdout and stderr will be bytes. If in text mode, any
        "input" should be a string, and stdout and stderr will be strings decoded
        according to locale encoding, or by "encoding" if set. Text mode is
        triggered by setting any of text, encoding, errors or universal_newlines.
    
        The other arguments are the same as for the Popen constructor.
        """
        if input is not None:
            if kwargs.get('stdin') is not None:
                raise ValueError('stdin and input arguments may not both be used.')
            kwargs['stdin'] = PIPE
    
        if capture_output:
            if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:
                raise ValueError('stdout and stderr arguments may not be used '
                                 'with capture_output.')
            kwargs['stdout'] = PIPE
            kwargs['stderr'] = PIPE
    
        with Popen(*popenargs, **kwargs) as process:
            try:
                stdout, stderr = process.communicate(input, timeout=timeout)
            except TimeoutExpired as exc:
                process.kill()
                if _mswindows:
                    # Windows accumulates the output in a single blocking
                    # read() call run on child threads, with the timeout
                    # being done in a join() on those threads.  communicate()
                    # _after_ kill() is required to collect that and add it
                    # to the exception.
                    exc.stdout, exc.stderr = process.communicate()
                else:
                    # POSIX _communicate already populated the output so
                    # far into the TimeoutExpired exception.
                    process.wait()
                raise
            except:  # Including KeyboardInterrupt, communicate handled that.
                process.kill()
                # We don't call process.wait() as .__exit__ does that for us.
                raise
            retcode = process.poll()
            if check and retcode:
>               raise CalledProcessError(retcode, process.args,
                                         output=stdout, stderr=stderr)
E               subprocess.CalledProcessError: Command '['/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/cpp', '-E', '-x', 'c', '/var/folders/0s/42v7yl697hn0l1cdnx0vrvyr0000gn/T/tmpho1wfruf.dts']' returned non-zero exit status 1.

/Users/malpern/.pyenv/versions/3.10.16/lib/python3.10/subprocess.py:526: CalledProcessError

During handling of the above exception, another exception occurred:

sample_keymap_path = '/Volumes/FlashGordon/Dropbox/code/nicktokatana/tests/fixtures/dts/complex_keymap.zmk'

    def test_extractor_performance(sample_keymap_path):
        """Test the performance of the extractor."""
        preprocessor = DtsPreprocessor()
        parser = DtsParser()
        extractor = KeymapExtractor()
    
        # Preprocess and parse once
>       content = preprocessor.preprocess(sample_keymap_path)

tests/dts/test_performance.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <converter.dts.preprocessor.DtsPreprocessor object at 0x104143730>
input_path = PosixPath('/Volumes/FlashGordon/Dropbox/code/nicktokatana/tests/fixtures/dts/complex_keymap.zmk')
matrix_size = None

    def preprocess(
        self,
        input_path: str,
        matrix_size: Optional[Tuple[int, int]] = None,
    ) -> str:
        """Preprocess a DTS file.
    
        Args:
            input_path: Path to the input file
            matrix_size: Optional tuple of (rows, cols) for matrix transform
    
        Returns:
            The preprocessed content as a string
    
        Raises:
            PreprocessorError: If preprocessing fails
        """
        input_path = Path(input_path)
        if not input_path.exists():
            raise PreprocessorError(
                f"Input file does not exist: {input_path}",
                help_text=(
                    "Ensure the input file exists and has proper "
                    "read permissions"
                )
            )
    
        try:
            with open(input_path, "r") as f:
                content_for_cpp = f.read()
        except Exception as e:
            raise PreprocessorError(
                f"Failed to read input file: {str(e)}",
                file=str(input_path),
                help_text=(
                    "Ensure the file exists and has proper "
                    "read permissions"
                )
            )
    
        # Create a temporary file for the preprocessor input
        tmp_input = tempfile.NamedTemporaryFile(
            mode="w",
            delete=False,
            suffix=".dts",
            dir=None,  # Use system default temp dir (usually /tmp)
        )
        tmp_input.write(content_for_cpp)
        tmp_input.close()
        tmp_input_file = Path(tmp_input.name)
    
        try:
            # Build cpp command as a list for shell=False
            cpp_cmd = [
                str(self.cpp_path),
                "-E",
                "-x", "c",
            ]
            for path in self.include_paths:
                cpp_cmd.extend(["-I", str(path)])
            cpp_cmd.append(str(tmp_input_file))
    
            # Debug: print the constructed command list
            print("[DtsPreprocessor] cpp command:", cpp_cmd)
    
            # Run preprocessor with shell=False
            try:
                result = subprocess.run(
                    cpp_cmd,
                    capture_output=True,
                    text=True,
                    check=True,
                    shell=False,
                )
            except subprocess.CalledProcessError as e:
>               raise PreprocessorError(
                    "Failed to process DTS directives",
                    file=str(input_path),
                    context=str(e),
                    help_text=(
                        "Check for malformed DTS directives in "
                        "input file"
                    )
                )
E               converter.dts.preprocessor.PreprocessorError: Failed to process DTS directives

converter/dts/preprocessor.py:202: PreprocessorError
----------------------------- Captured stdout call -----------------------------
[DtsPreprocessor] cpp command: ['/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/cpp', '-E', '-x', 'c', '/var/folders/0s/42v7yl697hn0l1cdnx0vrvyr0000gn/T/tmpho1wfruf.dts']
________________________ test_full_pipeline_performance ________________________

self = <converter.dts.preprocessor.DtsPreprocessor object at 0x1041b36a0>
input_path = PosixPath('/Volumes/FlashGordon/Dropbox/code/nicktokatana/tests/fixtures/dts/complex_keymap.zmk')
matrix_size = None

    def preprocess(
        self,
        input_path: str,
        matrix_size: Optional[Tuple[int, int]] = None,
    ) -> str:
        """Preprocess a DTS file.
    
        Args:
            input_path: Path to the input file
            matrix_size: Optional tuple of (rows, cols) for matrix transform
    
        Returns:
            The preprocessed content as a string
    
        Raises:
            PreprocessorError: If preprocessing fails
        """
        input_path = Path(input_path)
        if not input_path.exists():
            raise PreprocessorError(
                f"Input file does not exist: {input_path}",
                help_text=(
                    "Ensure the input file exists and has proper "
                    "read permissions"
                )
            )
    
        try:
            with open(input_path, "r") as f:
                content_for_cpp = f.read()
        except Exception as e:
            raise PreprocessorError(
                f"Failed to read input file: {str(e)}",
                file=str(input_path),
                help_text=(
                    "Ensure the file exists and has proper "
                    "read permissions"
                )
            )
    
        # Create a temporary file for the preprocessor input
        tmp_input = tempfile.NamedTemporaryFile(
            mode="w",
            delete=False,
            suffix=".dts",
            dir=None,  # Use system default temp dir (usually /tmp)
        )
        tmp_input.write(content_for_cpp)
        tmp_input.close()
        tmp_input_file = Path(tmp_input.name)
    
        try:
            # Build cpp command as a list for shell=False
            cpp_cmd = [
                str(self.cpp_path),
                "-E",
                "-x", "c",
            ]
            for path in self.include_paths:
                cpp_cmd.extend(["-I", str(path)])
            cpp_cmd.append(str(tmp_input_file))
    
            # Debug: print the constructed command list
            print("[DtsPreprocessor] cpp command:", cpp_cmd)
    
            # Run preprocessor with shell=False
            try:
>               result = subprocess.run(
                    cpp_cmd,
                    capture_output=True,
                    text=True,
                    check=True,
                    shell=False,
                )

converter/dts/preprocessor.py:194: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = None, capture_output = True, timeout = None, check = True
popenargs = (['/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/cpp', '-E', '-x', 'c', '/var/folders/0s/42v7yl697hn0l1cdnx0vrvyr0000gn/T/tmpb21uxrjj.dts'],)
kwargs = {'shell': False, 'stderr': -1, 'stdout': -1, 'text': True}
process = <Popen: returncode: 1 args: ['/Applications/Xcode.app/Contents/Developer/Too...>
stdout = '', stderr = 'cc: error: no input files\n', retcode = 1

    def run(*popenargs,
            input=None, capture_output=False, timeout=None, check=False, **kwargs):
        """Run command with arguments and return a CompletedProcess instance.
    
        The returned instance will have attributes args, returncode, stdout and
        stderr. By default, stdout and stderr are not captured, and those attributes
        will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them,
        or pass capture_output=True to capture both.
    
        If check is True and the exit code was non-zero, it raises a
        CalledProcessError. The CalledProcessError object will have the return code
        in the returncode attribute, and output & stderr attributes if those streams
        were captured.
    
        If timeout is given, and the process takes too long, a TimeoutExpired
        exception will be raised.
    
        There is an optional argument "input", allowing you to
        pass bytes or a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it will be used internally.
    
        By default, all communication is in bytes, and therefore any "input" should
        be bytes, and the stdout and stderr will be bytes. If in text mode, any
        "input" should be a string, and stdout and stderr will be strings decoded
        according to locale encoding, or by "encoding" if set. Text mode is
        triggered by setting any of text, encoding, errors or universal_newlines.
    
        The other arguments are the same as for the Popen constructor.
        """
        if input is not None:
            if kwargs.get('stdin') is not None:
                raise ValueError('stdin and input arguments may not both be used.')
            kwargs['stdin'] = PIPE
    
        if capture_output:
            if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:
                raise ValueError('stdout and stderr arguments may not be used '
                                 'with capture_output.')
            kwargs['stdout'] = PIPE
            kwargs['stderr'] = PIPE
    
        with Popen(*popenargs, **kwargs) as process:
            try:
                stdout, stderr = process.communicate(input, timeout=timeout)
            except TimeoutExpired as exc:
                process.kill()
                if _mswindows:
                    # Windows accumulates the output in a single blocking
                    # read() call run on child threads, with the timeout
                    # being done in a join() on those threads.  communicate()
                    # _after_ kill() is required to collect that and add it
                    # to the exception.
                    exc.stdout, exc.stderr = process.communicate()
                else:
                    # POSIX _communicate already populated the output so
                    # far into the TimeoutExpired exception.
                    process.wait()
                raise
            except:  # Including KeyboardInterrupt, communicate handled that.
                process.kill()
                # We don't call process.wait() as .__exit__ does that for us.
                raise
            retcode = process.poll()
            if check and retcode:
>               raise CalledProcessError(retcode, process.args,
                                         output=stdout, stderr=stderr)
E               subprocess.CalledProcessError: Command '['/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/cpp', '-E', '-x', 'c', '/var/folders/0s/42v7yl697hn0l1cdnx0vrvyr0000gn/T/tmpb21uxrjj.dts']' returned non-zero exit status 1.

/Users/malpern/.pyenv/versions/3.10.16/lib/python3.10/subprocess.py:526: CalledProcessError

During handling of the above exception, another exception occurred:

sample_keymap_path = '/Volumes/FlashGordon/Dropbox/code/nicktokatana/tests/fixtures/dts/complex_keymap.zmk'

    def test_full_pipeline_performance(sample_keymap_path):
        """Test the performance of the full conversion pipeline."""
        preprocessor = DtsPreprocessor()
        parser = DtsParser()
        extractor = KeymapExtractor()
        transformer = KanataTransformer()
    
        def run_pipeline():
            content = preprocessor.preprocess(sample_keymap_path)
            ast = parser.parse(content)
            config = extractor.extract(ast)
            return transformer.transform(config)
    
        # Run multiple times to get stable measurements
        times = []
        for _ in range(10):
>           _, duration = measure_time(run_pipeline)

tests/dts/test_performance.py:122: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/dts/test_performance.py:16: in measure_time
    result = func(*args, **kwargs)
tests/dts/test_performance.py:114: in run_pipeline
    content = preprocessor.preprocess(sample_keymap_path)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <converter.dts.preprocessor.DtsPreprocessor object at 0x1041b36a0>
input_path = PosixPath('/Volumes/FlashGordon/Dropbox/code/nicktokatana/tests/fixtures/dts/complex_keymap.zmk')
matrix_size = None

    def preprocess(
        self,
        input_path: str,
        matrix_size: Optional[Tuple[int, int]] = None,
    ) -> str:
        """Preprocess a DTS file.
    
        Args:
            input_path: Path to the input file
            matrix_size: Optional tuple of (rows, cols) for matrix transform
    
        Returns:
            The preprocessed content as a string
    
        Raises:
            PreprocessorError: If preprocessing fails
        """
        input_path = Path(input_path)
        if not input_path.exists():
            raise PreprocessorError(
                f"Input file does not exist: {input_path}",
                help_text=(
                    "Ensure the input file exists and has proper "
                    "read permissions"
                )
            )
    
        try:
            with open(input_path, "r") as f:
                content_for_cpp = f.read()
        except Exception as e:
            raise PreprocessorError(
                f"Failed to read input file: {str(e)}",
                file=str(input_path),
                help_text=(
                    "Ensure the file exists and has proper "
                    "read permissions"
                )
            )
    
        # Create a temporary file for the preprocessor input
        tmp_input = tempfile.NamedTemporaryFile(
            mode="w",
            delete=False,
            suffix=".dts",
            dir=None,  # Use system default temp dir (usually /tmp)
        )
        tmp_input.write(content_for_cpp)
        tmp_input.close()
        tmp_input_file = Path(tmp_input.name)
    
        try:
            # Build cpp command as a list for shell=False
            cpp_cmd = [
                str(self.cpp_path),
                "-E",
                "-x", "c",
            ]
            for path in self.include_paths:
                cpp_cmd.extend(["-I", str(path)])
            cpp_cmd.append(str(tmp_input_file))
    
            # Debug: print the constructed command list
            print("[DtsPreprocessor] cpp command:", cpp_cmd)
    
            # Run preprocessor with shell=False
            try:
                result = subprocess.run(
                    cpp_cmd,
                    capture_output=True,
                    text=True,
                    check=True,
                    shell=False,
                )
            except subprocess.CalledProcessError as e:
>               raise PreprocessorError(
                    "Failed to process DTS directives",
                    file=str(input_path),
                    context=str(e),
                    help_text=(
                        "Check for malformed DTS directives in "
                        "input file"
                    )
                )
E               converter.dts.preprocessor.PreprocessorError: Failed to process DTS directives

converter/dts/preprocessor.py:202: PreprocessorError
----------------------------- Captured stdout call -----------------------------
[DtsPreprocessor] cpp command: ['/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/cpp', '-E', '-x', 'c', '/var/folders/0s/42v7yl697hn0l1cdnx0vrvyr0000gn/T/tmpb21uxrjj.dts']
_______________________ test_preprocessor_initialization _______________________

    def test_preprocessor_initialization():
        """Test preprocessor initialization with different options."""
        # Test default initialization
        preprocessor = DtsPreprocessor()
>       assert preprocessor.cpp_path.endswith("cpp") or preprocessor.cpp_path.endswith(
            "clang"
        )
E       AttributeError: 'PosixPath' object has no attribute 'endswith'

tests/dts/test_preprocessor.py:93: AttributeError
_________________________ test_preprocess_simple_file __________________________

self = <converter.dts.preprocessor.DtsPreprocessor object at 0x103ea0550>
input_path = PosixPath('/var/folders/0s/42v7yl697hn0l1cdnx0vrvyr0000gn/T/tmppxny4wnz/test.dts')
matrix_size = None

    def preprocess(
        self,
        input_path: str,
        matrix_size: Optional[Tuple[int, int]] = None,
    ) -> str:
        """Preprocess a DTS file.
    
        Args:
            input_path: Path to the input file
            matrix_size: Optional tuple of (rows, cols) for matrix transform
    
        Returns:
            The preprocessed content as a string
    
        Raises:
            PreprocessorError: If preprocessing fails
        """
        input_path = Path(input_path)
        if not input_path.exists():
            raise PreprocessorError(
                f"Input file does not exist: {input_path}",
                help_text=(
                    "Ensure the input file exists and has proper "
                    "read permissions"
                )
            )
    
        try:
            with open(input_path, "r") as f:
                content_for_cpp = f.read()
        except Exception as e:
            raise PreprocessorError(
                f"Failed to read input file: {str(e)}",
                file=str(input_path),
                help_text=(
                    "Ensure the file exists and has proper "
                    "read permissions"
                )
            )
    
        # Create a temporary file for the preprocessor input
        tmp_input = tempfile.NamedTemporaryFile(
            mode="w",
            delete=False,
            suffix=".dts",
            dir=None,  # Use system default temp dir (usually /tmp)
        )
        tmp_input.write(content_for_cpp)
        tmp_input.close()
        tmp_input_file = Path(tmp_input.name)
    
        try:
            # Build cpp command as a list for shell=False
            cpp_cmd = [
                str(self.cpp_path),
                "-E",
                "-x", "c",
            ]
            for path in self.include_paths:
                cpp_cmd.extend(["-I", str(path)])
            cpp_cmd.append(str(tmp_input_file))
    
            # Debug: print the constructed command list
            print("[DtsPreprocessor] cpp command:", cpp_cmd)
    
            # Run preprocessor with shell=False
            try:
>               result = subprocess.run(
                    cpp_cmd,
                    capture_output=True,
                    text=True,
                    check=True,
                    shell=False,
                )

converter/dts/preprocessor.py:194: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = None, capture_output = True, timeout = None, check = True
popenargs = (['/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/cpp', '-E', '-x', 'c', '-I', '/var/folders/0s/42v7yl697hn0l1cdnx0vrvyr0000gn/T/tmppxny4wnz/include', ...],)
kwargs = {'shell': False, 'stderr': -1, 'stdout': -1, 'text': True}
process = <Popen: returncode: 1 args: ['/Applications/Xcode.app/Contents/Developer/Too...>
stdout = '', stderr = 'cc: error: no input files\n', retcode = 1

    def run(*popenargs,
            input=None, capture_output=False, timeout=None, check=False, **kwargs):
        """Run command with arguments and return a CompletedProcess instance.
    
        The returned instance will have attributes args, returncode, stdout and
        stderr. By default, stdout and stderr are not captured, and those attributes
        will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them,
        or pass capture_output=True to capture both.
    
        If check is True and the exit code was non-zero, it raises a
        CalledProcessError. The CalledProcessError object will have the return code
        in the returncode attribute, and output & stderr attributes if those streams
        were captured.
    
        If timeout is given, and the process takes too long, a TimeoutExpired
        exception will be raised.
    
        There is an optional argument "input", allowing you to
        pass bytes or a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it will be used internally.
    
        By default, all communication is in bytes, and therefore any "input" should
        be bytes, and the stdout and stderr will be bytes. If in text mode, any
        "input" should be a string, and stdout and stderr will be strings decoded
        according to locale encoding, or by "encoding" if set. Text mode is
        triggered by setting any of text, encoding, errors or universal_newlines.
    
        The other arguments are the same as for the Popen constructor.
        """
        if input is not None:
            if kwargs.get('stdin') is not None:
                raise ValueError('stdin and input arguments may not both be used.')
            kwargs['stdin'] = PIPE
    
        if capture_output:
            if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:
                raise ValueError('stdout and stderr arguments may not be used '
                                 'with capture_output.')
            kwargs['stdout'] = PIPE
            kwargs['stderr'] = PIPE
    
        with Popen(*popenargs, **kwargs) as process:
            try:
                stdout, stderr = process.communicate(input, timeout=timeout)
            except TimeoutExpired as exc:
                process.kill()
                if _mswindows:
                    # Windows accumulates the output in a single blocking
                    # read() call run on child threads, with the timeout
                    # being done in a join() on those threads.  communicate()
                    # _after_ kill() is required to collect that and add it
                    # to the exception.
                    exc.stdout, exc.stderr = process.communicate()
                else:
                    # POSIX _communicate already populated the output so
                    # far into the TimeoutExpired exception.
                    process.wait()
                raise
            except:  # Including KeyboardInterrupt, communicate handled that.
                process.kill()
                # We don't call process.wait() as .__exit__ does that for us.
                raise
            retcode = process.poll()
            if check and retcode:
>               raise CalledProcessError(retcode, process.args,
                                         output=stdout, stderr=stderr)
E               subprocess.CalledProcessError: Command '['/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/cpp', '-E', '-x', 'c', '-I', '/var/folders/0s/42v7yl697hn0l1cdnx0vrvyr0000gn/T/tmppxny4wnz/include', '/var/folders/0s/42v7yl697hn0l1cdnx0vrvyr0000gn/T/tmpjj6gmr3z.dts']' returned non-zero exit status 1.

/Users/malpern/.pyenv/versions/3.10.16/lib/python3.10/subprocess.py:526: CalledProcessError

During handling of the above exception, another exception occurred:

temp_dir = '/var/folders/0s/42v7yl697hn0l1cdnx0vrvyr0000gn/T/tmppxny4wnz'

    def test_preprocess_simple_file(temp_dir):
        """Test preprocessing a simple DTS file."""
        # Create a simple DTS file
        input_path = os.path.join(temp_dir, "test.dts")
        with open(input_path, "w") as f:
            f.write(
                """
    #define TEST_VALUE 42
    / {
        test = <TEST_VALUE>;
    };
    """
            )
    
        # Create a temporary include directory with a header file
        include_dir = os.path.join(temp_dir, "include")
        os.makedirs(include_dir)
    
        # Create a header file that defines TEST_VALUE
        header_path = os.path.join(include_dir, "test.h")
        with open(header_path, "w") as f:
            f.write("#define TEST_VALUE 42\n")
    
        preprocessor = DtsPreprocessor(include_paths=[include_dir])
>       result = preprocessor.preprocess(input_path)

tests/dts/test_preprocessor.py:136: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <converter.dts.preprocessor.DtsPreprocessor object at 0x103ea0550>
input_path = PosixPath('/var/folders/0s/42v7yl697hn0l1cdnx0vrvyr0000gn/T/tmppxny4wnz/test.dts')
matrix_size = None

    def preprocess(
        self,
        input_path: str,
        matrix_size: Optional[Tuple[int, int]] = None,
    ) -> str:
        """Preprocess a DTS file.
    
        Args:
            input_path: Path to the input file
            matrix_size: Optional tuple of (rows, cols) for matrix transform
    
        Returns:
            The preprocessed content as a string
    
        Raises:
            PreprocessorError: If preprocessing fails
        """
        input_path = Path(input_path)
        if not input_path.exists():
            raise PreprocessorError(
                f"Input file does not exist: {input_path}",
                help_text=(
                    "Ensure the input file exists and has proper "
                    "read permissions"
                )
            )
    
        try:
            with open(input_path, "r") as f:
                content_for_cpp = f.read()
        except Exception as e:
            raise PreprocessorError(
                f"Failed to read input file: {str(e)}",
                file=str(input_path),
                help_text=(
                    "Ensure the file exists and has proper "
                    "read permissions"
                )
            )
    
        # Create a temporary file for the preprocessor input
        tmp_input = tempfile.NamedTemporaryFile(
            mode="w",
            delete=False,
            suffix=".dts",
            dir=None,  # Use system default temp dir (usually /tmp)
        )
        tmp_input.write(content_for_cpp)
        tmp_input.close()
        tmp_input_file = Path(tmp_input.name)
    
        try:
            # Build cpp command as a list for shell=False
            cpp_cmd = [
                str(self.cpp_path),
                "-E",
                "-x", "c",
            ]
            for path in self.include_paths:
                cpp_cmd.extend(["-I", str(path)])
            cpp_cmd.append(str(tmp_input_file))
    
            # Debug: print the constructed command list
            print("[DtsPreprocessor] cpp command:", cpp_cmd)
    
            # Run preprocessor with shell=False
            try:
                result = subprocess.run(
                    cpp_cmd,
                    capture_output=True,
                    text=True,
                    check=True,
                    shell=False,
                )
            except subprocess.CalledProcessError as e:
>               raise PreprocessorError(
                    "Failed to process DTS directives",
                    file=str(input_path),
                    context=str(e),
                    help_text=(
                        "Check for malformed DTS directives in "
                        "input file"
                    )
                )
E               converter.dts.preprocessor.PreprocessorError: Failed to process DTS directives

converter/dts/preprocessor.py:202: PreprocessorError
----------------------------- Captured stdout call -----------------------------
[DtsPreprocessor] cpp command: ['/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/cpp', '-E', '-x', 'c', '-I', '/var/folders/0s/42v7yl697hn0l1cdnx0vrvyr0000gn/T/tmppxny4wnz/include', '/var/folders/0s/42v7yl697hn0l1cdnx0vrvyr0000gn/T/tmpjj6gmr3z.dts']
_________________________ test_preprocess_with_matrix __________________________

self = <converter.dts.preprocessor.DtsPreprocessor object at 0x103f8e470>
input_path = PosixPath('/var/folders/0s/42v7yl697hn0l1cdnx0vrvyr0000gn/T/tmph0dhnd27/matrix.dts')
matrix_size = None

    def preprocess(
        self,
        input_path: str,
        matrix_size: Optional[Tuple[int, int]] = None,
    ) -> str:
        """Preprocess a DTS file.
    
        Args:
            input_path: Path to the input file
            matrix_size: Optional tuple of (rows, cols) for matrix transform
    
        Returns:
            The preprocessed content as a string
    
        Raises:
            PreprocessorError: If preprocessing fails
        """
        input_path = Path(input_path)
        if not input_path.exists():
            raise PreprocessorError(
                f"Input file does not exist: {input_path}",
                help_text=(
                    "Ensure the input file exists and has proper "
                    "read permissions"
                )
            )
    
        try:
            with open(input_path, "r") as f:
                content_for_cpp = f.read()
        except Exception as e:
            raise PreprocessorError(
                f"Failed to read input file: {str(e)}",
                file=str(input_path),
                help_text=(
                    "Ensure the file exists and has proper "
                    "read permissions"
                )
            )
    
        # Create a temporary file for the preprocessor input
        tmp_input = tempfile.NamedTemporaryFile(
            mode="w",
            delete=False,
            suffix=".dts",
            dir=None,  # Use system default temp dir (usually /tmp)
        )
        tmp_input.write(content_for_cpp)
        tmp_input.close()
        tmp_input_file = Path(tmp_input.name)
    
        try:
            # Build cpp command as a list for shell=False
            cpp_cmd = [
                str(self.cpp_path),
                "-E",
                "-x", "c",
            ]
            for path in self.include_paths:
                cpp_cmd.extend(["-I", str(path)])
            cpp_cmd.append(str(tmp_input_file))
    
            # Debug: print the constructed command list
            print("[DtsPreprocessor] cpp command:", cpp_cmd)
    
            # Run preprocessor with shell=False
            try:
>               result = subprocess.run(
                    cpp_cmd,
                    capture_output=True,
                    text=True,
                    check=True,
                    shell=False,
                )

converter/dts/preprocessor.py:194: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = None, capture_output = True, timeout = None, check = True
popenargs = (['/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/cpp', '-E', '-x', 'c', '/var/folders/0s/42v7yl697hn0l1cdnx0vrvyr0000gn/T/tmpyl22wg76.dts'],)
kwargs = {'shell': False, 'stderr': -1, 'stdout': -1, 'text': True}
process = <Popen: returncode: 1 args: ['/Applications/Xcode.app/Contents/Developer/Too...>
stdout = '', stderr = 'cc: error: no input files\n', retcode = 1

    def run(*popenargs,
            input=None, capture_output=False, timeout=None, check=False, **kwargs):
        """Run command with arguments and return a CompletedProcess instance.
    
        The returned instance will have attributes args, returncode, stdout and
        stderr. By default, stdout and stderr are not captured, and those attributes
        will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them,
        or pass capture_output=True to capture both.
    
        If check is True and the exit code was non-zero, it raises a
        CalledProcessError. The CalledProcessError object will have the return code
        in the returncode attribute, and output & stderr attributes if those streams
        were captured.
    
        If timeout is given, and the process takes too long, a TimeoutExpired
        exception will be raised.
    
        There is an optional argument "input", allowing you to
        pass bytes or a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it will be used internally.
    
        By default, all communication is in bytes, and therefore any "input" should
        be bytes, and the stdout and stderr will be bytes. If in text mode, any
        "input" should be a string, and stdout and stderr will be strings decoded
        according to locale encoding, or by "encoding" if set. Text mode is
        triggered by setting any of text, encoding, errors or universal_newlines.
    
        The other arguments are the same as for the Popen constructor.
        """
        if input is not None:
            if kwargs.get('stdin') is not None:
                raise ValueError('stdin and input arguments may not both be used.')
            kwargs['stdin'] = PIPE
    
        if capture_output:
            if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:
                raise ValueError('stdout and stderr arguments may not be used '
                                 'with capture_output.')
            kwargs['stdout'] = PIPE
            kwargs['stderr'] = PIPE
    
        with Popen(*popenargs, **kwargs) as process:
            try:
                stdout, stderr = process.communicate(input, timeout=timeout)
            except TimeoutExpired as exc:
                process.kill()
                if _mswindows:
                    # Windows accumulates the output in a single blocking
                    # read() call run on child threads, with the timeout
                    # being done in a join() on those threads.  communicate()
                    # _after_ kill() is required to collect that and add it
                    # to the exception.
                    exc.stdout, exc.stderr = process.communicate()
                else:
                    # POSIX _communicate already populated the output so
                    # far into the TimeoutExpired exception.
                    process.wait()
                raise
            except:  # Including KeyboardInterrupt, communicate handled that.
                process.kill()
                # We don't call process.wait() as .__exit__ does that for us.
                raise
            retcode = process.poll()
            if check and retcode:
>               raise CalledProcessError(retcode, process.args,
                                         output=stdout, stderr=stderr)
E               subprocess.CalledProcessError: Command '['/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/cpp', '-E', '-x', 'c', '/var/folders/0s/42v7yl697hn0l1cdnx0vrvyr0000gn/T/tmpyl22wg76.dts']' returned non-zero exit status 1.

/Users/malpern/.pyenv/versions/3.10.16/lib/python3.10/subprocess.py:526: CalledProcessError

During handling of the above exception, another exception occurred:

temp_dir = '/var/folders/0s/42v7yl697hn0l1cdnx0vrvyr0000gn/T/tmph0dhnd27'

    def test_preprocess_with_matrix(temp_dir):
        """Test preprocessing a file with matrix transform."""
        # Create a DTS file with matrix
        input_path = os.path.join(temp_dir, "matrix.dts")
        with open(input_path, "w") as f:
            f.write(
                """
    / {
        RC_MATRIX = <2 3>;
        matrix_transform = <
            RC(0) RC(1) RC(2)
        >;
    };
    """
            )
    
        preprocessor = DtsPreprocessor()
>       result = preprocessor.preprocess(input_path)

tests/dts/test_preprocessor.py:160: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <converter.dts.preprocessor.DtsPreprocessor object at 0x103f8e470>
input_path = PosixPath('/var/folders/0s/42v7yl697hn0l1cdnx0vrvyr0000gn/T/tmph0dhnd27/matrix.dts')
matrix_size = None

    def preprocess(
        self,
        input_path: str,
        matrix_size: Optional[Tuple[int, int]] = None,
    ) -> str:
        """Preprocess a DTS file.
    
        Args:
            input_path: Path to the input file
            matrix_size: Optional tuple of (rows, cols) for matrix transform
    
        Returns:
            The preprocessed content as a string
    
        Raises:
            PreprocessorError: If preprocessing fails
        """
        input_path = Path(input_path)
        if not input_path.exists():
            raise PreprocessorError(
                f"Input file does not exist: {input_path}",
                help_text=(
                    "Ensure the input file exists and has proper "
                    "read permissions"
                )
            )
    
        try:
            with open(input_path, "r") as f:
                content_for_cpp = f.read()
        except Exception as e:
            raise PreprocessorError(
                f"Failed to read input file: {str(e)}",
                file=str(input_path),
                help_text=(
                    "Ensure the file exists and has proper "
                    "read permissions"
                )
            )
    
        # Create a temporary file for the preprocessor input
        tmp_input = tempfile.NamedTemporaryFile(
            mode="w",
            delete=False,
            suffix=".dts",
            dir=None,  # Use system default temp dir (usually /tmp)
        )
        tmp_input.write(content_for_cpp)
        tmp_input.close()
        tmp_input_file = Path(tmp_input.name)
    
        try:
            # Build cpp command as a list for shell=False
            cpp_cmd = [
                str(self.cpp_path),
                "-E",
                "-x", "c",
            ]
            for path in self.include_paths:
                cpp_cmd.extend(["-I", str(path)])
            cpp_cmd.append(str(tmp_input_file))
    
            # Debug: print the constructed command list
            print("[DtsPreprocessor] cpp command:", cpp_cmd)
    
            # Run preprocessor with shell=False
            try:
                result = subprocess.run(
                    cpp_cmd,
                    capture_output=True,
                    text=True,
                    check=True,
                    shell=False,
                )
            except subprocess.CalledProcessError as e:
>               raise PreprocessorError(
                    "Failed to process DTS directives",
                    file=str(input_path),
                    context=str(e),
                    help_text=(
                        "Check for malformed DTS directives in "
                        "input file"
                    )
                )
E               converter.dts.preprocessor.PreprocessorError: Failed to process DTS directives

converter/dts/preprocessor.py:202: PreprocessorError
----------------------------- Captured stdout call -----------------------------
[DtsPreprocessor] cpp command: ['/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/cpp', '-E', '-x', 'c', '/var/folders/0s/42v7yl697hn0l1cdnx0vrvyr0000gn/T/tmpyl22wg76.dts']
________________________ test_preprocess_with_includes _________________________

self = <converter.dts.preprocessor.DtsPreprocessor object at 0x103e94f40>
input_path = PosixPath('/var/folders/0s/42v7yl697hn0l1cdnx0vrvyr0000gn/T/tmp31wtxukh/main.dts')
matrix_size = None

    def preprocess(
        self,
        input_path: str,
        matrix_size: Optional[Tuple[int, int]] = None,
    ) -> str:
        """Preprocess a DTS file.
    
        Args:
            input_path: Path to the input file
            matrix_size: Optional tuple of (rows, cols) for matrix transform
    
        Returns:
            The preprocessed content as a string
    
        Raises:
            PreprocessorError: If preprocessing fails
        """
        input_path = Path(input_path)
        if not input_path.exists():
            raise PreprocessorError(
                f"Input file does not exist: {input_path}",
                help_text=(
                    "Ensure the input file exists and has proper "
                    "read permissions"
                )
            )
    
        try:
            with open(input_path, "r") as f:
                content_for_cpp = f.read()
        except Exception as e:
            raise PreprocessorError(
                f"Failed to read input file: {str(e)}",
                file=str(input_path),
                help_text=(
                    "Ensure the file exists and has proper "
                    "read permissions"
                )
            )
    
        # Create a temporary file for the preprocessor input
        tmp_input = tempfile.NamedTemporaryFile(
            mode="w",
            delete=False,
            suffix=".dts",
            dir=None,  # Use system default temp dir (usually /tmp)
        )
        tmp_input.write(content_for_cpp)
        tmp_input.close()
        tmp_input_file = Path(tmp_input.name)
    
        try:
            # Build cpp command as a list for shell=False
            cpp_cmd = [
                str(self.cpp_path),
                "-E",
                "-x", "c",
            ]
            for path in self.include_paths:
                cpp_cmd.extend(["-I", str(path)])
            cpp_cmd.append(str(tmp_input_file))
    
            # Debug: print the constructed command list
            print("[DtsPreprocessor] cpp command:", cpp_cmd)
    
            # Run preprocessor with shell=False
            try:
>               result = subprocess.run(
                    cpp_cmd,
                    capture_output=True,
                    text=True,
                    check=True,
                    shell=False,
                )

converter/dts/preprocessor.py:194: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = None, capture_output = True, timeout = None, check = True
popenargs = (['/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/cpp', '-E', '-x', 'c', '-I', '/var/folders/0s/42v7yl697hn0l1cdnx0vrvyr0000gn/T/tmp31wtxukh/include', ...],)
kwargs = {'shell': False, 'stderr': -1, 'stdout': -1, 'text': True}
process = <Popen: returncode: 1 args: ['/Applications/Xcode.app/Contents/Developer/Too...>
stdout = '', stderr = 'cc: error: no input files\n', retcode = 1

    def run(*popenargs,
            input=None, capture_output=False, timeout=None, check=False, **kwargs):
        """Run command with arguments and return a CompletedProcess instance.
    
        The returned instance will have attributes args, returncode, stdout and
        stderr. By default, stdout and stderr are not captured, and those attributes
        will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them,
        or pass capture_output=True to capture both.
    
        If check is True and the exit code was non-zero, it raises a
        CalledProcessError. The CalledProcessError object will have the return code
        in the returncode attribute, and output & stderr attributes if those streams
        were captured.
    
        If timeout is given, and the process takes too long, a TimeoutExpired
        exception will be raised.
    
        There is an optional argument "input", allowing you to
        pass bytes or a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it will be used internally.
    
        By default, all communication is in bytes, and therefore any "input" should
        be bytes, and the stdout and stderr will be bytes. If in text mode, any
        "input" should be a string, and stdout and stderr will be strings decoded
        according to locale encoding, or by "encoding" if set. Text mode is
        triggered by setting any of text, encoding, errors or universal_newlines.
    
        The other arguments are the same as for the Popen constructor.
        """
        if input is not None:
            if kwargs.get('stdin') is not None:
                raise ValueError('stdin and input arguments may not both be used.')
            kwargs['stdin'] = PIPE
    
        if capture_output:
            if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:
                raise ValueError('stdout and stderr arguments may not be used '
                                 'with capture_output.')
            kwargs['stdout'] = PIPE
            kwargs['stderr'] = PIPE
    
        with Popen(*popenargs, **kwargs) as process:
            try:
                stdout, stderr = process.communicate(input, timeout=timeout)
            except TimeoutExpired as exc:
                process.kill()
                if _mswindows:
                    # Windows accumulates the output in a single blocking
                    # read() call run on child threads, with the timeout
                    # being done in a join() on those threads.  communicate()
                    # _after_ kill() is required to collect that and add it
                    # to the exception.
                    exc.stdout, exc.stderr = process.communicate()
                else:
                    # POSIX _communicate already populated the output so
                    # far into the TimeoutExpired exception.
                    process.wait()
                raise
            except:  # Including KeyboardInterrupt, communicate handled that.
                process.kill()
                # We don't call process.wait() as .__exit__ does that for us.
                raise
            retcode = process.poll()
            if check and retcode:
>               raise CalledProcessError(retcode, process.args,
                                         output=stdout, stderr=stderr)
E               subprocess.CalledProcessError: Command '['/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/cpp', '-E', '-x', 'c', '-I', '/var/folders/0s/42v7yl697hn0l1cdnx0vrvyr0000gn/T/tmp31wtxukh/include', '/var/folders/0s/42v7yl697hn0l1cdnx0vrvyr0000gn/T/tmpyjcnn9mc.dts']' returned non-zero exit status 1.

/Users/malpern/.pyenv/versions/3.10.16/lib/python3.10/subprocess.py:526: CalledProcessError

During handling of the above exception, another exception occurred:

temp_dir = '/var/folders/0s/42v7yl697hn0l1cdnx0vrvyr0000gn/T/tmp31wtxukh'

    def test_preprocess_with_includes(temp_dir):
        """Test preprocessing with include files."""
        # Create include directory and file
        include_dir = os.path.join(temp_dir, "include")
        os.makedirs(include_dir)
    
        header_path = os.path.join(include_dir, "test.h")
        with open(header_path, "w") as f:
            f.write("#define HEADER_VALUE 123\n")
    
        # Create main DTS file
        input_path = os.path.join(temp_dir, "main.dts")
        with open(input_path, "w") as f:
            f.write(
                """
    #include "test.h"
    / {
        test = <HEADER_VALUE>;
    };
    """
            )
    
        preprocessor = DtsPreprocessor(include_paths=[include_dir])
>       result = preprocessor.preprocess(input_path)

tests/dts/test_preprocessor.py:191: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <converter.dts.preprocessor.DtsPreprocessor object at 0x103e94f40>
input_path = PosixPath('/var/folders/0s/42v7yl697hn0l1cdnx0vrvyr0000gn/T/tmp31wtxukh/main.dts')
matrix_size = None

    def preprocess(
        self,
        input_path: str,
        matrix_size: Optional[Tuple[int, int]] = None,
    ) -> str:
        """Preprocess a DTS file.
    
        Args:
            input_path: Path to the input file
            matrix_size: Optional tuple of (rows, cols) for matrix transform
    
        Returns:
            The preprocessed content as a string
    
        Raises:
            PreprocessorError: If preprocessing fails
        """
        input_path = Path(input_path)
        if not input_path.exists():
            raise PreprocessorError(
                f"Input file does not exist: {input_path}",
                help_text=(
                    "Ensure the input file exists and has proper "
                    "read permissions"
                )
            )
    
        try:
            with open(input_path, "r") as f:
                content_for_cpp = f.read()
        except Exception as e:
            raise PreprocessorError(
                f"Failed to read input file: {str(e)}",
                file=str(input_path),
                help_text=(
                    "Ensure the file exists and has proper "
                    "read permissions"
                )
            )
    
        # Create a temporary file for the preprocessor input
        tmp_input = tempfile.NamedTemporaryFile(
            mode="w",
            delete=False,
            suffix=".dts",
            dir=None,  # Use system default temp dir (usually /tmp)
        )
        tmp_input.write(content_for_cpp)
        tmp_input.close()
        tmp_input_file = Path(tmp_input.name)
    
        try:
            # Build cpp command as a list for shell=False
            cpp_cmd = [
                str(self.cpp_path),
                "-E",
                "-x", "c",
            ]
            for path in self.include_paths:
                cpp_cmd.extend(["-I", str(path)])
            cpp_cmd.append(str(tmp_input_file))
    
            # Debug: print the constructed command list
            print("[DtsPreprocessor] cpp command:", cpp_cmd)
    
            # Run preprocessor with shell=False
            try:
                result = subprocess.run(
                    cpp_cmd,
                    capture_output=True,
                    text=True,
                    check=True,
                    shell=False,
                )
            except subprocess.CalledProcessError as e:
>               raise PreprocessorError(
                    "Failed to process DTS directives",
                    file=str(input_path),
                    context=str(e),
                    help_text=(
                        "Check for malformed DTS directives in "
                        "input file"
                    )
                )
E               converter.dts.preprocessor.PreprocessorError: Failed to process DTS directives

converter/dts/preprocessor.py:202: PreprocessorError
----------------------------- Captured stdout call -----------------------------
[DtsPreprocessor] cpp command: ['/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/cpp', '-E', '-x', 'c', '-I', '/var/folders/0s/42v7yl697hn0l1cdnx0vrvyr0000gn/T/tmp31wtxukh/include', '/var/folders/0s/42v7yl697hn0l1cdnx0vrvyr0000gn/T/tmpyjcnn9mc.dts']
_________________________ test_preprocess_invalid_file _________________________

    def test_preprocess_invalid_file():
        """Test preprocessing a non-existent file."""
        preprocessor = DtsPreprocessor()
        with pytest.raises(FileNotFoundError):
>           preprocessor.preprocess("nonexistent.dts")

tests/dts/test_preprocessor.py:202: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <converter.dts.preprocessor.DtsPreprocessor object at 0x103f10bb0>
input_path = PosixPath('nonexistent.dts'), matrix_size = None

    def preprocess(
        self,
        input_path: str,
        matrix_size: Optional[Tuple[int, int]] = None,
    ) -> str:
        """Preprocess a DTS file.
    
        Args:
            input_path: Path to the input file
            matrix_size: Optional tuple of (rows, cols) for matrix transform
    
        Returns:
            The preprocessed content as a string
    
        Raises:
            PreprocessorError: If preprocessing fails
        """
        input_path = Path(input_path)
        if not input_path.exists():
>           raise PreprocessorError(
                f"Input file does not exist: {input_path}",
                help_text=(
                    "Ensure the input file exists and has proper "
                    "read permissions"
                )
            )
E           converter.dts.preprocessor.PreprocessorError: Input file does not exist: nonexistent.dts

converter/dts/preprocessor.py:146: PreprocessorError
_____________________ test_preprocess_invalid_cpp_command ______________________

temp_dir = '/var/folders/0s/42v7yl697hn0l1cdnx0vrvyr0000gn/T/tmpb5kxejgo'

    def test_preprocess_invalid_cpp_command(temp_dir):
        """Test preprocessing with invalid cpp command."""
        # Create a simple DTS file
        input_path = os.path.join(temp_dir, "test.dts")
        with open(input_path, "w") as f:
            f.write("/ { test = <1>; };")
    
        # Use invalid cpp path
        preprocessor = DtsPreprocessor(cpp_path="invalid_cpp")
        with pytest.raises(PreprocessorError):
>           preprocessor.preprocess(input_path)

tests/dts/test_preprocessor.py:215: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
converter/dts/preprocessor.py:194: in preprocess
    result = subprocess.run(
/Users/malpern/.pyenv/versions/3.10.16/lib/python3.10/subprocess.py:503: in run
    with Popen(*popenargs, **kwargs) as process:
/Users/malpern/.pyenv/versions/3.10.16/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen: returncode: 255 args: ['invalid_cpp', '-E', '-x', 'c', '/var/folders...>
args = ['invalid_cpp', '-E', '-x', 'c', '/var/folders/0s/42v7yl697hn0l1cdnx0vrvyr0000gn/T/tmpyiyvnd41.dts']
executable = b'invalid_cpp', preexec_fn = None, close_fds = True, pass_fds = ()
cwd = None, env = None, startupinfo = None, creationflags = 0, shell = False
p2cread = -1, p2cwrite = -1, c2pread = 11, c2pwrite = 12, errread = 13
errwrite = 14, restore_signals = True, gid = None, gids = None, uid = None
umask = -1, start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""
    
        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)
    
        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable
    
        if executable is None:
            executable = args[0]
    
        sys.audit("subprocess.Popen", executable, args, cwd, env)
    
        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return
    
        orig_executable = executable
    
        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()
    
                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)
    
            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)
    
            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)
    
        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass
    
            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: 'invalid_cpp'

/Users/malpern/.pyenv/versions/3.10.16/lib/python3.10/subprocess.py:1863: FileNotFoundError
----------------------------- Captured stdout call -----------------------------
[DtsPreprocessor] cpp command: ['invalid_cpp', '-E', '-x', 'c', '/var/folders/0s/42v7yl697hn0l1cdnx0vrvyr0000gn/T/tmpyiyvnd41.dts']
________________________ test_preprocess_simple_keymap _________________________

self = <converter.dts.preprocessor.DtsPreprocessor object at 0x1039cecb0>
input_path = PosixPath('/Volumes/FlashGordon/Dropbox/code/nicktokatana/tests/fixtures/dts/simple_keymap.zmk')
matrix_size = None

    def preprocess(
        self,
        input_path: str,
        matrix_size: Optional[Tuple[int, int]] = None,
    ) -> str:
        """Preprocess a DTS file.
    
        Args:
            input_path: Path to the input file
            matrix_size: Optional tuple of (rows, cols) for matrix transform
    
        Returns:
            The preprocessed content as a string
    
        Raises:
            PreprocessorError: If preprocessing fails
        """
        input_path = Path(input_path)
        if not input_path.exists():
            raise PreprocessorError(
                f"Input file does not exist: {input_path}",
                help_text=(
                    "Ensure the input file exists and has proper "
                    "read permissions"
                )
            )
    
        try:
            with open(input_path, "r") as f:
                content_for_cpp = f.read()
        except Exception as e:
            raise PreprocessorError(
                f"Failed to read input file: {str(e)}",
                file=str(input_path),
                help_text=(
                    "Ensure the file exists and has proper "
                    "read permissions"
                )
            )
    
        # Create a temporary file for the preprocessor input
        tmp_input = tempfile.NamedTemporaryFile(
            mode="w",
            delete=False,
            suffix=".dts",
            dir=None,  # Use system default temp dir (usually /tmp)
        )
        tmp_input.write(content_for_cpp)
        tmp_input.close()
        tmp_input_file = Path(tmp_input.name)
    
        try:
            # Build cpp command as a list for shell=False
            cpp_cmd = [
                str(self.cpp_path),
                "-E",
                "-x", "c",
            ]
            for path in self.include_paths:
                cpp_cmd.extend(["-I", str(path)])
            cpp_cmd.append(str(tmp_input_file))
    
            # Debug: print the constructed command list
            print("[DtsPreprocessor] cpp command:", cpp_cmd)
    
            # Run preprocessor with shell=False
            try:
>               result = subprocess.run(
                    cpp_cmd,
                    capture_output=True,
                    text=True,
                    check=True,
                    shell=False,
                )

converter/dts/preprocessor.py:194: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = None, capture_output = True, timeout = None, check = True
popenargs = (['/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/cpp', '-E', '-x', 'c', '-I', '/Volumes/FlashGordon/Dropbox/code/nicktokatana/tests/fixtures/dts/include', ...],)
kwargs = {'shell': False, 'stderr': -1, 'stdout': -1, 'text': True}
process = <Popen: returncode: 1 args: ['/Applications/Xcode.app/Contents/Developer/Too...>
stdout = '', stderr = 'cc: error: no input files\n', retcode = 1

    def run(*popenargs,
            input=None, capture_output=False, timeout=None, check=False, **kwargs):
        """Run command with arguments and return a CompletedProcess instance.
    
        The returned instance will have attributes args, returncode, stdout and
        stderr. By default, stdout and stderr are not captured, and those attributes
        will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them,
        or pass capture_output=True to capture both.
    
        If check is True and the exit code was non-zero, it raises a
        CalledProcessError. The CalledProcessError object will have the return code
        in the returncode attribute, and output & stderr attributes if those streams
        were captured.
    
        If timeout is given, and the process takes too long, a TimeoutExpired
        exception will be raised.
    
        There is an optional argument "input", allowing you to
        pass bytes or a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it will be used internally.
    
        By default, all communication is in bytes, and therefore any "input" should
        be bytes, and the stdout and stderr will be bytes. If in text mode, any
        "input" should be a string, and stdout and stderr will be strings decoded
        according to locale encoding, or by "encoding" if set. Text mode is
        triggered by setting any of text, encoding, errors or universal_newlines.
    
        The other arguments are the same as for the Popen constructor.
        """
        if input is not None:
            if kwargs.get('stdin') is not None:
                raise ValueError('stdin and input arguments may not both be used.')
            kwargs['stdin'] = PIPE
    
        if capture_output:
            if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:
                raise ValueError('stdout and stderr arguments may not be used '
                                 'with capture_output.')
            kwargs['stdout'] = PIPE
            kwargs['stderr'] = PIPE
    
        with Popen(*popenargs, **kwargs) as process:
            try:
                stdout, stderr = process.communicate(input, timeout=timeout)
            except TimeoutExpired as exc:
                process.kill()
                if _mswindows:
                    # Windows accumulates the output in a single blocking
                    # read() call run on child threads, with the timeout
                    # being done in a join() on those threads.  communicate()
                    # _after_ kill() is required to collect that and add it
                    # to the exception.
                    exc.stdout, exc.stderr = process.communicate()
                else:
                    # POSIX _communicate already populated the output so
                    # far into the TimeoutExpired exception.
                    process.wait()
                raise
            except:  # Including KeyboardInterrupt, communicate handled that.
                process.kill()
                # We don't call process.wait() as .__exit__ does that for us.
                raise
            retcode = process.poll()
            if check and retcode:
>               raise CalledProcessError(retcode, process.args,
                                         output=stdout, stderr=stderr)
E               subprocess.CalledProcessError: Command '['/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/cpp', '-E', '-x', 'c', '-I', '/Volumes/FlashGordon/Dropbox/code/nicktokatana/tests/fixtures/dts/include', '/var/folders/0s/42v7yl697hn0l1cdnx0vrvyr0000gn/T/tmp73owvvv2.dts']' returned non-zero exit status 1.

/Users/malpern/.pyenv/versions/3.10.16/lib/python3.10/subprocess.py:526: CalledProcessError

During handling of the above exception, another exception occurred:

preprocessor = <converter.dts.preprocessor.DtsPreprocessor object at 0x1039cecb0>
simple_keymap_path = PosixPath('/Volumes/FlashGordon/Dropbox/code/nicktokatana/tests/fixtures/dts/simple_keymap.zmk')

    def test_preprocess_simple_keymap(preprocessor, simple_keymap_path):
        """Test preprocessing a simple keymap."""
>       result = preprocessor.preprocess(str(simple_keymap_path))

tests/dts/test_preprocessor.py:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <converter.dts.preprocessor.DtsPreprocessor object at 0x1039cecb0>
input_path = PosixPath('/Volumes/FlashGordon/Dropbox/code/nicktokatana/tests/fixtures/dts/simple_keymap.zmk')
matrix_size = None

    def preprocess(
        self,
        input_path: str,
        matrix_size: Optional[Tuple[int, int]] = None,
    ) -> str:
        """Preprocess a DTS file.
    
        Args:
            input_path: Path to the input file
            matrix_size: Optional tuple of (rows, cols) for matrix transform
    
        Returns:
            The preprocessed content as a string
    
        Raises:
            PreprocessorError: If preprocessing fails
        """
        input_path = Path(input_path)
        if not input_path.exists():
            raise PreprocessorError(
                f"Input file does not exist: {input_path}",
                help_text=(
                    "Ensure the input file exists and has proper "
                    "read permissions"
                )
            )
    
        try:
            with open(input_path, "r") as f:
                content_for_cpp = f.read()
        except Exception as e:
            raise PreprocessorError(
                f"Failed to read input file: {str(e)}",
                file=str(input_path),
                help_text=(
                    "Ensure the file exists and has proper "
                    "read permissions"
                )
            )
    
        # Create a temporary file for the preprocessor input
        tmp_input = tempfile.NamedTemporaryFile(
            mode="w",
            delete=False,
            suffix=".dts",
            dir=None,  # Use system default temp dir (usually /tmp)
        )
        tmp_input.write(content_for_cpp)
        tmp_input.close()
        tmp_input_file = Path(tmp_input.name)
    
        try:
            # Build cpp command as a list for shell=False
            cpp_cmd = [
                str(self.cpp_path),
                "-E",
                "-x", "c",
            ]
            for path in self.include_paths:
                cpp_cmd.extend(["-I", str(path)])
            cpp_cmd.append(str(tmp_input_file))
    
            # Debug: print the constructed command list
            print("[DtsPreprocessor] cpp command:", cpp_cmd)
    
            # Run preprocessor with shell=False
            try:
                result = subprocess.run(
                    cpp_cmd,
                    capture_output=True,
                    text=True,
                    check=True,
                    shell=False,
                )
            except subprocess.CalledProcessError as e:
>               raise PreprocessorError(
                    "Failed to process DTS directives",
                    file=str(input_path),
                    context=str(e),
                    help_text=(
                        "Check for malformed DTS directives in "
                        "input file"
                    )
                )
E               converter.dts.preprocessor.PreprocessorError: Failed to process DTS directives

converter/dts/preprocessor.py:202: PreprocessorError
----------------------------- Captured stdout call -----------------------------
[DtsPreprocessor] cpp command: ['/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/cpp', '-E', '-x', 'c', '-I', '/Volumes/FlashGordon/Dropbox/code/nicktokatana/tests/fixtures/dts/include', '/var/folders/0s/42v7yl697hn0l1cdnx0vrvyr0000gn/T/tmp73owvvv2.dts']
___________________________ test_parse_simple_keymap ___________________________

self = <converter.dts.preprocessor.DtsPreprocessor object at 0x104141f00>
input_path = PosixPath('/Volumes/FlashGordon/Dropbox/code/nicktokatana/tests/fixtures/dts/simple_keymap.zmk')
matrix_size = None

    def preprocess(
        self,
        input_path: str,
        matrix_size: Optional[Tuple[int, int]] = None,
    ) -> str:
        """Preprocess a DTS file.
    
        Args:
            input_path: Path to the input file
            matrix_size: Optional tuple of (rows, cols) for matrix transform
    
        Returns:
            The preprocessed content as a string
    
        Raises:
            PreprocessorError: If preprocessing fails
        """
        input_path = Path(input_path)
        if not input_path.exists():
            raise PreprocessorError(
                f"Input file does not exist: {input_path}",
                help_text=(
                    "Ensure the input file exists and has proper "
                    "read permissions"
                )
            )
    
        try:
            with open(input_path, "r") as f:
                content_for_cpp = f.read()
        except Exception as e:
            raise PreprocessorError(
                f"Failed to read input file: {str(e)}",
                file=str(input_path),
                help_text=(
                    "Ensure the file exists and has proper "
                    "read permissions"
                )
            )
    
        # Create a temporary file for the preprocessor input
        tmp_input = tempfile.NamedTemporaryFile(
            mode="w",
            delete=False,
            suffix=".dts",
            dir=None,  # Use system default temp dir (usually /tmp)
        )
        tmp_input.write(content_for_cpp)
        tmp_input.close()
        tmp_input_file = Path(tmp_input.name)
    
        try:
            # Build cpp command as a list for shell=False
            cpp_cmd = [
                str(self.cpp_path),
                "-E",
                "-x", "c",
            ]
            for path in self.include_paths:
                cpp_cmd.extend(["-I", str(path)])
            cpp_cmd.append(str(tmp_input_file))
    
            # Debug: print the constructed command list
            print("[DtsPreprocessor] cpp command:", cpp_cmd)
    
            # Run preprocessor with shell=False
            try:
>               result = subprocess.run(
                    cpp_cmd,
                    capture_output=True,
                    text=True,
                    check=True,
                    shell=False,
                )

converter/dts/preprocessor.py:194: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = None, capture_output = True, timeout = None, check = True
popenargs = (['/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/cpp', '-E', '-x', 'c', '-I', '/Volumes/FlashGordon/Dropbox/code/nicktokatana/tests/fixtures/dts/include', ...],)
kwargs = {'shell': False, 'stderr': -1, 'stdout': -1, 'text': True}
process = <Popen: returncode: 1 args: ['/Applications/Xcode.app/Contents/Developer/Too...>
stdout = '', stderr = 'cc: error: no input files\n', retcode = 1

    def run(*popenargs,
            input=None, capture_output=False, timeout=None, check=False, **kwargs):
        """Run command with arguments and return a CompletedProcess instance.
    
        The returned instance will have attributes args, returncode, stdout and
        stderr. By default, stdout and stderr are not captured, and those attributes
        will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them,
        or pass capture_output=True to capture both.
    
        If check is True and the exit code was non-zero, it raises a
        CalledProcessError. The CalledProcessError object will have the return code
        in the returncode attribute, and output & stderr attributes if those streams
        were captured.
    
        If timeout is given, and the process takes too long, a TimeoutExpired
        exception will be raised.
    
        There is an optional argument "input", allowing you to
        pass bytes or a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it will be used internally.
    
        By default, all communication is in bytes, and therefore any "input" should
        be bytes, and the stdout and stderr will be bytes. If in text mode, any
        "input" should be a string, and stdout and stderr will be strings decoded
        according to locale encoding, or by "encoding" if set. Text mode is
        triggered by setting any of text, encoding, errors or universal_newlines.
    
        The other arguments are the same as for the Popen constructor.
        """
        if input is not None:
            if kwargs.get('stdin') is not None:
                raise ValueError('stdin and input arguments may not both be used.')
            kwargs['stdin'] = PIPE
    
        if capture_output:
            if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:
                raise ValueError('stdout and stderr arguments may not be used '
                                 'with capture_output.')
            kwargs['stdout'] = PIPE
            kwargs['stderr'] = PIPE
    
        with Popen(*popenargs, **kwargs) as process:
            try:
                stdout, stderr = process.communicate(input, timeout=timeout)
            except TimeoutExpired as exc:
                process.kill()
                if _mswindows:
                    # Windows accumulates the output in a single blocking
                    # read() call run on child threads, with the timeout
                    # being done in a join() on those threads.  communicate()
                    # _after_ kill() is required to collect that and add it
                    # to the exception.
                    exc.stdout, exc.stderr = process.communicate()
                else:
                    # POSIX _communicate already populated the output so
                    # far into the TimeoutExpired exception.
                    process.wait()
                raise
            except:  # Including KeyboardInterrupt, communicate handled that.
                process.kill()
                # We don't call process.wait() as .__exit__ does that for us.
                raise
            retcode = process.poll()
            if check and retcode:
>               raise CalledProcessError(retcode, process.args,
                                         output=stdout, stderr=stderr)
E               subprocess.CalledProcessError: Command '['/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/cpp', '-E', '-x', 'c', '-I', '/Volumes/FlashGordon/Dropbox/code/nicktokatana/tests/fixtures/dts/include', '/var/folders/0s/42v7yl697hn0l1cdnx0vrvyr0000gn/T/tmph4v1nrwl.dts']' returned non-zero exit status 1.

/Users/malpern/.pyenv/versions/3.10.16/lib/python3.10/subprocess.py:526: CalledProcessError

During handling of the above exception, another exception occurred:

    def test_parse_simple_keymap():
        """Test parsing a simple keymap."""
        fixtures_dir = os.path.join(os.path.dirname(__file__), "fixtures", "dts")
    
        preprocessor = DtsPreprocessor(
            include_paths=[os.path.join(fixtures_dir, "include")]
        )
        parser = DtsParser()
    
        input_file = os.path.join(fixtures_dir, "simple_keymap.zmk")
>       preprocessed = preprocessor.preprocess(input_file)

tests/test_dts_parser.py:20: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <converter.dts.preprocessor.DtsPreprocessor object at 0x104141f00>
input_path = PosixPath('/Volumes/FlashGordon/Dropbox/code/nicktokatana/tests/fixtures/dts/simple_keymap.zmk')
matrix_size = None

    def preprocess(
        self,
        input_path: str,
        matrix_size: Optional[Tuple[int, int]] = None,
    ) -> str:
        """Preprocess a DTS file.
    
        Args:
            input_path: Path to the input file
            matrix_size: Optional tuple of (rows, cols) for matrix transform
    
        Returns:
            The preprocessed content as a string
    
        Raises:
            PreprocessorError: If preprocessing fails
        """
        input_path = Path(input_path)
        if not input_path.exists():
            raise PreprocessorError(
                f"Input file does not exist: {input_path}",
                help_text=(
                    "Ensure the input file exists and has proper "
                    "read permissions"
                )
            )
    
        try:
            with open(input_path, "r") as f:
                content_for_cpp = f.read()
        except Exception as e:
            raise PreprocessorError(
                f"Failed to read input file: {str(e)}",
                file=str(input_path),
                help_text=(
                    "Ensure the file exists and has proper "
                    "read permissions"
                )
            )
    
        # Create a temporary file for the preprocessor input
        tmp_input = tempfile.NamedTemporaryFile(
            mode="w",
            delete=False,
            suffix=".dts",
            dir=None,  # Use system default temp dir (usually /tmp)
        )
        tmp_input.write(content_for_cpp)
        tmp_input.close()
        tmp_input_file = Path(tmp_input.name)
    
        try:
            # Build cpp command as a list for shell=False
            cpp_cmd = [
                str(self.cpp_path),
                "-E",
                "-x", "c",
            ]
            for path in self.include_paths:
                cpp_cmd.extend(["-I", str(path)])
            cpp_cmd.append(str(tmp_input_file))
    
            # Debug: print the constructed command list
            print("[DtsPreprocessor] cpp command:", cpp_cmd)
    
            # Run preprocessor with shell=False
            try:
                result = subprocess.run(
                    cpp_cmd,
                    capture_output=True,
                    text=True,
                    check=True,
                    shell=False,
                )
            except subprocess.CalledProcessError as e:
>               raise PreprocessorError(
                    "Failed to process DTS directives",
                    file=str(input_path),
                    context=str(e),
                    help_text=(
                        "Check for malformed DTS directives in "
                        "input file"
                    )
                )
E               converter.dts.preprocessor.PreprocessorError: Failed to process DTS directives

converter/dts/preprocessor.py:202: PreprocessorError
----------------------------- Captured stdout call -----------------------------
[DtsPreprocessor] cpp command: ['/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/cpp', '-E', '-x', 'c', '-I', '/Volumes/FlashGordon/Dropbox/code/nicktokatana/tests/fixtures/dts/include', '/var/folders/0s/42v7yl697hn0l1cdnx0vrvyr0000gn/T/tmph4v1nrwl.dts']
___________________________ test_parse_large_keymap ____________________________

self = <converter.dts.preprocessor.DtsPreprocessor object at 0x103e86ec0>
input_path = PosixPath('/Volumes/FlashGordon/Dropbox/code/nicktokatana/tests/fixtures/dts/large_keymap.zmk')
matrix_size = None

    def preprocess(
        self,
        input_path: str,
        matrix_size: Optional[Tuple[int, int]] = None,
    ) -> str:
        """Preprocess a DTS file.
    
        Args:
            input_path: Path to the input file
            matrix_size: Optional tuple of (rows, cols) for matrix transform
    
        Returns:
            The preprocessed content as a string
    
        Raises:
            PreprocessorError: If preprocessing fails
        """
        input_path = Path(input_path)
        if not input_path.exists():
            raise PreprocessorError(
                f"Input file does not exist: {input_path}",
                help_text=(
                    "Ensure the input file exists and has proper "
                    "read permissions"
                )
            )
    
        try:
            with open(input_path, "r") as f:
                content_for_cpp = f.read()
        except Exception as e:
            raise PreprocessorError(
                f"Failed to read input file: {str(e)}",
                file=str(input_path),
                help_text=(
                    "Ensure the file exists and has proper "
                    "read permissions"
                )
            )
    
        # Create a temporary file for the preprocessor input
        tmp_input = tempfile.NamedTemporaryFile(
            mode="w",
            delete=False,
            suffix=".dts",
            dir=None,  # Use system default temp dir (usually /tmp)
        )
        tmp_input.write(content_for_cpp)
        tmp_input.close()
        tmp_input_file = Path(tmp_input.name)
    
        try:
            # Build cpp command as a list for shell=False
            cpp_cmd = [
                str(self.cpp_path),
                "-E",
                "-x", "c",
            ]
            for path in self.include_paths:
                cpp_cmd.extend(["-I", str(path)])
            cpp_cmd.append(str(tmp_input_file))
    
            # Debug: print the constructed command list
            print("[DtsPreprocessor] cpp command:", cpp_cmd)
    
            # Run preprocessor with shell=False
            try:
>               result = subprocess.run(
                    cpp_cmd,
                    capture_output=True,
                    text=True,
                    check=True,
                    shell=False,
                )

converter/dts/preprocessor.py:194: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = None, capture_output = True, timeout = None, check = True
popenargs = (['/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/cpp', '-E', '-x', 'c', '-I', '/Volumes/FlashGordon/Dropbox/code/nicktokatana/tests/fixtures/dts/include', ...],)
kwargs = {'shell': False, 'stderr': -1, 'stdout': -1, 'text': True}
process = <Popen: returncode: 1 args: ['/Applications/Xcode.app/Contents/Developer/Too...>
stdout = '', stderr = 'cc: error: no input files\n', retcode = 1

    def run(*popenargs,
            input=None, capture_output=False, timeout=None, check=False, **kwargs):
        """Run command with arguments and return a CompletedProcess instance.
    
        The returned instance will have attributes args, returncode, stdout and
        stderr. By default, stdout and stderr are not captured, and those attributes
        will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them,
        or pass capture_output=True to capture both.
    
        If check is True and the exit code was non-zero, it raises a
        CalledProcessError. The CalledProcessError object will have the return code
        in the returncode attribute, and output & stderr attributes if those streams
        were captured.
    
        If timeout is given, and the process takes too long, a TimeoutExpired
        exception will be raised.
    
        There is an optional argument "input", allowing you to
        pass bytes or a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it will be used internally.
    
        By default, all communication is in bytes, and therefore any "input" should
        be bytes, and the stdout and stderr will be bytes. If in text mode, any
        "input" should be a string, and stdout and stderr will be strings decoded
        according to locale encoding, or by "encoding" if set. Text mode is
        triggered by setting any of text, encoding, errors or universal_newlines.
    
        The other arguments are the same as for the Popen constructor.
        """
        if input is not None:
            if kwargs.get('stdin') is not None:
                raise ValueError('stdin and input arguments may not both be used.')
            kwargs['stdin'] = PIPE
    
        if capture_output:
            if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:
                raise ValueError('stdout and stderr arguments may not be used '
                                 'with capture_output.')
            kwargs['stdout'] = PIPE
            kwargs['stderr'] = PIPE
    
        with Popen(*popenargs, **kwargs) as process:
            try:
                stdout, stderr = process.communicate(input, timeout=timeout)
            except TimeoutExpired as exc:
                process.kill()
                if _mswindows:
                    # Windows accumulates the output in a single blocking
                    # read() call run on child threads, with the timeout
                    # being done in a join() on those threads.  communicate()
                    # _after_ kill() is required to collect that and add it
                    # to the exception.
                    exc.stdout, exc.stderr = process.communicate()
                else:
                    # POSIX _communicate already populated the output so
                    # far into the TimeoutExpired exception.
                    process.wait()
                raise
            except:  # Including KeyboardInterrupt, communicate handled that.
                process.kill()
                # We don't call process.wait() as .__exit__ does that for us.
                raise
            retcode = process.poll()
            if check and retcode:
>               raise CalledProcessError(retcode, process.args,
                                         output=stdout, stderr=stderr)
E               subprocess.CalledProcessError: Command '['/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/cpp', '-E', '-x', 'c', '-I', '/Volumes/FlashGordon/Dropbox/code/nicktokatana/tests/fixtures/dts/include', '/var/folders/0s/42v7yl697hn0l1cdnx0vrvyr0000gn/T/tmp99j_o3gv.dts']' returned non-zero exit status 1.

/Users/malpern/.pyenv/versions/3.10.16/lib/python3.10/subprocess.py:526: CalledProcessError

During handling of the above exception, another exception occurred:

    def test_parse_large_keymap():
        """Test parsing a larger keymap."""
        fixtures_dir = os.path.join(os.path.dirname(__file__), "fixtures", "dts")
    
        preprocessor = DtsPreprocessor(
            include_paths=[os.path.join(fixtures_dir, "include")]
        )
        parser = DtsParser()
    
        input_file = os.path.join(fixtures_dir, "large_keymap.zmk")
>       preprocessed = preprocessor.preprocess(input_file)

tests/test_dts_parser.py:54: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <converter.dts.preprocessor.DtsPreprocessor object at 0x103e86ec0>
input_path = PosixPath('/Volumes/FlashGordon/Dropbox/code/nicktokatana/tests/fixtures/dts/large_keymap.zmk')
matrix_size = None

    def preprocess(
        self,
        input_path: str,
        matrix_size: Optional[Tuple[int, int]] = None,
    ) -> str:
        """Preprocess a DTS file.
    
        Args:
            input_path: Path to the input file
            matrix_size: Optional tuple of (rows, cols) for matrix transform
    
        Returns:
            The preprocessed content as a string
    
        Raises:
            PreprocessorError: If preprocessing fails
        """
        input_path = Path(input_path)
        if not input_path.exists():
            raise PreprocessorError(
                f"Input file does not exist: {input_path}",
                help_text=(
                    "Ensure the input file exists and has proper "
                    "read permissions"
                )
            )
    
        try:
            with open(input_path, "r") as f:
                content_for_cpp = f.read()
        except Exception as e:
            raise PreprocessorError(
                f"Failed to read input file: {str(e)}",
                file=str(input_path),
                help_text=(
                    "Ensure the file exists and has proper "
                    "read permissions"
                )
            )
    
        # Create a temporary file for the preprocessor input
        tmp_input = tempfile.NamedTemporaryFile(
            mode="w",
            delete=False,
            suffix=".dts",
            dir=None,  # Use system default temp dir (usually /tmp)
        )
        tmp_input.write(content_for_cpp)
        tmp_input.close()
        tmp_input_file = Path(tmp_input.name)
    
        try:
            # Build cpp command as a list for shell=False
            cpp_cmd = [
                str(self.cpp_path),
                "-E",
                "-x", "c",
            ]
            for path in self.include_paths:
                cpp_cmd.extend(["-I", str(path)])
            cpp_cmd.append(str(tmp_input_file))
    
            # Debug: print the constructed command list
            print("[DtsPreprocessor] cpp command:", cpp_cmd)
    
            # Run preprocessor with shell=False
            try:
                result = subprocess.run(
                    cpp_cmd,
                    capture_output=True,
                    text=True,
                    check=True,
                    shell=False,
                )
            except subprocess.CalledProcessError as e:
>               raise PreprocessorError(
                    "Failed to process DTS directives",
                    file=str(input_path),
                    context=str(e),
                    help_text=(
                        "Check for malformed DTS directives in "
                        "input file"
                    )
                )
E               converter.dts.preprocessor.PreprocessorError: Failed to process DTS directives

converter/dts/preprocessor.py:202: PreprocessorError
----------------------------- Captured stdout call -----------------------------
[DtsPreprocessor] cpp command: ['/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/cpp', '-E', '-x', 'c', '-I', '/Volumes/FlashGordon/Dropbox/code/nicktokatana/tests/fixtures/dts/include', '/var/folders/0s/42v7yl697hn0l1cdnx0vrvyr0000gn/T/tmp99j_o3gv.dts']
______________________________ test_preprocessor _______________________________

self = <converter.dts.preprocessor.DtsPreprocessor object at 0x103f10460>
input_path = PosixPath('/Volumes/FlashGordon/Dropbox/code/nicktokatana/tests/fixtures/dts/simple_keymap.zmk')
matrix_size = None

    def preprocess(
        self,
        input_path: str,
        matrix_size: Optional[Tuple[int, int]] = None,
    ) -> str:
        """Preprocess a DTS file.
    
        Args:
            input_path: Path to the input file
            matrix_size: Optional tuple of (rows, cols) for matrix transform
    
        Returns:
            The preprocessed content as a string
    
        Raises:
            PreprocessorError: If preprocessing fails
        """
        input_path = Path(input_path)
        if not input_path.exists():
            raise PreprocessorError(
                f"Input file does not exist: {input_path}",
                help_text=(
                    "Ensure the input file exists and has proper "
                    "read permissions"
                )
            )
    
        try:
            with open(input_path, "r") as f:
                content_for_cpp = f.read()
        except Exception as e:
            raise PreprocessorError(
                f"Failed to read input file: {str(e)}",
                file=str(input_path),
                help_text=(
                    "Ensure the file exists and has proper "
                    "read permissions"
                )
            )
    
        # Create a temporary file for the preprocessor input
        tmp_input = tempfile.NamedTemporaryFile(
            mode="w",
            delete=False,
            suffix=".dts",
            dir=None,  # Use system default temp dir (usually /tmp)
        )
        tmp_input.write(content_for_cpp)
        tmp_input.close()
        tmp_input_file = Path(tmp_input.name)
    
        try:
            # Build cpp command as a list for shell=False
            cpp_cmd = [
                str(self.cpp_path),
                "-E",
                "-x", "c",
            ]
            for path in self.include_paths:
                cpp_cmd.extend(["-I", str(path)])
            cpp_cmd.append(str(tmp_input_file))
    
            # Debug: print the constructed command list
            print("[DtsPreprocessor] cpp command:", cpp_cmd)
    
            # Run preprocessor with shell=False
            try:
>               result = subprocess.run(
                    cpp_cmd,
                    capture_output=True,
                    text=True,
                    check=True,
                    shell=False,
                )

converter/dts/preprocessor.py:194: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = None, capture_output = True, timeout = None, check = True
popenargs = (['/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/cpp', '-E', '-x', 'c', '-I', '/Volumes/FlashGordon/Dropbox/code/nicktokatana/tests/fixtures/dts/include', ...],)
kwargs = {'shell': False, 'stderr': -1, 'stdout': -1, 'text': True}
process = <Popen: returncode: 1 args: ['/Applications/Xcode.app/Contents/Developer/Too...>
stdout = '', stderr = 'cc: error: no input files\n', retcode = 1

    def run(*popenargs,
            input=None, capture_output=False, timeout=None, check=False, **kwargs):
        """Run command with arguments and return a CompletedProcess instance.
    
        The returned instance will have attributes args, returncode, stdout and
        stderr. By default, stdout and stderr are not captured, and those attributes
        will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them,
        or pass capture_output=True to capture both.
    
        If check is True and the exit code was non-zero, it raises a
        CalledProcessError. The CalledProcessError object will have the return code
        in the returncode attribute, and output & stderr attributes if those streams
        were captured.
    
        If timeout is given, and the process takes too long, a TimeoutExpired
        exception will be raised.
    
        There is an optional argument "input", allowing you to
        pass bytes or a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it will be used internally.
    
        By default, all communication is in bytes, and therefore any "input" should
        be bytes, and the stdout and stderr will be bytes. If in text mode, any
        "input" should be a string, and stdout and stderr will be strings decoded
        according to locale encoding, or by "encoding" if set. Text mode is
        triggered by setting any of text, encoding, errors or universal_newlines.
    
        The other arguments are the same as for the Popen constructor.
        """
        if input is not None:
            if kwargs.get('stdin') is not None:
                raise ValueError('stdin and input arguments may not both be used.')
            kwargs['stdin'] = PIPE
    
        if capture_output:
            if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:
                raise ValueError('stdout and stderr arguments may not be used '
                                 'with capture_output.')
            kwargs['stdout'] = PIPE
            kwargs['stderr'] = PIPE
    
        with Popen(*popenargs, **kwargs) as process:
            try:
                stdout, stderr = process.communicate(input, timeout=timeout)
            except TimeoutExpired as exc:
                process.kill()
                if _mswindows:
                    # Windows accumulates the output in a single blocking
                    # read() call run on child threads, with the timeout
                    # being done in a join() on those threads.  communicate()
                    # _after_ kill() is required to collect that and add it
                    # to the exception.
                    exc.stdout, exc.stderr = process.communicate()
                else:
                    # POSIX _communicate already populated the output so
                    # far into the TimeoutExpired exception.
                    process.wait()
                raise
            except:  # Including KeyboardInterrupt, communicate handled that.
                process.kill()
                # We don't call process.wait() as .__exit__ does that for us.
                raise
            retcode = process.poll()
            if check and retcode:
>               raise CalledProcessError(retcode, process.args,
                                         output=stdout, stderr=stderr)
E               subprocess.CalledProcessError: Command '['/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/cpp', '-E', '-x', 'c', '-I', '/Volumes/FlashGordon/Dropbox/code/nicktokatana/tests/fixtures/dts/include', '/var/folders/0s/42v7yl697hn0l1cdnx0vrvyr0000gn/T/tmp4yrd_mmn.dts']' returned non-zero exit status 1.

/Users/malpern/.pyenv/versions/3.10.16/lib/python3.10/subprocess.py:526: CalledProcessError

During handling of the above exception, another exception occurred:

    def test_preprocessor():
        # Get the absolute path to the test fixtures directory
        fixtures_dir = os.path.join(os.path.dirname(__file__), "fixtures", "dts")
        include_path = os.path.join(fixtures_dir, "include")
    
        # Create preprocessor with include path
        preprocessor = DtsPreprocessor(include_paths=[include_path])
    
        # Preprocess the test file
        input_file = os.path.join(fixtures_dir, "simple_keymap.zmk")
>       result = preprocessor.preprocess(input_file)

tests/test_dts_preprocessor.py:18: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <converter.dts.preprocessor.DtsPreprocessor object at 0x103f10460>
input_path = PosixPath('/Volumes/FlashGordon/Dropbox/code/nicktokatana/tests/fixtures/dts/simple_keymap.zmk')
matrix_size = None

    def preprocess(
        self,
        input_path: str,
        matrix_size: Optional[Tuple[int, int]] = None,
    ) -> str:
        """Preprocess a DTS file.
    
        Args:
            input_path: Path to the input file
            matrix_size: Optional tuple of (rows, cols) for matrix transform
    
        Returns:
            The preprocessed content as a string
    
        Raises:
            PreprocessorError: If preprocessing fails
        """
        input_path = Path(input_path)
        if not input_path.exists():
            raise PreprocessorError(
                f"Input file does not exist: {input_path}",
                help_text=(
                    "Ensure the input file exists and has proper "
                    "read permissions"
                )
            )
    
        try:
            with open(input_path, "r") as f:
                content_for_cpp = f.read()
        except Exception as e:
            raise PreprocessorError(
                f"Failed to read input file: {str(e)}",
                file=str(input_path),
                help_text=(
                    "Ensure the file exists and has proper "
                    "read permissions"
                )
            )
    
        # Create a temporary file for the preprocessor input
        tmp_input = tempfile.NamedTemporaryFile(
            mode="w",
            delete=False,
            suffix=".dts",
            dir=None,  # Use system default temp dir (usually /tmp)
        )
        tmp_input.write(content_for_cpp)
        tmp_input.close()
        tmp_input_file = Path(tmp_input.name)
    
        try:
            # Build cpp command as a list for shell=False
            cpp_cmd = [
                str(self.cpp_path),
                "-E",
                "-x", "c",
            ]
            for path in self.include_paths:
                cpp_cmd.extend(["-I", str(path)])
            cpp_cmd.append(str(tmp_input_file))
    
            # Debug: print the constructed command list
            print("[DtsPreprocessor] cpp command:", cpp_cmd)
    
            # Run preprocessor with shell=False
            try:
                result = subprocess.run(
                    cpp_cmd,
                    capture_output=True,
                    text=True,
                    check=True,
                    shell=False,
                )
            except subprocess.CalledProcessError as e:
>               raise PreprocessorError(
                    "Failed to process DTS directives",
                    file=str(input_path),
                    context=str(e),
                    help_text=(
                        "Check for malformed DTS directives in "
                        "input file"
                    )
                )
E               converter.dts.preprocessor.PreprocessorError: Failed to process DTS directives

converter/dts/preprocessor.py:202: PreprocessorError
----------------------------- Captured stdout call -----------------------------
[DtsPreprocessor] cpp command: ['/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/cpp', '-E', '-x', 'c', '-I', '/Volumes/FlashGordon/Dropbox/code/nicktokatana/tests/fixtures/dts/include', '/var/folders/0s/42v7yl697hn0l1cdnx0vrvyr0000gn/T/tmp4yrd_mmn.dts']
________________________ test_preprocessor_large_matrix ________________________

self = <converter.dts.preprocessor.DtsPreprocessor object at 0x103e9a110>
input_path = PosixPath('/Volumes/FlashGordon/Dropbox/code/nicktokatana/tests/fixtures/dts/large_keymap.zmk')
matrix_size = None

    def preprocess(
        self,
        input_path: str,
        matrix_size: Optional[Tuple[int, int]] = None,
    ) -> str:
        """Preprocess a DTS file.
    
        Args:
            input_path: Path to the input file
            matrix_size: Optional tuple of (rows, cols) for matrix transform
    
        Returns:
            The preprocessed content as a string
    
        Raises:
            PreprocessorError: If preprocessing fails
        """
        input_path = Path(input_path)
        if not input_path.exists():
            raise PreprocessorError(
                f"Input file does not exist: {input_path}",
                help_text=(
                    "Ensure the input file exists and has proper "
                    "read permissions"
                )
            )
    
        try:
            with open(input_path, "r") as f:
                content_for_cpp = f.read()
        except Exception as e:
            raise PreprocessorError(
                f"Failed to read input file: {str(e)}",
                file=str(input_path),
                help_text=(
                    "Ensure the file exists and has proper "
                    "read permissions"
                )
            )
    
        # Create a temporary file for the preprocessor input
        tmp_input = tempfile.NamedTemporaryFile(
            mode="w",
            delete=False,
            suffix=".dts",
            dir=None,  # Use system default temp dir (usually /tmp)
        )
        tmp_input.write(content_for_cpp)
        tmp_input.close()
        tmp_input_file = Path(tmp_input.name)
    
        try:
            # Build cpp command as a list for shell=False
            cpp_cmd = [
                str(self.cpp_path),
                "-E",
                "-x", "c",
            ]
            for path in self.include_paths:
                cpp_cmd.extend(["-I", str(path)])
            cpp_cmd.append(str(tmp_input_file))
    
            # Debug: print the constructed command list
            print("[DtsPreprocessor] cpp command:", cpp_cmd)
    
            # Run preprocessor with shell=False
            try:
>               result = subprocess.run(
                    cpp_cmd,
                    capture_output=True,
                    text=True,
                    check=True,
                    shell=False,
                )

converter/dts/preprocessor.py:194: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = None, capture_output = True, timeout = None, check = True
popenargs = (['/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/cpp', '-E', '-x', 'c', '-I', '/Volumes/FlashGordon/Dropbox/code/nicktokatana/tests/fixtures/dts/include', ...],)
kwargs = {'shell': False, 'stderr': -1, 'stdout': -1, 'text': True}
process = <Popen: returncode: 1 args: ['/Applications/Xcode.app/Contents/Developer/Too...>
stdout = '', stderr = 'cc: error: no input files\n', retcode = 1

    def run(*popenargs,
            input=None, capture_output=False, timeout=None, check=False, **kwargs):
        """Run command with arguments and return a CompletedProcess instance.
    
        The returned instance will have attributes args, returncode, stdout and
        stderr. By default, stdout and stderr are not captured, and those attributes
        will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them,
        or pass capture_output=True to capture both.
    
        If check is True and the exit code was non-zero, it raises a
        CalledProcessError. The CalledProcessError object will have the return code
        in the returncode attribute, and output & stderr attributes if those streams
        were captured.
    
        If timeout is given, and the process takes too long, a TimeoutExpired
        exception will be raised.
    
        There is an optional argument "input", allowing you to
        pass bytes or a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it will be used internally.
    
        By default, all communication is in bytes, and therefore any "input" should
        be bytes, and the stdout and stderr will be bytes. If in text mode, any
        "input" should be a string, and stdout and stderr will be strings decoded
        according to locale encoding, or by "encoding" if set. Text mode is
        triggered by setting any of text, encoding, errors or universal_newlines.
    
        The other arguments are the same as for the Popen constructor.
        """
        if input is not None:
            if kwargs.get('stdin') is not None:
                raise ValueError('stdin and input arguments may not both be used.')
            kwargs['stdin'] = PIPE
    
        if capture_output:
            if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:
                raise ValueError('stdout and stderr arguments may not be used '
                                 'with capture_output.')
            kwargs['stdout'] = PIPE
            kwargs['stderr'] = PIPE
    
        with Popen(*popenargs, **kwargs) as process:
            try:
                stdout, stderr = process.communicate(input, timeout=timeout)
            except TimeoutExpired as exc:
                process.kill()
                if _mswindows:
                    # Windows accumulates the output in a single blocking
                    # read() call run on child threads, with the timeout
                    # being done in a join() on those threads.  communicate()
                    # _after_ kill() is required to collect that and add it
                    # to the exception.
                    exc.stdout, exc.stderr = process.communicate()
                else:
                    # POSIX _communicate already populated the output so
                    # far into the TimeoutExpired exception.
                    process.wait()
                raise
            except:  # Including KeyboardInterrupt, communicate handled that.
                process.kill()
                # We don't call process.wait() as .__exit__ does that for us.
                raise
            retcode = process.poll()
            if check and retcode:
>               raise CalledProcessError(retcode, process.args,
                                         output=stdout, stderr=stderr)
E               subprocess.CalledProcessError: Command '['/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/cpp', '-E', '-x', 'c', '-I', '/Volumes/FlashGordon/Dropbox/code/nicktokatana/tests/fixtures/dts/include', '/var/folders/0s/42v7yl697hn0l1cdnx0vrvyr0000gn/T/tmpz31frbjb.dts']' returned non-zero exit status 1.

/Users/malpern/.pyenv/versions/3.10.16/lib/python3.10/subprocess.py:526: CalledProcessError

During handling of the above exception, another exception occurred:

    def test_preprocessor_large_matrix():
        # Get the absolute path to the test fixtures directory
        fixtures_dir = os.path.join(os.path.dirname(__file__), "fixtures", "dts")
        include_path = os.path.join(fixtures_dir, "include")
    
        # Create preprocessor with include path
        preprocessor = DtsPreprocessor(include_paths=[include_path])
    
        # Preprocess the test file
        input_file = os.path.join(fixtures_dir, "large_keymap.zmk")
>       result = preprocessor.preprocess(input_file)

tests/test_dts_preprocessor.py:45: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <converter.dts.preprocessor.DtsPreprocessor object at 0x103e9a110>
input_path = PosixPath('/Volumes/FlashGordon/Dropbox/code/nicktokatana/tests/fixtures/dts/large_keymap.zmk')
matrix_size = None

    def preprocess(
        self,
        input_path: str,
        matrix_size: Optional[Tuple[int, int]] = None,
    ) -> str:
        """Preprocess a DTS file.
    
        Args:
            input_path: Path to the input file
            matrix_size: Optional tuple of (rows, cols) for matrix transform
    
        Returns:
            The preprocessed content as a string
    
        Raises:
            PreprocessorError: If preprocessing fails
        """
        input_path = Path(input_path)
        if not input_path.exists():
            raise PreprocessorError(
                f"Input file does not exist: {input_path}",
                help_text=(
                    "Ensure the input file exists and has proper "
                    "read permissions"
                )
            )
    
        try:
            with open(input_path, "r") as f:
                content_for_cpp = f.read()
        except Exception as e:
            raise PreprocessorError(
                f"Failed to read input file: {str(e)}",
                file=str(input_path),
                help_text=(
                    "Ensure the file exists and has proper "
                    "read permissions"
                )
            )
    
        # Create a temporary file for the preprocessor input
        tmp_input = tempfile.NamedTemporaryFile(
            mode="w",
            delete=False,
            suffix=".dts",
            dir=None,  # Use system default temp dir (usually /tmp)
        )
        tmp_input.write(content_for_cpp)
        tmp_input.close()
        tmp_input_file = Path(tmp_input.name)
    
        try:
            # Build cpp command as a list for shell=False
            cpp_cmd = [
                str(self.cpp_path),
                "-E",
                "-x", "c",
            ]
            for path in self.include_paths:
                cpp_cmd.extend(["-I", str(path)])
            cpp_cmd.append(str(tmp_input_file))
    
            # Debug: print the constructed command list
            print("[DtsPreprocessor] cpp command:", cpp_cmd)
    
            # Run preprocessor with shell=False
            try:
                result = subprocess.run(
                    cpp_cmd,
                    capture_output=True,
                    text=True,
                    check=True,
                    shell=False,
                )
            except subprocess.CalledProcessError as e:
>               raise PreprocessorError(
                    "Failed to process DTS directives",
                    file=str(input_path),
                    context=str(e),
                    help_text=(
                        "Check for malformed DTS directives in "
                        "input file"
                    )
                )
E               converter.dts.preprocessor.PreprocessorError: Failed to process DTS directives

converter/dts/preprocessor.py:202: PreprocessorError
----------------------------- Captured stdout call -----------------------------
[DtsPreprocessor] cpp command: ['/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/cpp', '-E', '-x', 'c', '-I', '/Volumes/FlashGordon/Dropbox/code/nicktokatana/tests/fixtures/dts/include', '/var/folders/0s/42v7yl697hn0l1cdnx0vrvyr0000gn/T/tmpz31frbjb.dts']
_______________________ test_preprocessor_error_handling _______________________

    def test_preprocessor_error_handling():
        # Test with non-existent file
>       preprocessor = DtsPreprocessor(include_paths=["/nonexistent/path"])

tests/test_dts_preprocessor.py:60: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <converter.dts.preprocessor.DtsPreprocessor object at 0x104017100>
cpp_path = '/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/cpp'
include_paths = ['/nonexistent/path']

    def __init__(
        self,
        cpp_path: Optional[str] = None,
        include_paths: Optional[List[str]] = None,
    ):
        """Initialize the preprocessor.
    
        Args:
            cpp_path: Path to the C preprocessor executable
            include_paths: List of paths to search for include files
        """
        if cpp_path is None:
            cpp_path = (
                "/Applications/Xcode.app/Contents/Developer/Toolchains/"
                "XcodeDefault.xctoolchain/usr/bin/cpp"
            )
        cpp_path = str(cpp_path)
        if not cpp_path.endswith("cpp"):
            raise PreprocessorError(
                "Invalid cpp path",
                help_text="The cpp path must point to a cpp executable"
            )
        self.cpp_path = Path(cpp_path)
    
        self.include_paths = []
        if include_paths:
            for path in include_paths:
                path_obj = Path(path)
                if not path_obj.exists():
                    msg = f"Include path does not exist: {path}"
                    help_text = (
                        "Ensure all include paths exist and are accessible"
                    )
>                   raise PreprocessorError(msg, help_text=help_text)
E                   converter.dts.preprocessor.PreprocessorError: Include path does not exist: /nonexistent/path

converter/dts/preprocessor.py:82: PreprocessorError
______________________ test_main_simple_conversion_stdout ______________________

simple_dts_file = PosixPath('/private/var/folders/0s/42v7yl697hn0l1cdnx0vrvyr0000gn/T/pytest-of-malpern/pytest-75/test_main_simple_conversion_st0/simple.keymap')

    def test_main_simple_conversion_stdout(simple_dts_file: Path):
        """Test converting a simple file and printing to stdout."""
        result = run_main_script([str(simple_dts_file)])
    
>       assert result.returncode == 0
E       assert 1 == 0
E        +  where 1 = CompletedProcess(args=['python', '/Volumes/FlashGordon/Dropbox/code/nicktokatana/converter/main.py', '/private/var/fol...1cdnx0vrvyr0000gn/T/tmpk34ftnor.dts']\n", stderr='Error: Failed to convert keymap: Failed to process DTS directives\n').returncode

tests/test_main.py:93: AssertionError
_____________________ test_main_simple_conversion_outfile ______________________

simple_dts_file = PosixPath('/private/var/folders/0s/42v7yl697hn0l1cdnx0vrvyr0000gn/T/pytest-of-malpern/pytest-75/test_main_simple_conversion_ou0/simple.keymap')
tmp_path = PosixPath('/private/var/folders/0s/42v7yl697hn0l1cdnx0vrvyr0000gn/T/pytest-of-malpern/pytest-75/test_main_simple_conversion_ou0')

    def test_main_simple_conversion_outfile(simple_dts_file: Path, tmp_path: Path):
        """Test converting a simple file and writing to an output file."""
        output_file = tmp_path / "output.kanata"
        result = run_main_script([str(simple_dts_file), "-o", str(output_file)])
    
>       assert result.returncode == 0
E       assert 1 == 0
E        +  where 1 = CompletedProcess(args=['python', '/Volumes/FlashGordon/Dropbox/code/nicktokatana/converter/main.py', '/private/var/fol...1cdnx0vrvyr0000gn/T/tmpr40fh880.dts']\n", stderr='Error: Failed to convert keymap: Failed to process DTS directives\n').returncode

tests/test_main.py:106: AssertionError
____________________________ test_main_with_include ____________________________

dts_with_include_files = PosixPath('/private/var/folders/0s/42v7yl697hn0l1cdnx0vrvyr0000gn/T/pytest-of-malpern/pytest-75/test_main_with_include0/with_include.keymap')
tmp_path = PosixPath('/private/var/folders/0s/42v7yl697hn0l1cdnx0vrvyr0000gn/T/pytest-of-malpern/pytest-75/test_main_with_include0')

    def test_main_with_include(dts_with_include_files: Path, tmp_path: Path):
        """Test conversion with an include path."""
        include_dir = tmp_path / "include"
        result = run_main_script([str(dts_with_include_files), "-I", str(include_dir)])
    
>       assert result.returncode == 0
E       assert 1 == 0
E        +  where 1 = CompletedProcess(args=['python', '/Volumes/FlashGordon/Dropbox/code/nicktokatana/converter/main.py', '/private/var/fol...1cdnx0vrvyr0000gn/T/tmpk5511zil.dts']\n", stderr='Error: Failed to convert keymap: Failed to process DTS directives\n').returncode

tests/test_main.py:123: AssertionError
________________________ test_main_input_file_not_found ________________________

tmp_path = PosixPath('/private/var/folders/0s/42v7yl697hn0l1cdnx0vrvyr0000gn/T/pytest-of-malpern/pytest-75/test_main_input_file_not_found0')

    def test_main_input_file_not_found(tmp_path: Path):
        """Test error handling for non-existent input file."""
        non_existent_file = tmp_path / "does_not_exist.keymap"
        result = run_main_script([str(non_existent_file)])
    
        assert result.returncode != 0
>       assert "Error: Input file not found" in result.stderr
E       AssertionError: assert 'Error: Input file not found' in 'Error: Failed to convert keymap: Input file does not exist: /private/var/folders/0s/42v7yl697hn0l1cdnx0vrvyr0000gn/T/pytest-of-malpern/pytest-75/test_main_input_file_not_found0/does_not_exist.keymap\n'
E        +  where 'Error: Failed to convert keymap: Input file does not exist: /private/var/folders/0s/42v7yl697hn0l1cdnx0vrvyr0000gn/T/pytest-of-malpern/pytest-75/test_main_input_file_not_found0/does_not_exist.keymap\n' = CompletedProcess(args=['python', '/Volumes/FlashGordon/Dropbox/code/nicktokatana/converter/main.py', '/private/var/fol.../42v7yl697hn0l1cdnx0vrvyr0000gn/T/pytest-of-malpern/pytest-75/test_main_input_file_not_found0/does_not_exist.keymap\n').stderr

tests/test_main.py:136: AssertionError
____________________________ test_main_invalid_dts _____________________________

invalid_dts_file = PosixPath('/private/var/folders/0s/42v7yl697hn0l1cdnx0vrvyr0000gn/T/pytest-of-malpern/pytest-75/test_main_invalid_dts0/invalid.keymap')

    def test_main_invalid_dts(invalid_dts_file: Path):
        """Test error handling for invalid DTS content."""
        result = run_main_script([str(invalid_dts_file)])
    
        assert result.returncode != 0
        # Check for a generic conversion failure message,
        # as the exact parser error might change
        assert "Error: Failed to convert keymap" in result.stderr
>       assert result.stdout == ""
E       assert "[DtsPreproce...b51on.dts']\n" == ''
E         
E         + [DtsPreprocessor] cpp command: ['/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/cpp', '-E', '-x', 'c', '-I', '/Volumes/FlashGordon/Dropbox/code/nicktokatana/converter/dts/include', '/var/folders/0s/42v7yl697hn0l1cdnx0vrvyr0000gn/T/tmp2xjb51on.dts']

tests/test_main.py:148: AssertionError
=========================== short test summary info ============================
FAILED tests/dts/test_end_to_end.py::test_simple_keymap - TypeError: Layer.__...
FAILED tests/dts/test_end_to_end.py::test_complex_keymap_with_behaviors - Typ...
FAILED tests/dts/test_end_to_end.py::test_keymap_with_unicode - TypeError: La...
FAILED tests/dts/test_end_to_end.py::test_error_handling - converter.dts.erro...
FAILED tests/dts/test_end_to_end.py::test_keymap_with_combos - TypeError: Lay...
FAILED tests/dts/test_end_to_end.py::test_keymap_with_conditional_layers - Ty...
FAILED tests/dts/test_extractor.py::test_extract_simple_keymap - TypeError: L...
FAILED tests/dts/test_extractor.py::test_extract_with_behaviors - TypeError: ...
FAILED tests/dts/test_extractor.py::test_extract_multiple_layers - TypeError:...
FAILED tests/dts/test_extractor.py::test_extract_complex_bindings - TypeError...
FAILED tests/dts/test_extractor.py::test_extract_invalid_content - converter....
FAILED tests/dts/test_integration.py::test_full_pipeline_simple_keymap - Type...
FAILED tests/dts/test_integration.py::test_full_pipeline_with_behaviors - Typ...
FAILED tests/dts/test_integration.py::test_full_pipeline_multiple_layers - Ty...
FAILED tests/dts/test_integration.py::test_full_pipeline_complex_bindings - T...
FAILED tests/dts/test_integration.py::test_full_pipeline_error_handling - con...
FAILED tests/dts/test_parser.py::test_parse_error_handling - AssertionError: ...
FAILED tests/dts/test_parser.py::test_parse_zmk_specific_constructs - Asserti...
FAILED tests/dts/test_performance.py::test_preprocessor_performance - convert...
FAILED tests/dts/test_performance.py::test_parser_performance - converter.dts...
FAILED tests/dts/test_performance.py::test_extractor_performance - converter....
FAILED tests/dts/test_performance.py::test_full_pipeline_performance - conver...
FAILED tests/dts/test_preprocessor.py::test_preprocessor_initialization - Att...
FAILED tests/dts/test_preprocessor.py::test_preprocess_simple_file - converte...
FAILED tests/dts/test_preprocessor.py::test_preprocess_with_matrix - converte...
FAILED tests/dts/test_preprocessor.py::test_preprocess_with_includes - conver...
FAILED tests/dts/test_preprocessor.py::test_preprocess_invalid_file - convert...
FAILED tests/dts/test_preprocessor.py::test_preprocess_invalid_cpp_command - ...
FAILED tests/dts/test_preprocessor.py::test_preprocess_simple_keymap - conver...
FAILED tests/test_dts_parser.py::test_parse_simple_keymap - converter.dts.pre...
FAILED tests/test_dts_parser.py::test_parse_large_keymap - converter.dts.prep...
FAILED tests/test_dts_preprocessor.py::test_preprocessor - converter.dts.prep...
FAILED tests/test_dts_preprocessor.py::test_preprocessor_large_matrix - conve...
FAILED tests/test_dts_preprocessor.py::test_preprocessor_error_handling - con...
FAILED tests/test_main.py::test_main_simple_conversion_stdout - assert 1 == 0
FAILED tests/test_main.py::test_main_simple_conversion_outfile - assert 1 == 0
FAILED tests/test_main.py::test_main_with_include - assert 1 == 0
FAILED tests/test_main.py::test_main_input_file_not_found - AssertionError: a...
FAILED tests/test_main.py::test_main_invalid_dts - assert "[DtsPreproce...b51...
======================== 39 failed, 33 passed in 1.11s =========================
