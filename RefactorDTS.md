# Refactoring Plan: DTS-Based ZMK Parsing

## 1. Goal

To refactor the ZMK-to-Kanata converter to robustly parse **any** valid ZMK keymap file (`.zmk` or `.keymap`) generated by "Nick's configuration tool" by replacing the current regex/state-machine text parsing with a proper DeviceTree Source (DTS) parsing approach. This aims to significantly improve reliability and compatibility.

## 2. Current Limitations Addressed

The existing parser relies heavily on regular expressions and a fragile state machine to interpret the ZMK file as text. This approach suffers from:

*   **Sensitivity to Formatting:** Minor variations in whitespace, comments, or line breaks generated by Nick's tool can break the parser.
*   **Structural Rigidity:** Assumes a very specific structure and order of elements, failing on valid but differently structured DTS files.
*   **Incomplete Feature Support:** Difficulty handling the full range of DTS syntax and ZMK features (e.g., complex behaviors, includes, potential preprocessor usage).
*   **Lack of DTS Semantics:** Doesn't truly understand DeviceTree nodes, properties, labels, and references (`&`).

## Architecture Diagrams

### Current Architecture (Before Refactoring)

```ascii
+-----------------+      +---------------------------+      +-------------------+      +-------------------+      +-----------------+
|  ZMK Input File | ---> | Regex/State-Machine       | ---> | Intermediate      | ---> | Transformers      | ---> | Kanata Output   |
| (.zmk/.keymap)  |      | Parsers                   |      | Model             |      | LayerTransformer, |      +-----------------+
                       | (ZMKParser, LayerParser,  |      | (KeymapConfig,    |      |  etc.)            |
                       |  MacroParser, etc.)        |      |  Layer, Binding)  |      +-------------------+
                       +---------------------------+      +-------------------+      +-------------------+
                           ^       |
                           |       | (Fragile text parsing, sensitive to format)
                           +-------+
```

**Explanation (Before):**

1.  The input ZMK file is read as raw text.
2.  A collection of parsers (`ZMKParser`, `LayerParser`, etc.) use regular expressions and a state machine to try and identify keymap structures directly from the text.
3.  If successful, this populates an intermediate Python object model (`KeymapConfig`, `Layer`, etc.).
4.  Transformer classes then convert this intermediate model into the Kanata format.
5.  The main limitation is the fragility of the initial text parsing step.

### Proposed Architecture (After Refactoring)

```ascii
+-----------------+      +-------------------+      +----------------------+      +-----------------+      +-----------------+
|  ZMK Input File | ---> | C Preprocessor    | ---> | Preprocessed DTS Text| ---> | DTS Parser      | ---> | Abstract Syntax |
| (.zmk/.keymap)  |      | (External `cpp`)  |      | (Plain Text)         |      | (Python Module) |      | Tree (AST)      |
+-----------------+      +-------------------+      +----------------------+      +-----------------+      +-------+---------+
                                                                                                                    |
                                                                                                                    | (AST Traversal)
                                                                                                                    V
+-----------------+      +-------------------+      +-------------------+      +-------------------+      +--------+--------+
| Kanata Output   | <--- | Transformers      | <--- | Intermediate      | <--- | AST Extractor /   | <--- |                 |
| String/File     |      | (KanataTransformer|      | Model             |      | Mapper            |      |                 |
+-----------------+      | LayerTransformer, |      | (KeymapConfig,    |      | (Python Module)   |      +-----------------+
                       |  etc.) [REUSED]     |      |  Layer, Binding)  |      |                   |
                       +-------------------+      |  [REUSED]         |      +-------------------+
                                                +-------------------+
```

**Explanation (After):**

1.  The input ZMK file is first passed to an external C preprocessor (`cpp`) to handle includes and macros, producing plain DTS text.
2.  A new, dedicated DTS Parser processes this *preprocessed* text, understanding DTS syntax rules.
3.  This generates an Abstract Syntax Tree (AST), a structured representation of the keymap.
4.  An AST Extractor/Mapper traverses this tree, reliably extracting keymap information.
5.  The extracted information populates the *existing* intermediate Python models (`KeymapConfig`, etc.).
6.  The *existing* transformer classes convert the model to the Kanata format.
7.  This approach is more robust because it correctly handles the underlying DTS format and separates preprocessing from parsing.

## 3. Proposed Architecture & Workflow

The new architecture will process ZMK files in the following stages:

1.  **Preprocessing (`cpp`)**: Use an external C preprocessor (`cpp`) invoked via `subprocess` to handle all `#include`, `#define`, `#ifdef`, etc., directives. This yields a "flat" DTS file as plain text.
2.  **DTS Parsing**: Parse the preprocessed DTS text into an Abstract Syntax Tree (AST) using a dedicated DTS parser component. This AST accurately represents the nodes, properties, and structure.
3.  **AST Traversal & Extraction**: Navigate the generated AST to find relevant keymap information (global settings, layers, bindings, behaviors).
4.  **Model Population**: Map the extracted data from the AST into the *existing* intermediate Python data models (`KeymapConfig`, `Layer`, `Binding`, `MacroBehavior`, etc.).
5.  **Transformation**: Use the *existing* transformer components (`KanataTransformer`, `LayerTransformer`, etc.) to convert the populated Python models into the final Kanata configuration string.

## 4. Implementation Steps

### Step 4.1: Preprocessor Integration

*   **Component:** New Python module/function (e.g., `converter.dts.preprocess`).
*   **Task:** Implement logic using `subprocess.run` to execute `cpp` (assuming it's in the system PATH or configurable).
    *   Input: Path to the original ZMK file.
    *   Output: String containing the preprocessed DTS content.
    *   Error Handling: Capture `stderr` from `cpp` and raise appropriate Python exceptions.
*   **Testing:** Unit tests verifying `cpp` invocation, output capture, and error handling for valid/invalid ZMK inputs.

### Step 4.2: DTS Parser & AST Definition

*   **Component:** New Python package (e.g., `converter.dts.parser`).
*   **Task:** Implement a parser that takes the preprocessed DTS string and generates an AST.
    *   Define AST node classes (e.g., `Node`, `Property`, potentially specialized nodes).
    *   Implement parsing logic (e.g., using recursive descent or a parsing library if deemed necessary later) to handle:
        *   Node definitions (`node_name { ... };`)
        *   Property assignments (`prop_name = value;`)
        *   Labels (`label:`)
        *   References (`&label`)
        *   Basic data types (integers `<1 2>`, strings `"string"`, boolean properties `prop-present;`)
        *   Byte arrays (`[00 11 ff]`)
        *   Focus initially on syntax relevant to ZMK keymaps.
*   **Testing:** Extensive unit tests for parsing various valid DTS snippets, edge cases, and basic error conditions within the preprocessed DTS syntax.

### Step 4.3: AST Traversal & Data Extraction

*   **Component:** New Python module/class (e.g., `converter.dts.extractor.KeymapExtractor`).
*   **Task:** Develop logic to traverse the AST generated in Step 4.2.
    *   Locate the root node (`/`).
    *   Find the `keymap` node.
    *   Find `behaviors` node (if present).
    *   Iterate through child nodes of `keymap` to find `*_layer` nodes.
    *   Extract properties like `compatible`, `bindings`, `tapping-term-ms`, `#binding-cells`, etc.
    *   Resolve references (`&kp`, `&mt`, etc.) by looking up labels in the AST.
    *   Handle different binding formats found within the `bindings` property.
*   **Testing:** Unit tests providing sample ASTs and verifying correct extraction of layers, bindings, global settings, and behaviors.

### Step 4.4: Mapping AST Data to Existing Models

*   **Component:** Primarily within the `KeymapExtractor` (or a dedicated mapper class).
*   **Task:** Translate the raw data extracted from the AST into instances of the existing `converter.model.keymap_model` classes (`KeymapConfig`, `Layer`, `Binding`, `HoldTap`, `MacroBehavior`, etc.).
    *   This step replaces the core logic of the current `ZMKParser`, `LayerParser`, `GlobalSettingsParser`, etc.
*   **Testing:** Unit tests verifying correct model population based on various extracted AST data scenarios.

### Step 4.5: Integration & Refactoring Main Workflow

*   **Component:** Modify `converter.main` and potentially `converter.zmk_to_kanata`.
*   **Task:**
    *   Replace the old `ZMKParser().parse(...)` call with the new workflow:
        1.  `preprocess(input_file)`
        2.  `dts_parser.parse(preprocessed_text)`
        3.  `keymap_extractor.extract(ast)` -> returns `KeymapConfig` instance.
    *   Ensure the `KanataTransformer` receives the correctly populated `KeymapConfig`.
    *   Remove old parser classes (`ZMKParser`, `LayerParser`, `MacroParser`, `UnicodeParser`, `GlobalSettingsParser`, `TapHoldParser`).
*   **Testing:** Integration tests covering the flow from ZMK file input to Kanata string output using the new parsing pipeline.

## 5. Component Reuse

*   **Keep:**
    *   `converter.model.keymap_model`: The intermediate representation is still valuable.
    *   `converter.transformer.*`: These operate on the intermediate model and should require minimal changes.
    *   `converter.behaviors.*`: Classes representing behaviors (used by model and transformers) should remain.
    *   Existing Command-Line Interface (`converter.cli`, `converter.main` argument parsing).
*   **Replace/Remove:**
    *   `converter.parser.*` (All current parsers).
    *   The core parsing logic within `converter.zmk_to_kanata` or `converter.main`.

## 6. Testing Strategy

*   **Unit Tests:** Crucial for the new DTS parser, AST extractor, and preprocessor integration.
*   **Integration Tests:** Verify the pipeline stages work together correctly (preprocess -> parse -> extract -> map).
*   **End-to-End Tests:**
    *   Use a diverse set of ZMK files **known to be generated by Nick's tool**.
    *   Include files exercising various features (hold-taps, layers, basic macros, different key types).
    *   Compare the generated Kanata output against known-good or manually verified conversions for these specific input files.
    *   Test with intentionally malformed *preprocessed* DTS to check parser error handling.
    *   Test with files that cause `cpp` errors to check preprocessor error handling.

## 7. Potential Challenges

*   **Complexity of DTS:** Accurately parsing the full DTS specification can be complex; focus initially on the subset used by ZMK and Nick's tool.
*   **Variations in Nick's Tool Output:** While aiming for robustness, subtle or unexpected DTS constructs might still emerge. Requires a good test set.
*   **`cpp` Availability/Consistency:** Ensure the environment reliably provides a standard C preprocessor.
*   **AST Design:** Defining a clean and effective AST structure.

## 8. Conclusion

This refactoring represents a significant architectural shift but is necessary for achieving robust parsing of ZMK files. By leveraging an external C preprocessor and implementing a focused DTS parser, we can build a much more reliable and maintainable converter capable of handling the diverse outputs expected from Nick's configuration tool, while reusing the valuable existing model and transformation logic.

## Achieving Stability: Steps to Follow

### Current State (Checkpoint)
- We've documented the issues with the current architecture.
- We've created a detailed refactoring plan.
- We've created a new branch for the refactor.

### Next Steps for Stability

#### Phase 1: Preprocessor Integration
- Implement the C preprocessor integration first.
- This is the least invasive change and can be tested independently.
- It will help us understand the preprocessed output format.

#### Phase 2: DTS Parser Development
- Develop the DTS parser in isolation.
- Create comprehensive test cases.
- Focus on parsing the specific DTS constructs used in ZMK files.

#### Phase 3: AST Extraction
- Implement the AST traversal and extraction logic.
- Map to existing model classes.
- This is where we'll start removing the old parsing code.

#### Phase 4: Integration and Cleanup
- Integrate the new components.
- Remove old parsing code.
- Update tests and documentation.

### Key Stability Measures
- Each phase will have its own test suite.
- We'll maintain the existing model and transformation layers.
- We'll keep the old parser working until the new one is fully tested.
- We'll add integration tests for the complete pipeline.

## Implementation Progress

### Current Status (Updated)

#### Completed Components
1. **Models (converter/models.py)**
   - ✅ Basic model classes defined
   - ✅ Type definitions for keymap structure
   - ✅ Linter errors fixed (spacing and imports)
   - ✅ Proper handling of built-in behaviors
   - ✅ Fixed dataclass argument order issues

2. **DTS Parser (converter/dts/parser.py)**
   - ✅ Basic structure implemented
   - ✅ Handles node definitions and properties
   - ✅ Supports labels and references
   - ✅ Comprehensive test coverage
   - ✅ Proper error handling
   - ✅ Debug instrumentation
   - ✅ Integration tests passing
   - ✅ All linter issues fixed

3. **AST Definition (converter/dts/ast.py)**
   - ✅ Clean node and property classes
   - ✅ Proper type hints
   - ✅ Label and reference support
   - ✅ Tree traversal methods
   - ✅ No linter errors

4. **AST Extractor (converter/dts/extractor.py)**
   - ✅ Basic structure implemented
   - ✅ Layer extraction working
   - ✅ Behavior extraction working
   - ✅ Binding resolution working
   - ✅ Built-in behavior handling
   - ✅ All tests passing
   - ✅ Fixed array value handling
   - ✅ Fixed built-in behavior handling
   - ⚠️ Minor linter issues to fix (imports and spacing)

5. **DTS Preprocessor (converter/dts/preprocessor.py)**
   - ✅ Basic structure implemented
   - ✅ C preprocessor integration working
   - ✅ Include path handling
   - ✅ Matrix size detection
   - ✅ RC macro preservation
   - ✅ Error handling and logging
   - ✅ Cross-platform support (macOS/Windows)
   - ✅ All tests passing
   - ⚠️ Minor linter issues to fix (blank lines)

6. **End-to-End Tests (tests/dts/test_end_to_end.py)**
   - ✅ Simple keymap tests passing
   - ✅ Complex keymap with behaviors tests passing
   - ✅ Unicode handling tests passing
   - ✅ Error handling tests passing
   - ✅ Combo key tests passing
   - ✅ Conditional layer tests passing
   - ⚠️ Minor linter issues to fix (ambiguous variable names)

7. **Preprocessor Tests (tests/dts/test_preprocessor.py)**
   - ✅ Basic preprocessing tests
   - ✅ Include handling tests
   - ✅ Matrix transform tests
   - ✅ Error handling tests
   - ✅ Cross-platform tests
   - ⚠️ Minor linter issues to fix (line length)

#### Integration Steps (In Progress)
1. **Main Converter Integration**
   - ⚠️ Update converter/main.py to use new DTS parser
   - ⚠️ Implement preprocessor integration
   - ⚠️ Remove old parser classes
   - ⚠️ Update CLI interface

2. **Preprocessor Implementation**
   - ✅ Create DtsPreprocessor class
   - ✅ Implement cpp integration
   - ✅ Add include path handling
   - ✅ Add error handling and logging
   - ⚠️ Add performance testing

3. **Cleanup Tasks**
   - ⚠️ Remove old parser classes
   - ⚠️ Update documentation
   - ⚠️ Add performance testing
   - ⚠️ Fix remaining linter issues

#### Current Issues Identified
1. **Parser Architecture**:
   - ✓ Clean separation of concerns achieved
   - ✓ Proper error handling implemented
   - ✓ Comprehensive test coverage
   - ✓ All linter issues fixed

2. **Test Coverage**:
   - ✓ Parser has comprehensive unit tests
   - ✓ AST has proper test coverage
   - ✓ Extractor has comprehensive test coverage
   - ✓ Integration tests implemented and passing
   - ✓ End-to-end tests implemented and passing
   - ⚠️ Minor linter issues to fix

3. **Code Quality**:
   - ✓ Most linter errors fixed
   - ✓ Clear documentation
   - ✓ Maintainable structure
   - ⚠️ Some import cleanup needed
   - ⚠️ Some variable naming improvements needed

### Next Steps

1. **Immediate Tasks**:
   - Fix remaining linter issues in preprocessor and tests
   - Update main.py to use new DTS parser
   - Add preprocessor integration tests
   - Remove old parser classes

2. **Documentation Updates**:
   - Update API documentation
   - Add performance metrics
   - Update implementation details
   - Add troubleshooting guide

3. **Testing Additions**:
   - Add preprocessor tests
   - Add integration tests for full pipeline
   - Add performance tests
   - Update existing tests for new architecture

## 9. Detailed Implementation Plan with TDD Approach

### Phase 1: Preprocessor Integration (TDD)

#### Step 1.1: Test Setup
1. Create test directory structure:
   ```
   tests/
   ├── dts/
   │   ├── __init__.py
   │   ├── test_preprocessor.py
   │   ├── test_parser.py
   │   └── test_extractor.py
   ├── fixtures/
   │   └── dts/
   │       ├── simple_keymap.zmk
   │       ├── with_includes.zmk
   │       └── with_macros.zmk
   ```

2. Create initial test cases for preprocessor:
   - Test basic file preprocessing
   - Test include handling
   - Test macro expansion
   - Test error handling for invalid files

#### Step 1.2: Preprocessor Implementation
1. Create `converter/dts/preprocessor.py`:
   ```python
   class DtsPreprocessor:
       def preprocess(self, input_file: str) -> str:
           """
           Preprocess a DTS file using cpp.
           Returns the preprocessed content as a string.
           """
   ```

2. Implement error handling and logging:
   - Capture cpp stderr
   - Raise appropriate exceptions
   - Add detailed logging

3. Add configuration options:
   - Allow custom cpp path
   - Support custom include paths
   - Handle different cpp versions

### Phase 2: DTS Parser Development (TDD)

#### Step 2.1: AST Definition
1. Create `converter/dts/ast.py`:
   ```python
   class Node:
       def __init__(self, name: str, properties: Dict[str, Any], children: List['Node']):
           self.name = name
           self.properties = properties
           self.children = children

   class Property:
       def __init__(self, name: str, value: Any):
           self.name = name
           self.value = value
   ```

2. Add test cases for AST:
   - Test node creation
   - Test property handling
   - Test tree traversal

#### Step 2.2: Parser Implementation
1. Create `converter/dts/parser.py`:
   ```python
   class DtsParser:
       def parse(self, content: str) -> Node:
           """
           Parse preprocessed DTS content into an AST.
           """
   ```

2. Implement parsing for:
   - Node definitions
   - Property assignments
   - Labels and references
   - Basic data types
   - Byte arrays

3. Add error handling:
   - Syntax errors
   - Invalid references
   - Malformed properties

### Phase 3: AST Extraction (TDD)

#### Step 3.1: Extractor Tests
1. Create test cases for:
   - Layer extraction
   - Binding resolution
   - Behavior mapping
   - Global settings

2. Add test fixtures:
   - Simple keymap AST
   - Complex keymap with behaviors
   - Keymap with macros

#### Step 3.2: Extractor Implementation
1. Create `converter/dts/extractor.py`:
   ```python
   class KeymapExtractor:
       def extract(self, ast: Node) -> KeymapConfig:
           """
           Extract keymap information from AST.
           Returns a populated KeymapConfig instance.
           """
   ```

2. Implement extraction for:
   - Root node traversal
   - Layer node identification
   - Binding property parsing
   - Behavior resolution

3. Add validation:
   - Required properties
   - Valid references
   - Type checking

### Testing Strategy

#### Unit Tests
1. **Preprocessor Tests**
   ```python
   def test_preprocess_simple_file():
       preprocessor = DtsPreprocessor()
       result = preprocessor.preprocess("simple_keymap.zmk")
       assert "keymap" in result
       assert "bindings" in result

   def test_preprocess_with_includes():
       preprocessor = DtsPreprocessor()
       result = preprocessor.preprocess("with_includes.zmk")
       assert "included_content" in result
   ```

2. **Parser Tests**
   ```python
   def test_parse_simple_node():
       parser = DtsParser()
       ast = parser.parse("node { property = value; };")
       assert ast.name == "node"
       assert ast.properties["property"] == "value"

   def test_parse_complex_tree():
       parser = DtsParser()
       ast = parser.parse(complex_dts)
       assert len(ast.children) > 0
       assert "bindings" in ast.properties
   ```

3. **Extractor Tests**
   ```python
   def test_extract_layers():
       extractor = KeymapExtractor()
       config = extractor.extract(sample_ast)
       assert len(config.layers) > 0
       assert config.layers[0].name == "default"

   def test_extract_bindings():
       extractor = KeymapExtractor()
       config = extractor.extract(sample_ast)
       assert len(config.layers[0].bindings) > 0
       assert isinstance(config.layers[0].bindings[0], Binding)
   ```

#### Integration Tests
1. **Full Pipeline Tests**
   ```python
   def test_full_conversion():
       preprocessor = DtsPreprocessor()
       parser = DtsParser()
       extractor = KeymapExtractor()
       
       preprocessed = preprocessor.preprocess("test.zmk")
       ast = parser.parse(preprocessed)
       config = extractor.extract(ast)
       
       assert config.is_valid()
       assert len(config.layers) > 0
   ```

2. **Error Handling Tests**
   ```python
   def test_invalid_file_handling():
       with pytest.raises(PreprocessorError):
           preprocessor.preprocess("invalid.zmk")
           
   def test_invalid_ast_handling():
       with pytest.raises(ParserError):
           parser.parse("invalid { syntax")
   ```

### Implementation Order

1. **Week 1: Preprocessor**
   - Set up test infrastructure
   - Implement basic preprocessing
   - Add include handling
   - Add error handling

2. **Week 2: Parser**
   - Define AST structure
   - Implement basic parsing
   - Add complex node handling
   - Add error handling

3. **Week 3: Extractor**
   - Implement basic extraction
   - Add layer handling
   - Add binding resolution
   - Add behavior mapping

4. **Week 4: Integration**
   - Connect all components
   - Add full pipeline tests
   - Remove old parsing code
   - Update documentation

### Success Criteria

1. **Preprocessor**
   - ✓ Handles all ZMK file formats
   - ✓ Correctly processes includes
   - ✓ Proper error messages
   - ✓ 100% test coverage

2. **Parser**
   - ✓ Parses all valid DTS constructs
   - ✓ Generates correct AST
   - ✓ Handles errors gracefully
   - ✓ 100% test coverage

3. **Extractor**
   - ✓ Extracts all keymap information
   - ✓ Correctly maps to model
   - ✓ Handles edge cases
   - ✓ 100% test coverage

4. **Integration**
   - ✓ All tests pass
   - ✓ No regressions
   - ✓ Documentation updated
   - ✓ Performance acceptable