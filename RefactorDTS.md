# Refactoring Plan: DTS-Based ZMK Parsing

## 1. Goal

To refactor the ZMK-to-Kanata converter to robustly parse **any** valid ZMK keymap file (`.zmk` or `.keymap`) generated by "Nick's configuration tool" by replacing the current regex/state-machine text parsing with a proper DeviceTree Source (DTS) parsing approach. This aims to significantly improve reliability and compatibility.

## 2. Current Limitations Addressed

The existing parser relies heavily on regular expressions and a fragile state machine to interpret the ZMK file as text. This approach suffers from:

*   **Sensitivity to Formatting:** Minor variations in whitespace, comments, or line breaks generated by Nick's tool can break the parser.
*   **Structural Rigidity:** Assumes a very specific structure and order of elements, failing on valid but differently structured DTS files.
*   **Incomplete Feature Support:** Difficulty handling the full range of DTS syntax and ZMK features (e.g., complex behaviors, includes, potential preprocessor usage).
*   **Lack of DTS Semantics:** Doesn't truly understand DeviceTree nodes, properties, labels, and references (`&`).

## Architecture Diagrams

### Current Architecture (Before Refactoring)

```ascii
+-----------------+      +---------------------------+      +-------------------+      +-------------------+      +-----------------+
|  ZMK Input File | ---> | Regex/State-Machine       | ---> | Intermediate      | ---> | Transformers      | ---> | Kanata Output   |
| (.zmk/.keymap)  |      | Parsers                   |      | Model             |      | (KanataTransformer|      | String/File     |
+-----------------+      | (ZMKParser, LayerParser,  |      | (KeymapConfig,    |      | LayerTransformer, |      +-----------------+
                       |  MacroParser, etc.)        |      |  Layer, Binding)  |      |  etc.)            |
                       +---------------------------+      +-------------------+      +-------------------+
                           ^       |
                           |       | (Fragile text parsing, sensitive to format)
                           +-------+
```

**Explanation (Before):**

1.  The input ZMK file is read as raw text.
2.  A collection of parsers (`ZMKParser`, `LayerParser`, etc.) use regular expressions and a state machine to try and identify keymap structures directly from the text.
3.  If successful, this populates an intermediate Python object model (`KeymapConfig`, `Layer`, etc.).
4.  Transformer classes then convert this intermediate model into the Kanata format.
5.  The main limitation is the fragility of the initial text parsing step.

### Proposed Architecture (After Refactoring)

```ascii
+-----------------+      +-------------------+      +----------------------+      +-----------------+      +-----------------+
|  ZMK Input File | ---> | C Preprocessor    | ---> | Preprocessed DTS Text| ---> | DTS Parser      | ---> | Abstract Syntax |
| (.zmk/.keymap)  |      | (External `cpp`)  |      | (Plain Text)         |      | (Python Module) |      | Tree (AST)      |
+-----------------+      +-------------------+      +----------------------+      +-----------------+      +-------+---------+
                                                                                                                    |
                                                                                                                    | (AST Traversal)
                                                                                                                    V
+-----------------+      +-------------------+      +-------------------+      +-------------------+      +--------+--------+
| Kanata Output   | <--- | Transformers      | <--- | Intermediate      | <--- | AST Extractor /   | <--- |                 |
| String/File     |      | (KanataTransformer|      | Model             |      | Mapper            |      |                 |
+-----------------+      | LayerTransformer, |      | (KeymapConfig,    |      | (Python Module)   |      +-----------------+
                       |  etc.) [REUSED]     |      |  Layer, Binding)  |      |                   |
                       +-------------------+      |  [REUSED]         |      +-------------------+
                                                +-------------------+
```

**Explanation (After):**

1.  The input ZMK file is first passed to an external C preprocessor (`cpp`) to handle includes and macros, producing plain DTS text.
2.  A new, dedicated DTS Parser processes this *preprocessed* text, understanding DTS syntax rules.
3.  This generates an Abstract Syntax Tree (AST), a structured representation of the keymap.
4.  An AST Extractor/Mapper traverses this tree, reliably extracting keymap information.
5.  The extracted information populates the *existing* intermediate Python models (`KeymapConfig`, etc.).
6.  The *existing* transformer classes convert the model to the Kanata format.
7.  This approach is more robust because it correctly handles the underlying DTS format and separates preprocessing from parsing.

## 3. Proposed Architecture & Workflow

The new architecture will process ZMK files in the following stages:

1.  **Preprocessing (`cpp`)**: Use an external C preprocessor (`cpp`) invoked via `subprocess` to handle all `#include`, `#define`, `#ifdef`, etc., directives. This yields a "flat" DTS file as plain text.
2.  **DTS Parsing**: Parse the preprocessed DTS text into an Abstract Syntax Tree (AST) using a dedicated DTS parser component. This AST accurately represents the nodes, properties, and structure.
3.  **AST Traversal & Extraction**: Navigate the generated AST to find relevant keymap information (global settings, layers, bindings, behaviors).
4.  **Model Population**: Map the extracted data from the AST into the *existing* intermediate Python data models (`KeymapConfig`, `Layer`, `Binding`, `MacroBehavior`, etc.).
5.  **Transformation**: Use the *existing* transformer components (`KanataTransformer`, `LayerTransformer`, etc.) to convert the populated Python models into the final Kanata configuration string.

## 4. Implementation Steps

### Step 4.1: Preprocessor Integration

*   **Component:** New Python module/function (e.g., `converter.dts.preprocess`).
*   **Task:** Implement logic using `subprocess.run` to execute `cpp` (assuming it's in the system PATH or configurable).
    *   Input: Path to the original ZMK file.
    *   Output: String containing the preprocessed DTS content.
    *   Error Handling: Capture `stderr` from `cpp` and raise appropriate Python exceptions.
*   **Testing:** Unit tests verifying `cpp` invocation, output capture, and error handling for valid/invalid ZMK inputs.

### Step 4.2: DTS Parser & AST Definition

*   **Component:** New Python package (e.g., `converter.dts.parser`).
*   **Task:** Implement a parser that takes the preprocessed DTS string and generates an AST.
    *   Define AST node classes (e.g., `Node`, `Property`, potentially specialized nodes).
    *   Implement parsing logic (e.g., using recursive descent or a parsing library if deemed necessary later) to handle:
        *   Node definitions (`node_name { ... };`)
        *   Property assignments (`prop_name = value;`)
        *   Labels (`label:`)
        *   References (`&label`)
        *   Basic data types (integers `<1 2>`, strings `"string"`, boolean properties `prop-present;`)
        *   Byte arrays (`[00 11 ff]`)
        *   Focus initially on syntax relevant to ZMK keymaps.
*   **Testing:** Extensive unit tests for parsing various valid DTS snippets, edge cases, and basic error conditions within the preprocessed DTS syntax.

### Step 4.3: AST Traversal & Data Extraction

*   **Component:** New Python module/class (e.g., `converter.dts.extractor.KeymapExtractor`).
*   **Task:** Develop logic to traverse the AST generated in Step 4.2.
    *   Locate the root node (`/`).
    *   Find the `keymap` node.
    *   Find `behaviors` node (if present).
    *   Iterate through child nodes of `keymap` to find `*_layer` nodes.
    *   Extract properties like `compatible`, `bindings`, `tapping-term-ms`, `#binding-cells`, etc.
    *   Resolve references (`&kp`, `&mt`, etc.) by looking up labels in the AST.
    *   Handle different binding formats found within the `bindings` property.
*   **Testing:** Unit tests providing sample ASTs and verifying correct extraction of layers, bindings, global settings, and behaviors.

### Step 4.4: Mapping AST Data to Existing Models

*   **Component:** Primarily within the `KeymapExtractor` (or a dedicated mapper class).
*   **Task:** Translate the raw data extracted from the AST into instances of the existing `converter.model.keymap_model` classes (`KeymapConfig`, `Layer`, `Binding`, `HoldTap`, `MacroBehavior`, etc.).
    *   This step replaces the core logic of the current `ZMKParser`, `LayerParser`, `GlobalSettingsParser`, etc.
*   **Testing:** Unit tests verifying correct model population based on various extracted AST data scenarios.

### Step 4.5: Integration & Refactoring Main Workflow

*   **Component:** Modify `converter.main` and potentially `converter.zmk_to_kanata`.
*   **Task:**
    *   Replace the old `ZMKParser().parse(...)` call with the new workflow:
        1.  `preprocess(input_file)`
        2.  `dts_parser.parse(preprocessed_text)`
        3.  `keymap_extractor.extract(ast)` -> returns `KeymapConfig` instance.
    *   Ensure the `KanataTransformer` receives the correctly populated `KeymapConfig`.
    *   Remove old parser classes (`ZMKParser`, `LayerParser`, `MacroParser`, `UnicodeParser`, `GlobalSettingsParser`, `TapHoldParser`).
*   **Testing:** Integration tests covering the flow from ZMK file input to Kanata string output using the new parsing pipeline.

## 5. Component Reuse

*   **Keep:**
    *   `converter.model.keymap_model`: The intermediate representation is still valuable.
    *   `converter.transformer.*`: These operate on the intermediate model and should require minimal changes.
    *   `converter.behaviors.*`: Classes representing behaviors (used by model and transformers) should remain.
    *   Existing Command-Line Interface (`converter.cli`, `converter.main` argument parsing).
*   **Replace/Remove:**
    *   `converter.parser.*` (All current parsers).
    *   The core parsing logic within `converter.zmk_to_kanata` or `converter.main`.

## 6. Testing Strategy

*   **Unit Tests:** Crucial for the new DTS parser, AST extractor, and preprocessor integration.
*   **Integration Tests:** Verify the pipeline stages work together correctly (preprocess -> parse -> extract -> map).
*   **End-to-End Tests:**
    *   Use a diverse set of ZMK files **known to be generated by Nick's tool**.
    *   Include files exercising various features (hold-taps, layers, basic macros, different key types).
    *   Compare the generated Kanata output against known-good or manually verified conversions for these specific input files.
    *   Test with intentionally malformed *preprocessed* DTS to check parser error handling.
    *   Test with files that cause `cpp` errors to check preprocessor error handling.

## 7. Potential Challenges

*   **Complexity of DTS:** Accurately parsing the full DTS specification can be complex; focus initially on the subset used by ZMK and Nick's tool.
*   **Variations in Nick's Tool Output:** While aiming for robustness, subtle or unexpected DTS constructs might still emerge. Requires a good test set.
*   **`cpp` Availability/Consistency:** Ensure the environment reliably provides a standard C preprocessor.
*   **AST Design:** Defining a clean and effective AST structure.

## 8. Conclusion

This refactoring represents a significant architectural shift but is necessary for achieving robust parsing of ZMK files. By leveraging an external C preprocessor and implementing a focused DTS parser, we can build a much more reliable and maintainable converter capable of handling the diverse outputs expected from Nick's configuration tool, while reusing the valuable existing model and transformation logic.